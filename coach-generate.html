<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GR Perform - AI Workout Lab v2.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ==============================================
           LAYOUT MASTER - PRIORITÃ€ MASSIMA
           ============================================== */
        
        /* DESKTOP DEFAULT - 3 COLONNE */
        .main-grid {
            display: grid !important;
            grid-template-columns: 260px 1fr 360px !important;
            grid-template-areas: "experts conversation workout" !important;
            grid-template-rows: 1fr !important;
            gap: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            flex-wrap: nowrap !important;
        }
        
        /* SUSPENSE: Nascondi la colonna workout temporaneamente */
        .main {
            width: calc(100vw - 72px) !important;
            max-width: calc(100vw - 72px) !important;
        }
        .workout-panel {
            display: none !important;
        }
        
        /* FORZA POSIZIONE PANNELLI */
        .main-grid > .experts-panel,
        .main-grid > .conversation-panel,
        .main-grid > .workout-panel {
            grid-row: 1 !important;
        }
        
        .experts-panel { 
            grid-area: experts !important;
            grid-column: 1 !important;
            display: flex !important;
            flex-direction: column !important;
        }
        .conversation-panel { 
            grid-area: conversation !important; 
            grid-column: 2 !important;
            display: flex !important;
        }
        .workout-panel { 
            grid-area: workout !important;
            grid-column: 3 !important;
            display: flex !important;
            flex-direction: column !important;
            background: var(--gray-900) !important;
            background-color: #0A0A0A !important;
            border-left: 1px solid #1A1A1A !important;
        }
        
        .hero-header {
            display: grid !important;
            grid-template-columns: 260px 1fr 360px !important;
        }
        
        /* FAB nascosto su desktop */
        .mobile-fab { display: none !important; }
        .workout-panel .close-mobile { display: none !important; }
        
        /* DESKTOP LARGE >1400px */
        @media (min-width: 1401px) {
            .main-grid { grid-template-columns: 300px 1fr 400px !important; }
            .hero-header { grid-template-columns: 300px 1fr 400px !important; }
        }
        
        /* DESKTOP MEDIUM 1200-1400px - giÃ  coperto dal default */
        
        /* DESKTOP SMALL 1000-1199px */
        @media (min-width: 1000px) and (max-width: 1199px) {
            .main-grid { grid-template-columns: 220px 1fr 320px !important; }
            .hero-header { grid-template-columns: 220px 1fr 320px !important; }
        }
        
        /* TABLET LANDSCAPE 900-999px */
        @media (min-width: 900px) and (max-width: 999px) {
            .main-grid { grid-template-columns: 180px 1fr 280px !important; }
            .hero-header { grid-template-columns: 180px 1fr 280px !important; }
        }
        
        /* TABLET/MOBILE <900px */
        @media (max-width: 899px) {
            .main-grid { 
                grid-template-columns: 1fr !important;
                grid-template-areas: "conversation" !important;
                width: 100% !important;
            }
            .hero-header { grid-template-columns: 1fr !important; }
            .workout-panel { display: none !important; }
            .experts-panel { display: none !important; }
            .mobile-fab { display: flex !important; }
        }
        
        /* MOBILE <768px */
        @media (max-width: 767px) {
            html, body {
                overflow-x: hidden !important;
                width: 100% !important;
                max-width: 100vw !important;
            }
            
            .sidebar {
                position: fixed !important;
                left: 0 !important; 
                right: 0 !important; 
                bottom: 0 !important;
                top: auto !important;
                width: 100% !important; 
                height: 70px !important;
                flex-direction: row !important;
                padding: 0 !important;
                justify-content: space-around !important;
                align-items: center !important;
                border-right: none !important;
                border-top: 1px solid var(--gray-700) !important;
                background: var(--black) !important;
                z-index: 200 !important;
            }
            
            .logo, .nav-spacer { display: none !important; }
            
            .nav-item {
                margin-bottom: 0 !important;
                width: 50px !important;
                height: 50px !important;
                font-size: 18px !important;
            }
            
            .nav-item.active::before { display: none !important; }
            
            .main { 
                margin-left: 0 !important; 
                margin-bottom: 70px !important;
                width: 100% !important;
                max-width: 100vw !important;
                overflow-x: hidden !important;
            }
            
            .main-grid {
                width: 100% !important;
                max-width: 100% !important;
                overflow-x: hidden !important;
            }
            
            .conversation-panel {
                width: 100% !important;
                max-width: 100vw !important;
            }
            
            .hero-header {
                width: 100% !important;
            }
            
            .hero-header > .hero-top { 
                padding: 20px 16px 10px !important; 
            }
            
            .hero-title {
                font-size: 28px !important;
                letter-spacing: -1px !important;
            }
            
            .hero-subtitle { display: none !important; }
            
            .mobile-fab {
                display: flex !important;
                position: fixed !important;
                bottom: 86px !important;
                right: 16px !important;
                z-index: 150 !important;
            }
            
            .workout-panel .close-mobile { display: flex !important; }
        }
        
        /* Mobile workout overlay */
        .workout-panel.mobile-show { 
            display: flex !important; 
            position: fixed !important;
            top: 0 !important; 
            right: 0 !important; 
            bottom: 70px !important; 
            left: 0 !important;
            z-index: 100 !important;
            background: var(--gray-900) !important;
            width: 100% !important;
            max-width: 100vw !important;
        }
        /* ============================================== */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html {
            overflow-x: hidden;
            width: 100%;
        }

        :root {
            --red: #D71921;
            --black: #000;
            --gray-900: #0A0A0A;
            --gray-850: #0E0E0E;
            --gray-800: #111;
            --gray-750: #151515;
            --gray-700: #1A1A1A;
            --gray-650: #1F1F1F;
            --gray-600: #222;
            --gray-500: #666;
            --gray-400: #888;
            --gray-300: #AAA;
            --white: #FFF;
            --green: #00D26A;
            --blue: #2196F3;
            --purple: #9C27B0;
            --orange: #FF9800;
            --cyan: #00BCD4;
            
            /* Nike Timing */
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
            --transition-fast: 0.15s var(--ease-out-expo);
            --transition-medium: 0.3s var(--ease-out-expo);
            --transition-slow: 0.5s var(--ease-out-expo);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--black);
            color: var(--white);
            min-height: 100vh;
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }

        /* SIDEBAR - NIKE STYLE */
        .sidebar {
            position: fixed;
            left: 0; top: 0;
            width: 72px; height: 100vh;
            background: var(--gray-900);
            border-right: 1px solid var(--gray-700);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            z-index: 100;
        }

        .logo {
            width: 44px; height: 44px;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            margin-bottom: 40px;
            cursor: pointer;
            overflow: hidden;
        }

        .logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .nav-item {
            width: 44px; height: 44px;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-500);
            margin-bottom: 8px;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-decoration: none;
            position: relative;
        }

        .nav-item:hover { background: var(--gray-800); color: var(--white); }
        .nav-item.active { background: var(--red); color: var(--white); }
        .nav-item.active::before {
            display: none;
        }

        .nav-spacer { flex: 1; }

        /* MAIN */
        .main { margin-left: 72px; min-height: 100vh; }

        /* HERO HEADER - Nike Style (base removed, defined in Nike revamp section) */

        .hero-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 32px;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 12px;
            color: var(--red);
        }

        .hero-title {
            font-size: clamp(36px, 5vw, 56px);
            font-weight: 900;
            letter-spacing: -2px;
            line-height: 0.95;
            text-transform: uppercase;
        }

        .hero-title span {
            background: none;
            -webkit-text-fill-color: unset;
            color: var(--white);
        }

        .hero-subtitle {
            color: var(--gray-400);
            font-size: 14px;
            margin-top: 16px;
            max-width: 480px;
            line-height: 1.5;
        }

        /* ATHLETE SELECTOR - NIKE SQUARED */
        .athlete-selector {
            background: var(--gray-900);
            border-radius: 0;
            padding: 20px 24px;
            border: 1px solid var(--gray-700);
            min-width: 320px;
        }

        .selector-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--gray-500);
            margin-bottom: 12px;
        }

        .selector-row {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .athlete-avatar-lg {
            width: 48px; height: 48px;
            border-radius: 0;
            background: var(--gray-800);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 16px;
            overflow: hidden;
        }

        .athlete-avatar-lg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .athlete-selector select {
            flex: 1;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            color: var(--white);
            font-size: 14px;
            font-weight: 600;
            outline: none;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 0;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpolyline points='6,9 12,15 18,9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 44px;
            transition: border-color var(--transition-fast);
        }
        
        .athlete-selector select:focus {
            border-color: var(--red);
        }

        .athlete-selector select option { background: var(--gray-800); }

        /* STEPS INDICATOR - NIKE SQUARED */
        .steps-container {
            display: flex;
            gap: 1px;
            background: var(--gray-700);
            border-radius: 0;
            overflow: hidden;
            border: none;
        }

        .step-item {
            flex: 1;
            padding: 18px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all var(--transition-fast);
            border-right: none;
            position: relative;
            background: var(--gray-900);
        }

        .step-item:last-child { border-right: none; }

        .step-item:hover {
            background: var(--gray-800);
        }

        .step-item::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--red);
            transform: scaleX(0);
            transition: transform var(--transition-medium);
        }

        .step-item.active::after { transform: scaleX(1); }
        .step-item.completed::after { background: var(--green); transform: scaleX(1); }

        .step-num {
            width: 32px; height: 32px;
            border-radius: 0;
            background: var(--gray-800);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 13px;
            transition: all var(--transition-fast);
        }

        .step-item.active .step-num { background: var(--red); }
        .step-item.completed .step-num { background: var(--green); }

        .step-info h4 { font-size: 13px; font-weight: 700; }
        .step-info p { font-size: 11px; color: var(--gray-400); margin-top: 2px; }

        /* MAIN GRID - Definito in css/coach-layout.css */

        /* Stili base pannelli (layout gestito da coach-layout.css) */

        /* LEFT PANEL - EXPERTS - NIKE SQUARED */
        .experts-panel {
            background: var(--gray-900);
            border-right: 1px solid var(--gray-700);
            padding: 24px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--gray-500);
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--gray-700);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .expert-card {
            background: var(--gray-800);
            border-radius: 0;
            padding: 14px;
            margin-bottom: 1px;
            cursor: pointer;
            transition: all var(--transition-fast);
            border: none;
            position: relative;
            overflow: hidden;
        }

        .expert-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 3px;
            height: 100%;
            background: var(--red);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .expert-card:hover {
            background: var(--gray-750);
        }
        
        .expert-card:hover::before {
            opacity: 1;
        }

        .expert-card.thinking::before { opacity: 1; }
        .expert-card.thinking { background: rgba(215, 25, 33, 0.08); }

        .expert-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .expert-avatar {
            width: 38px; height: 38px;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: var(--gray-700);
        }

        .expert-avatar.strength { background: var(--gray-700); color: var(--red); }
        .expert-avatar.recovery { background: var(--gray-700); color: var(--cyan); }
        .expert-avatar.technique { background: var(--gray-700); color: var(--purple); }
        .expert-avatar.athletic { background: var(--gray-700); color: var(--green); }
        .expert-avatar.biomech { background: var(--gray-700); color: var(--blue); }

        .expert-info { flex: 1; }
        .expert-info h4 { font-size: 13px; font-weight: 700; }
        .expert-info p { font-size: 11px; color: var(--gray-400); margin-top: 2px; }

        .expert-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            font-size: 10px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .status-indicator {
            width: 6px; height: 6px;
            border-radius: 0;
            background: var(--gray-600);
        }

        .status-indicator.ready { background: var(--gray-500); }
        .status-indicator.thinking { 
            background: var(--red);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .thinking-text {
            display: none;
            color: var(--red);
        }

        .expert-card.thinking .thinking-text { display: inline; }
        .expert-card.thinking .ready-text { display: none; }

        /* ATHLETE CONTEXT BOX - NIKE SQUARED */
        .athlete-context-box {
            background: var(--gray-800);
            border-radius: 0;
            padding: 18px;
            margin-top: 16px;
            display: none;
        }

        .athlete-context-box.show { display: block; }

        .context-header {
            font-size: 10px;
            font-weight: 700;
            color: var(--gray-500);
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .context-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: var(--gray-700);
        }

        .context-stat {
            background: var(--gray-900);
            border-radius: 0;
            padding: 12px;
        }

        .context-stat label { 
            font-size: 9px; 
            color: var(--gray-500); 
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .context-stat span { 
            font-size: 15px; 
            font-weight: 700; 
            display: block;
            margin-top: 4px;
        }

        /* WEARABLE DATA SECTION */
        .wearable-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--gray-700);
        }

        .wearable-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 10px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .wearable-header i { margin-right: 6px; }

        .freshness-badge {
            padding: 3px 8px;
            border-radius: 0;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .freshness-badge.fresh { background: rgba(0,210,106,0.2); color: var(--green); }
        .freshness-badge.stale { background: rgba(255,152,0,0.2); color: var(--orange); }
        .freshness-badge.old { background: rgba(230,57,70,0.2); color: var(--red); }
        .freshness-badge.none { background: var(--gray-700); color: var(--gray-500); }

        .wearable-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: var(--gray-700);
        }

        .wearable-stat {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--gray-900);
            border-radius: 0;
            padding: 10px;
        }

        .wearable-stat.full { grid-column: span 2; }

        .wearable-stat i { 
            color: var(--gray-500); 
            font-size: 14px;
            width: 20px;
            text-align: center;
        }

        .wearable-stat label {
            font-size: 9px;
            color: var(--gray-500);
            text-transform: uppercase;
        }

        .wearable-stat span {
            font-size: 13px;
            font-weight: 600;
            display: block;
        }

        .wearable-warning {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,152,0,0.1);
            border: 1px solid rgba(255,152,0,0.3);
            border-radius: 8px;
            font-size: 11px;
            color: var(--orange);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .wearable-warning.critical {
            background: rgba(230,57,70,0.1);
            border-color: rgba(230,57,70,0.3);
            color: var(--red);
        }

        /* PERIODIZATION SECTION */
        .periodization-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--gray-700);
        }

        .periodization-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 11px;
            color: var(--gray-400);
        }

        .periodization-header i { margin-right: 6px; }

        .periodization-model {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(33,150,243,0.2);
            color: var(--blue);
        }

        .periodization-stats {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 12px;
        }

        .periodization-stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .periodization-bar {
            height: 6px;
            background: var(--gray-700);
            border-radius: 3px;
            overflow: hidden;
        }

        .periodization-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--blue));
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .periodization-bar.intensity .periodization-bar-fill {
            background: linear-gradient(90deg, var(--orange), var(--red));
        }

        .periodization-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--gray-400);
        }

        .periodization-label span:last-child {
            font-weight: 600;
            color: var(--white);
        }

        .periodization-focus {
            padding: 10px;
            background: var(--gray-700);
            border-radius: 8px;
            font-size: 11px;
            color: var(--gray-300);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .periodization-focus i {
            color: var(--cyan);
        }

        .periodization-adjustments {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,152,0,0.1);
            border: 1px solid rgba(255,152,0,0.3);
            border-radius: 8px;
            font-size: 10px;
            color: var(--orange);
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .periodization-adjustments i {
            margin-top: 2px;
        }

        /* MACROCYCLE SECTION */
        .macrocycle-section {
            background: var(--gray-800);
            border-radius: 12px;
            padding: 16px;
            margin-top: 12px;
            border: 1px solid var(--gray-700);
        }

        .macrocycle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-300);
        }

        .macrocycle-header i { margin-right: 6px; color: var(--orange); }

        .macrocycle-btn-small {
            background: var(--gray-700);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            color: var(--gray-400);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .macrocycle-btn-small:hover {
            background: var(--orange);
            color: var(--white);
        }

        .macro-event {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .macro-event-name {
            font-weight: 700;
            font-size: 14px;
            color: var(--white);
        }

        .macro-event-date {
            font-size: 11px;
            color: var(--orange);
            font-weight: 600;
        }

        .macro-progress-bar {
            height: 8px;
            background: var(--gray-700);
            border-radius: 0;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .macro-progress-fill {
            height: 100%;
            background: var(--red);
            border-radius: 0;
            transition: width var(--transition-medium);
        }

        .macro-progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--gray-400);
            margin-bottom: 12px;
        }

        .macro-phases {
            display: flex;
            gap: 1px;
            flex-wrap: wrap;
            background: var(--gray-700);
        }

        .macro-phase-chip {
            padding: 4px 8px;
            border-radius: 0;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            background: var(--gray-800);
            color: var(--gray-400);
        }

        .macro-phase-chip.active {
            background: var(--red);
            color: var(--white);
            border: none;
        }

        .macro-phase-chip.completed {
            background: rgba(0,210,106,0.2);
            color: var(--green);
        }

        .macrocycle-empty {
            text-align: center;
            padding: 20px;
            color: var(--gray-500);
        }

        .macrocycle-empty p {
            font-size: 12px;
            margin-bottom: 12px;
        }

        /* NEXT EVENT (match/fight) OVERRIDE */
        .next-event-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--gray-700);
        }

        .next-event-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 10px;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 8px;
        }

        .next-event-grid {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
        }

        .next-event-input {
            width: 100%;
            background: var(--gray-700);
            color: var(--white);
            border: 1px solid var(--gray-700);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 12px;
            outline: none;
        }

        .next-event-input::placeholder {
            color: var(--gray-500);
        }

        .next-event-btn {
            background: var(--gray-700);
            border: none;
            height: 34px;
            padding: 0 10px;
            border-radius: 8px;
            color: var(--gray-300);
            cursor: pointer;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .next-event-btn:hover {
            background: var(--orange);
            color: var(--white);
        }

        .next-event-hint {
            margin-top: 6px;
            font-size: 10px;
            color: var(--gray-500);
            line-height: 1.3;
        }

        .calendar-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            margin-bottom: 8px;
        }

        .calendar-item.active {
            border-color: var(--orange);
        }

        .calendar-item-left {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .calendar-item-title {
            font-size: 12px;
            color: var(--white);
            font-weight: 700;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 420px;
        }

        .calendar-item-sub {
            font-size: 10px;
            color: var(--gray-400);
        }

        .calendar-item-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .calendar-pill {
            font-size: 10px;
            color: var(--gray-300);
            background: var(--gray-700);
            padding: 4px 8px;
            border-radius: 999px;
        }

        /* FULLSCREEN CALENDAR OVERLAY */
        .calendar-overlay {
            position: fixed;
            inset: 0;
            z-index: 500;
            background: var(--black);
            display: none;
            flex-direction: column;
        }

        .calendar-overlay.show {
            display: flex;
        }

        .calendar-overlay-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 18px;
            border-bottom: 1px solid var(--gray-700);
            background: var(--gray-900);
        }

        .calendar-overlay-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--white);
        }

        .calendar-overlay-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .calendar-overlay-body {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 0;
            min-height: 0;
            height: calc(100vh - 62px);
        }

        .calendar-overlay-left {
            padding: 18px;
            overflow: auto;
            border-right: 1px solid var(--gray-700);
            background: var(--black);
        }

        .calendar-overlay-right {
            padding: 18px;
            overflow: auto;
            background: var(--gray-900);
        }

        .calendar-month-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            gap: 10px;
        }

        .calendar-month-label {
            font-size: 14px;
            font-weight: 800;
            color: var(--white);
            letter-spacing: -0.02em;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
            margin-bottom: 6px;
        }

        .calendar-weekday {
            font-size: 10px;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 6px 8px;
        }

        .calendar-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
        }

        .cal-day {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 10px;
            padding: 8px;
            min-height: 70px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .cal-day.other-month {
            opacity: 0.45;
        }

        .cal-day.selected {
            border-color: var(--orange);
        }

        .cal-day-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .cal-day-number {
            font-size: 12px;
            font-weight: 800;
            color: var(--white);
        }

        .cal-event-dots {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .cal-dot {
            width: 7px;
            height: 7px;
            border-radius: 999px;
            background: var(--gray-500);
        }

        .cal-dot.match { background: var(--orange); }
        .cal-dot.fight { background: var(--purple); }
        .cal-dot.other { background: var(--cyan); }
        .cal-dot.workout { background: var(--green); }

        .cal-day.training-day {
            border-left: 3px solid var(--blue);
        }

        .cal-day.has-workout {
            background: rgba(0, 210, 106, 0.12);
        }

        .cal-day-icons {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 4px;
            font-size: 10px;
            color: var(--gray-400);
        }

        .cal-day-icons i {
            font-size: 10px;
        }

        .cal-day-icons .icon-training { color: var(--blue); }
        .cal-day-icons .icon-workout { color: var(--green); }
        .cal-day-icons .icon-match { color: var(--orange); }
        .cal-day-icons .icon-fight { color: var(--purple); }

        .cal-md-badge {
            font-size: 9px;
            font-weight: 800;
            padding: 2px 5px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 4px;
            display: inline-block;
        }

        .cal-md-badge.md0 { background: var(--red); color: var(--white); }
        .cal-md-badge.md-1 { background: var(--orange); color: var(--black); }
        .cal-md-badge.md-2 { background: rgba(255,152,0,0.5); color: var(--white); }
        .cal-md-badge.md1 { background: var(--green); color: var(--black); }
        .cal-md-badge.md2 { background: rgba(0,210,106,0.5); color: var(--white); }

        .cal-situation-panel {
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 14px;
        }

        .cal-situation-title {
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--gray-400);
            margin-bottom: 10px;
        }

        .cal-situation-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--white);
            margin-bottom: 6px;
        }

        .cal-situation-row i {
            width: 16px;
            text-align: center;
            color: var(--gray-400);
        }

        .cal-situation-row .highlight {
            font-weight: 700;
            color: var(--orange);
        }

        .cal-situation-row .highlight-green {
            font-weight: 700;
            color: var(--green);
        }

        .cal-situation-row .highlight-red {
            font-weight: 700;
            color: var(--red);
        }

        .cal-situation-suggestion {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,152,0,0.15);
            border-left: 3px solid var(--orange);
            font-size: 11px;
            color: var(--gray-300);
            line-height: 1.4;
        }

        .cal-situation-suggestion.recovery {
            background: rgba(0,210,106,0.15);
            border-left-color: var(--green);
        }

        .cal-situation-suggestion.rest {
            background: rgba(215,25,33,0.15);
            border-left-color: var(--red);
        }

        .situation-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 12px;
            color: var(--gray-300);
            margin-bottom: 8px;
        }

        .situation-label {
            color: var(--gray-400);
            font-size: 11px;
        }

        .situation-value {
            font-weight: 600;
            color: var(--white);
        }

        .situation-value.urgent {
            color: var(--red);
            font-weight: 700;
        }

        .situation-value.soon {
            color: var(--orange);
        }

        .situation-value.normal {
            color: var(--green);
        }

        .situation-md {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--gray-700);
        }

        .situation-suggestion {
            margin-top: 12px;
            padding: 10px;
            background: rgba(255,152,0,0.1);
            border: 1px solid rgba(255,152,0,0.3);
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .suggestion-icon {
            font-size: 16px;
            line-height: 1;
        }

        .suggestion-text {
            font-size: 11px;
            color: var(--gray-200);
            line-height: 1.4;
        }

        .situation-phase {
            color: var(--purple) !important;
        }

        /* ðŸ§  Rationale Card - Coach Reasoning UI */
        .rationale-card {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.1) 0%, rgba(103, 58, 183, 0.05) 100%);
            border: 1px solid rgba(156, 39, 176, 0.3);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
            animation: slideIn 0.4s var(--ease-out-expo);
        }
        
        .rationale-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: rgba(156, 39, 176, 0.08);
            border-bottom: 1px solid rgba(156, 39, 176, 0.2);
        }
        
        .rationale-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .rationale-emoji {
            font-size: 20px;
        }
        
        .rationale-decision {
            font-size: 14px;
            font-weight: 700;
            color: var(--white);
        }
        
        .rationale-confidence {
            font-size: 10px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .rationale-expand-btn {
            background: none;
            border: none;
            color: var(--gray-400);
            cursor: pointer;
            padding: 4px;
            transition: all 0.2s;
        }
        
        .rationale-expand-btn:hover {
            color: var(--purple);
        }
        
        .rationale-factors {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(156, 39, 176, 0.15);
        }
        
        .rationale-factor {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 5px 10px;
            border-radius: 16px;
            background: var(--gray-800);
            color: var(--gray-300);
        }
        
        .rationale-factor.critical {
            background: rgba(215, 25, 33, 0.2);
            color: var(--red);
            border: 1px solid rgba(215, 25, 33, 0.3);
        }
        
        .rationale-factor.high {
            background: rgba(255, 152, 0, 0.15);
            color: var(--orange);
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        .rationale-factor.medium {
            background: rgba(33, 150, 243, 0.15);
            color: var(--blue);
        }
        
        .factor-icon {
            font-size: 12px;
        }
        
        .rationale-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .rationale-details.expanded {
            max-height: 600px;
        }
        
        .rationale-section {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(156, 39, 176, 0.1);
        }
        
        .rationale-section:last-child {
            border-bottom: none;
        }
        
        .rationale-section-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--purple);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
        }
        
        .rationale-explanation {
            font-size: 13px;
            color: var(--gray-300);
            line-height: 1.6;
        }
        
        .rationale-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .rationale-list li {
            font-size: 12px;
            color: var(--gray-300);
            padding: 4px 0;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }
        
        .rationale-list.alternatives li {
            color: var(--gray-400);
            font-style: italic;
        }
        
        .rationale-list.monitoring li {
            color: var(--cyan);
        }

        /* Coach Alerts Panel */
        .coach-alerts-panel {
            background: var(--gray-850);
            border: 1px solid var(--gray-700);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            display: none;
        }
        .coach-alerts-panel.has-alerts {
            display: block;
        }
        .coach-alerts-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(215,25,33,0.1);
            border-bottom: 1px solid var(--gray-700);
        }
        .coach-alerts-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--red);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .coach-alerts-count {
            background: var(--red);
            color: var(--white);
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 700;
        }
        .coach-alerts-list {
            padding: 0;
            margin: 0;
            list-style: none;
        }
        .coach-alert-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 14px;
            border-bottom: 1px solid var(--gray-800);
            font-size: 12px;
            color: var(--gray-200);
            line-height: 1.4;
        }
        .coach-alert-item:last-child {
            border-bottom: none;
        }
        .coach-alert-item.warning {
            background: rgba(255,152,0,0.08);
        }
        .coach-alert-item.danger {
            background: rgba(215,25,33,0.08);
        }
        .coach-alert-item.info {
            background: rgba(0,210,106,0.05);
        }
        .coach-alert-icon {
            font-size: 14px;
            flex-shrink: 0;
            margin-top: 1px;
        }
        .coach-alert-icon.warning { color: var(--orange); }
        .coach-alert-icon.danger { color: var(--red); }
        .coach-alert-icon.info { color: var(--green); }
        .coach-alert-text {
            flex: 1;
        }
        .coach-alert-text strong {
            color: var(--white);
        }

        /* AI Decision Log */
        .ai-decision-log {
            background: var(--gray-850);
            border: 1px solid var(--gray-700);
            border-radius: 12px;
            margin-bottom: 12px;
            display: none;
        }
        .ai-decision-log.visible {
            display: block;
        }
        .ai-decision-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            user-select: none;
        }
        .ai-decision-header:hover {
            background: rgba(255,255,255,0.02);
        }
        .ai-decision-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--purple);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ai-reliability-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: 8px;
            background: var(--gray-800);
            font-size: 10px;
        }

        /* AI Metrics Dashboard */
        .ai-metrics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 10000;
            display: none;
            overflow-y: auto;
            padding: 40px 20px;
        }
        .ai-metrics-overlay.open {
            display: block;
        }
        .ai-metrics-container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 16px;
            overflow: hidden;
        }
        .ai-metrics-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            background: var(--gray-850);
            border-bottom: 1px solid var(--gray-700);
        }
        .ai-metrics-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--white);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .ai-metrics-close {
            background: none;
            border: none;
            color: var(--gray-400);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
        }
        .ai-metrics-close:hover {
            color: var(--white);
        }
        .ai-metrics-body {
            padding: 24px;
        }
        .ai-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        .ai-metric-card {
            background: var(--gray-850);
            border: 1px solid var(--gray-700);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .ai-metric-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--white);
            line-height: 1;
            margin-bottom: 6px;
        }
        .ai-metric-value.green { color: var(--green); }
        .ai-metric-value.orange { color: var(--orange); }
        .ai-metric-value.red { color: var(--red); }
        .ai-metric-value.purple { color: var(--purple); }
        .ai-metric-label {
            font-size: 11px;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .ai-metrics-section {
            margin-bottom: 24px;
        }
        .ai-metrics-section-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ai-metrics-table {
            width: 100%;
            border-collapse: collapse;
        }
        .ai-metrics-table th,
        .ai-metrics-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--gray-800);
            font-size: 12px;
        }
        .ai-metrics-table th {
            color: var(--gray-400);
            font-weight: 600;
            background: var(--gray-850);
        }
        .ai-metrics-table td {
            color: var(--gray-200);
        }
        .ai-metrics-error-item {
            background: rgba(215,25,33,0.1);
            border: 1px solid rgba(215,25,33,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .ai-metrics-error-stage {
            color: var(--red);
            font-weight: 600;
            margin-bottom: 4px;
        }
        .ai-metrics-error-msg {
            color: var(--gray-300);
        }
        .ai-metrics-error-time {
            color: var(--gray-500);
            font-size: 10px;
            margin-top: 4px;
        }
        .ai-test-btn {
            background: var(--purple);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .ai-test-btn:hover {
            opacity: 0.9;
        }
        .ai-test-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .ai-test-results {
            margin-top: 16px;
            padding: 16px;
            background: var(--gray-850);
            border-radius: 8px;
            font-size: 12px;
            display: none;
        }
        .ai-test-results.visible {
            display: block;
        }
        .ai-test-progress {
            height: 4px;
            background: var(--gray-700);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 12px;
        }
        .ai-test-progress-bar {
            height: 100%;
            background: var(--purple);
            transition: width 0.3s;
        }

        .ai-decision-toggle {
            color: var(--gray-400);
            font-size: 12px;
            transition: transform 0.2s;
        }
        .ai-decision-log.expanded .ai-decision-toggle {
            transform: rotate(180deg);
        }
        .ai-decision-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .ai-decision-log.expanded .ai-decision-body {
            max-height: 500px;
        }
        .ai-decision-list {
            padding: 0 14px 14px;
            margin: 0;
            list-style: none;
        }
        .ai-decision-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 0;
            border-bottom: 1px solid var(--gray-800);
            font-size: 11px;
            color: var(--gray-300);
            line-height: 1.4;
        }
        .ai-decision-item:last-child {
            border-bottom: none;
        }
        .ai-decision-icon {
            color: var(--purple);
            flex-shrink: 0;
            width: 16px;
            text-align: center;
        }
        .ai-decision-text {
            flex: 1;
        }
        .ai-decision-reason {
            color: var(--gray-500);
            font-style: italic;
        }

        .cal-day-phase {
            margin-top: 6px;
            font-size: 10px;
            color: var(--gray-400);
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-overlay-panel-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 10px;
            color: var(--gray-400);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 10px;
        }

        .calendar-overlay-selected {
            font-size: 11px;
            color: var(--gray-300);
            margin: 6px 0 14px;
        }

        @media (max-width: 899px) {
            .calendar-overlay-body {
                grid-template-columns: 1fr;
                height: calc(100vh - 62px);
            }
            .calendar-overlay-left {
                border-right: none;
                border-bottom: 1px solid var(--gray-700);
            }
        }

        .btn-create-macro-full {
            background: var(--red);
            border: none;
            padding: 10px 16px;
            border-radius: 0;
            color: var(--white);
            font-weight: 700;
            font-size: 11px;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .btn-create-macro-full:hover {
            background: #FF3040;
        }

        /* MIDDLE - CONVERSATION - NIKE STYLE */
        .conversation-panel {
            background: var(--black);
            display: flex;
            flex-direction: column;
            max-width: 100%;
            overflow-x: hidden;
        }

        .conversation-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--gray-700);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .conversation-title {
            font-weight: 700;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--gray-400);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .live-badge {
            background: var(--red);
            padding: 4px 10px;
            border-radius: 0;
            font-size: 9px;
            font-weight: 700;
            animation: pulse 2s infinite;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .phase-badge {
            background: var(--gray-900);
            padding: 8px 14px;
            border-radius: 0;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--gray-700);
        }

        .phase-badge i { color: var(--red); }

        .conversation-messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .ai-message {
            display: flex;
            gap: 14px;
            animation: slideIn 0.4s var(--ease-out-expo);
            padding: 20px 0;
            border-bottom: 1px solid var(--gray-800);
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .ai-message .expert-avatar {
            width: 32px; height: 32px;
            font-size: 14px;
            flex-shrink: 0;
            border-radius: 0;
        }

        .message-bubble {
            flex: 1;
            background: transparent;
            border-radius: 0;
            padding: 0;
            max-width: 100%;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .message-author { 
            font-weight: 700; 
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .confidence-badge {
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 0;
            font-weight: 600;
            text-transform: uppercase;
        }

        .confidence-high { background: rgba(0,210,106,0.2); color: var(--green); }
        .confidence-medium { background: rgba(255,152,0,0.2); color: var(--orange); }

        .message-time { font-size: 10px; color: var(--gray-500); }
        .message-text { font-size: 14px; line-height: 1.7; color: var(--gray-300); }
        .message-text strong { color: var(--white); }

        /* COACH MESSAGE */
        .coach-message {
            display: flex;
            justify-content: flex-start;
            animation: slideIn 0.3s var(--ease-out-expo);
            padding: 20px 0;
            border-bottom: 1px solid var(--gray-800);
        }

        .coach-bubble {
            background: var(--red);
            border-radius: 0;
            padding: 14px 18px;
            max-width: 85%;
        }

        .coach-bubble .message-text { color: var(--white); }

        /* TYPING INDICATOR */
        .typing-indicator {
            display: flex;
            gap: 14px;
            display: none;
            padding: 20px 0;
        }

        .typing-indicator.show { display: flex; }

        .typing-dots {
            display: flex;
            gap: 4px;
            padding: 14px 18px;
            background: var(--gray-800);
            border-radius: 0;
        }

        .typing-dots span {
            width: 6px; height: 6px;
            background: var(--gray-500);
            border-radius: 0;
            animation: typingBounce 1.4s infinite;
        }

        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }

        /* COACH INPUT - NIKE STYLE */
        .coach-input-area {
            padding: 20px 24px;
            border-top: 1px solid var(--gray-700);
            background: var(--gray-900);
        }

        .quick-prompts {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .quick-prompt {
            padding: 8px 14px;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            border-radius: 0;
            font-size: 11px;
            color: var(--gray-400);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .quick-prompt:hover {
            background: var(--red);
            color: var(--white);
            border-color: var(--red);
        }

        .input-box {
            display: flex;
            gap: 1px;
            align-items: stretch;
            background: var(--gray-700);
        }

        .coach-input {
            flex: 1;
            background: var(--gray-800);
            border: none;
            border-radius: 0;
            padding: 16px 18px;
            color: var(--white);
            font-size: 14px;
            resize: none;
            outline: none;
            min-height: 54px;
            max-height: 120px;
            font-family: inherit;
            transition: background var(--transition-fast);
        }

        .coach-input:focus { background: var(--gray-750); }

        .send-btn {
            width: 54px; height: 54px;
            border-radius: 0;
            background: var(--red);
            border: none;
            color: var(--white);
            font-size: 18px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .send-btn:hover { background: #FF3040; }

        .quick-btn:hover { 
            background: var(--red) !important; 
            border-color: var(--red) !important;
        }

        .generate-main-btn {
            border-radius: 0 !important;
        }
        
        .generate-main-btn:hover {
            background: #FF3040 !important;
        }

        /* EMPTY STATE */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 40px;
        }

        .empty-icon {
            width: 80px; height: 80px;
            background: var(--gray-800);
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 20px;
        }

        .empty-state h3 { 
            font-size: 16px; 
            margin-bottom: 8px; 
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .empty-state p { color: var(--gray-500); font-size: 13px; }
    </style>
</head>
<body>
    <!-- SIDEBAR -->
    <nav class="sidebar">
        <a href="coach-dashboard.html" class="logo" style="overflow:hidden;border-radius:0;">
            <img src="https://cdn.shopify.com/s/files/1/0969/1801/2243/files/Black_White_Bold_Modern_Clothing_Brand_Logo_97389bbf-665b-4465-82ec-d71a0fa4b35e.png?v=1758700090" alt="GR" style="width:100%;height:100%;object-fit:cover;">
        </a>
        <a href="coach-dashboard.html" class="nav-item"><i class="fas fa-th-large"></i></a>
        <a href="coach-clients.html" class="nav-item"><i class="fas fa-users"></i></a>
        <a href="coach-generate.html" class="nav-item active"><i class="fas fa-bolt"></i></a>
        <div class="nav-spacer"></div>
        <a href="#" onclick="coachLogout(event)" class="nav-item"><i class="fas fa-sign-out-alt"></i></a>
    </nav>

    <!-- MAIN CONTENT -->
    <main class="main">
        <!-- HERO HEADER - COMPACT NIKE -->
        <div class="hero-header">
            <div class="hero-top">
                <div class="hero-left">
                    <div class="hero-badge">
                        <i class="fas fa-robot"></i>
                        AI Powered
                    </div>
                    <h1 class="hero-title">WORKOUT<br><span>GENERATOR</span></h1>
                    <p class="hero-subtitle">Il tuo team di 5 esperti AI analizza i dati e genera il workout perfetto</p>
                </div>
            </div>

            <!-- PROGRESS LINE -->
            <div class="progress-line" aria-hidden="true">
                <div class="progress-line-fill" id="progress-line-fill"></div>
            </div>
        </div>

        <!-- MAIN GRID - Continua nel prossimo step -->
        <div class="main-grid">
            <!-- LEFT: EXPERTS PANEL -->
            <div class="experts-panel">
                <div class="panel-title"><i class="fas fa-robot"></i> Team AI</div>

                <div class="expert-card strength" data-expert="strength">
                    <div class="expert-header">
                        <div class="expert-avatar strength"><i class="fas fa-dumbbell" aria-hidden="true"></i></div>
                        <div class="expert-info">
                            <h4>Coach Strength</h4>
                            <p>Periodizzazione & Forza</p>
                        </div>
                    </div>
                    <div class="expert-status">
                        <span class="status-indicator ready"></span>
                        <span class="ready-text">Pronto</span>
                        <span class="thinking-text">Analizzando...</span>
                    </div>
                </div>

                <div class="expert-card recovery" data-expert="recovery">
                    <div class="expert-header">
                        <div class="expert-avatar recovery"><i class="fas fa-bed" aria-hidden="true"></i></div>
                        <div class="expert-info">
                            <h4>Recovery Pro</h4>
                            <p>Recupero & Fatica</p>
                        </div>
                    </div>
                    <div class="expert-status">
                        <span class="status-indicator ready"></span>
                        <span class="ready-text">Pronto</span>
                        <span class="thinking-text">Analizzando...</span>
                    </div>
                </div>

                <div class="expert-card technique" data-expert="technique">
                    <div class="expert-header">
                        <div class="expert-avatar technique"><i class="fas fa-bullseye" aria-hidden="true"></i></div>
                        <div class="expert-info">
                            <h4>Tech Master</h4>
                            <p>Tecnica & Progressione</p>
                        </div>
                    </div>
                    <div class="expert-status">
                        <span class="status-indicator ready"></span>
                        <span class="ready-text">Pronto</span>
                        <span class="thinking-text">Analizzando...</span>
                    </div>
                </div>

                <div class="expert-card athletic" data-expert="athletic">
                    <div class="expert-header">
                        <div class="expert-avatar athletic"><i class="fas fa-person-running" aria-hidden="true"></i></div>
                        <div class="expert-info">
                            <h4>Coach Athletic</h4>
                            <p>Conditioning & Cardio</p>
                        </div>
                    </div>
                    <div class="expert-status">
                        <span class="status-indicator ready"></span>
                        <span class="ready-text">Pronto</span>
                        <span class="thinking-text">Analizzando...</span>
                    </div>
                </div>

                <div class="expert-card biomech" data-expert="biomech">
                    <div class="expert-header">
                        <div class="expert-avatar biomech"><i class="fas fa-bone" aria-hidden="true"></i></div>
                        <div class="expert-info">
                            <h4>Dr. Biomech</h4>
                            <p>Movimento & Postura</p>
                        </div>
                    </div>
                    <div class="expert-status">
                        <span class="status-indicator ready"></span>
                        <span class="ready-text">Pronto</span>
                        <span class="thinking-text">Analizzando...</span>
                    </div>
                </div>

                <!-- ATHLETE CONTEXT -->
                <div class="athlete-context-box" id="athlete-context">
                    <div class="context-header"><i class="fas fa-chart-line"></i> Stato Atleta</div>
                    <div class="context-stats">
                        <div class="context-stat">
                            <label>Settimana</label>
                            <span id="ctx-week">-</span>
                        </div>
                        <div class="context-stat">
                            <label>Fase</label>
                            <span id="ctx-phase">-</span>
                        </div>
                        <div class="context-stat">
                            <label>RPE Medio</label>
                            <span id="ctx-rpe">-</span>
                        </div>
                        <div class="context-stat">
                            <label>Compliance</label>
                            <span id="ctx-compliance">-</span>
                        </div>
                    </div>

                    <!-- WEARABLE DATA SECTION -->
                    <div class="wearable-section" id="wearable-section">
                        <div class="wearable-header">
                            <span><i class="fas fa-watch"></i> Dati Wearable</span>
                            <span class="freshness-badge" id="freshness-badge">-</span>
                        </div>
                        <div class="wearable-stats" id="wearable-stats">
                            <div class="wearable-stat">
                                <i class="fas fa-heartbeat"></i>
                                <div>
                                    <label>HRV</label>
                                    <span id="ctx-hrv">-</span>
                                </div>
                            </div>
                            <div class="wearable-stat">
                                <i class="fas fa-moon"></i>
                                <div>
                                    <label>Sonno</label>
                                    <span id="ctx-sleep">-</span>
                                </div>
                            </div>
                            <div class="wearable-stat full">
                                <i class="fas fa-battery-full"></i>
                                <div>
                                    <label>Readiness</label>
                                    <span id="ctx-readiness">-</span>
                                </div>
                            </div>
                        </div>
                        <div class="wearable-warning" id="wearable-warning" style="display:none;">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span id="warning-text">Dati non aggiornati</span>
                        </div>
                    </div>

                    <!-- PERIODIZATION SECTION -->
                    <div class="periodization-section" id="periodization-section">
                        <div class="periodization-header">
                            <span><i class="fas fa-chart-bar"></i> Periodizzazione</span>
                            <span class="periodization-model" id="periodization-model">-</span>
                        </div>
                        <div class="periodization-stats">
                            <div class="periodization-stat">
                                <div class="periodization-bar">
                                    <div class="periodization-bar-fill" id="volume-bar" style="width: 100%"></div>
                                </div>
                                <div class="periodization-label">
                                    <span>Volume</span>
                                    <span id="volume-pct">100%</span>
                                </div>
                            </div>
                            <div class="periodization-stat">
                                <div class="periodization-bar intensity">
                                    <div class="periodization-bar-fill" id="intensity-bar" style="width: 70%"></div>
                                </div>
                                <div class="periodization-label">
                                    <span>IntensitÃ </span>
                                    <span id="intensity-pct">70%</span>
                                </div>
                            </div>
                        </div>
                        <div class="periodization-focus" id="periodization-focus">
                            <i class="fas fa-bullseye"></i>
                            <span id="week-focus">-</span>
                        </div>
                        <div class="periodization-adjustments" id="periodization-adjustments" style="display: none;">
                            <i class="fas fa-sliders-h"></i>
                            <span id="adjustments-text">-</span>
                        </div>
                    </div>

                    <!-- MACROCYCLE SECTION -->
                    <div class="macrocycle-section" id="macrocycle-section" style="display: none;">
                        <div class="macrocycle-header">
                            <span><i class="fas fa-calendar-alt"></i> Macrociclo</span>
                            <button class="macrocycle-btn-small" id="btn-create-macro" title="Crea nuovo macrociclo">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                        <div class="macrocycle-active" id="macro-active-content">
                            <div class="macro-event">
                                <span class="macro-event-name" id="macro-event-name">-</span>
                                <span class="macro-event-date" id="macro-event-date">-</span>
                            </div>
                            <div class="macro-progress">
                                <div class="macro-progress-bar">
                                    <div class="macro-progress-fill" id="macro-progress-fill" style="width: 0%"></div>
                                </div>
                                <div class="macro-progress-info">
                                    <span id="macro-week-info">Settimana -/-</span>
                                    <span id="macro-days-left">- giorni</span>
                                </div>
                            </div>
                            <div class="macro-phases" id="macro-phases">
                                <!-- Fasi renderizzate dinamicamente -->
                            </div>
                        </div>
                        <div class="macrocycle-empty" id="macro-empty-content" style="display: none;">
                            <p>Nessun obiettivo pianificato</p>
                            <button class="btn-create-macro-full" id="btn-create-macro-full">
                                <i class="fas fa-plus-circle"></i> Pianifica Obiettivo
                            </button>
                        </div>

                        <!-- NEXT EVENT OVERRIDE (prima della generazione) -->
                        <div class="next-event-section" id="next-event-section">
                            <div class="next-event-title">
                                <span><i class="fas fa-flag-checkered" style="margin-right:6px;"></i> Prossimo evento (override)</span>
                            </div>
                            <div class="next-event-grid">
                                <input class="next-event-input" id="next-event-name" type="text" placeholder="es. Partita / Match / Gara" value="" />
                                <input class="next-event-input" id="next-event-date" type="date" />
                                <button class="next-event-btn" id="next-event-clear" type="button" title="Rimuovi override">Pulisci</button>
                            </div>
                            <div class="next-event-hint" style="margin-top:8px; display:flex; align-items:center; gap:8px;">
                                <input id="md0-primer-enabled" type="checkbox" />
                                <label for="md0-primer-enabled" style="cursor:pointer;">MD0: consenti micro-primer (altrimenti OFF)</label>
                            </div>
                            <div class="next-event-hint" id="next-event-hint">Usato per calcolare MD-1/MD0/MD+1 e applicare regole in-season (calcio/basket) e match-week (boxe). Se cambia la partita, aggiorna qui prima di generare.</div>

                            <div class="next-event-section" style="border-top:none; padding-top:10px; margin-top:10px;">
                                <div class="next-event-title">
                                    <span><i class="fas fa-calendar" style="margin-right:6px;"></i> Calendario eventi atleta</span>
                                    <button class="next-event-btn" id="calendar-open-overlay" type="button" title="Apri calendario a schermo intero">Apri</button>
                                </div>
                                <div class="next-event-grid" style="grid-template-columns: 1fr 1fr 1fr auto;">
                                    <select class="next-event-input" id="calendar-event-type">
                                        <option value="match">Partita/Gara</option>
                                        <option value="fight">Match (boxe)</option>
                                        <option value="other">Altro</option>
                                    </select>
                                    <input class="next-event-input" id="calendar-event-name" type="text" placeholder="Nome evento" value="" />
                                    <input class="next-event-input" id="calendar-event-date" type="date" />
                                    <button class="next-event-btn" id="calendar-event-add" type="button" title="Aggiungi evento">Aggiungi</button>
                                </div>
                                <div id="calendar-events-list" style="margin-top:10px;"></div>
                                <div class="next-event-hint">Suggerimento: aggiungi piÃ¹ eventi e seleziona quello attivo. Se non selezioni, useremo automaticamente il prossimo evento futuro.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- END EXPERTS PANEL -->

            <!-- MIDDLE: CONVERSATION -->
            <div class="conversation-panel">
                <div class="conversation-header">
                    <div class="athlete-bar" id="athlete-bar">
                        <div class="athlete-bar-main">
                            <div class="athlete-avatar-lg" id="athlete-avatar">--</div>
                            <select id="athlete-select" aria-label="Seleziona atleta">
                                <option value="">Scegli un atleta...</option>
                            </select>
                            <select id="ruleset-profile" aria-label="Profilo programmazione">
                                <option value="balanced">Bilanciato</option>
                                <option value="conservative">Conservativo</option>
                                <option value="aggressive">Aggressivo</option>
                            </select>
                            <!-- ATLAS AI Engine - No external AI needed -->
                            <div id="ai-mode-select" style="display:none;"></div>
                            <span style="background:linear-gradient(135deg,#3b82f6,#1d4ed8);color:#fff;padding:6px 12px;border-radius:6px;font-size:0.8rem;font-weight:600;display:inline-flex;align-items:center;gap:6px;">
                                <i class="fas fa-brain"></i> ATLAS AI
                            </span>
                            <button class="athlete-search-btn" id="athlete-search-toggle" type="button" aria-label="Cerca atleta">
                                <i class="fas fa-magnifying-glass" aria-hidden="true"></i>
                            </button>
                        </div>
                        <div class="athlete-bar-search" id="athlete-search-wrap" hidden>
                            <input class="athlete-search-input" id="athlete-search" type="search" placeholder="Cerca atletaâ€¦" autocomplete="off" />
                            <div class="athlete-search-results" id="athlete-search-results" role="listbox" aria-label="Risultati ricerca atleta"></div>
                        </div>
                        <div id="ruleset-suggestion" class="ruleset-suggestion"></div>
                    </div>

                    <div class="conversation-header-row">
                        <span class="conversation-title">
                            Discussione Team
                            <span class="live-badge" id="live-badge" style="display:none;">LIVE</span>
                            <button class="workout-toggle-btn" type="button" aria-label="Apri workout" onclick="toggleWorkoutPanel()">
                                <i class="fas fa-dumbbell" aria-hidden="true"></i>
                            </button>
                        </span>
                        <div class="phase-badge" id="phase-badge">
                            <i class="fas fa-calendar-alt"></i>
                            <span id="week-label">Seleziona atleta</span>
                        </div>
                    </div>
                </div>

                <div class="conversation-messages" id="messages">
                    <div class="empty-state">
                        <h3>Seleziona un atleta</h3>
                        <p>Il team AI inizierÃ  ad analizzare i dati e proporre il workout</p>
                    </div>
                </div>

                <div class="typing-indicator" id="typing-indicator">
                    <div class="expert-avatar strength" id="typing-avatar"><i class="fas fa-dumbbell" aria-hidden="true"></i></div>
                    <div class="typing-dots">
                        <span></span><span></span><span></span>
                    </div>
                </div>

                <div class="coach-input-area">
                    <!-- Coach Alerts Panel -->
                    <div class="coach-alerts-panel" id="coach-alerts-panel">
                        <div class="coach-alerts-header">
                            <div class="coach-alerts-title">
                                <i class="fas fa-exclamation-triangle"></i>
                                <span>Attenzione Coach</span>
                            </div>
                            <span class="coach-alerts-count" id="coach-alerts-count">0</span>
                        </div>
                        <ul class="coach-alerts-list" id="coach-alerts-list"></ul>
                    </div>

                    <!-- AI Decision Log -->
                    <div class="ai-decision-log" id="ai-decision-log">
                        <div class="ai-decision-header" onclick="toggleAIDecisionLog()">
                            <div class="ai-decision-title">
                                <i class="fas fa-brain"></i>
                                <span>Log Decisioni AI</span>
                                <span class="ai-reliability-badge" id="ai-reliability-badge" style="display:none;margin-left:8px;"></span>
                                <button onclick="event.stopPropagation(); openAIMetricsDashboard();" style="margin-left:auto;background:var(--purple);color:white;border:none;padding:4px 10px;border-radius:6px;font-size:10px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Apri Dashboard Metriche AI">
                                    <i class="fas fa-chart-bar"></i> Metriche
                                </button>
                            </div>
                            <i class="fas fa-chevron-down ai-decision-toggle"></i>
                        </div>
                        <div class="ai-decision-body">
                            <ul class="ai-decision-list" id="ai-decision-list"></ul>
                        </div>
                    </div>

                    <!-- Single Generate Button - Phase auto-detected from mesocycle -->
                    <div class="quick-actions" style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap;align-items:center;">
                        <button onclick="generateFromMesocycle()" class="quick-btn generate-main-btn" style="background:var(--red);color:var(--white);border:none;padding:12px 20px;border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:8px;">
                            <i class="fas fa-magic"></i> Genera Settimana <span id="auto-phase-badge" style="background:rgba(255,255,255,0.2);padding:2px 8px;border-radius:6px;font-size:12px;margin-left:4px;">Week 1</span>
                        </button>
                        <button onclick="openReadinessCheck()" class="quick-btn" style="background:var(--purple);color:var(--white);border:none;padding:10px 14px;border-radius:10px;font-size:13px;font-weight:500;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:6px;" title="Readiness Check dell'atleta prima di generare">
                            <i class="fas fa-clipboard-check"></i> <span style="display:none;" class="desktop-only-text">Readiness</span>
                        </button>
                        <span id="phase-indicator" style="color:var(--gray-400);font-size:13px;"></span>
                        <span id="readiness-badge" style="display:none;background:var(--green);color:white;padding:4px 10px;border-radius:8px;font-size:12px;font-weight:600;"></span>
                    </div>
                    <div class="input-box">
                        <textarea class="coach-input" id="coach-input" placeholder="Indicazioni aggiuntive (opzionale)..." rows="1"></textarea>
                        <button class="send-btn" onclick="sendCoachMessage()" aria-label="Invia">
                            <i class="fas fa-arrow-right" aria-hidden="true"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- RIGHT: WORKOUT BUILDER -->
            <div class="workout-panel" id="workout-panel">
                <button class="close-mobile" onclick="toggleWorkoutPanel()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="workout-header">
                    <div class="workout-title-row">
                        <input type="text" class="workout-title-input" id="workout-title" value="Nuovo Workout" placeholder="Nome workout...">
                        <button class="regenerate-btn" onclick="regenerate()" title="Rigenera">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                    <select id="week-workout-picker" class="workout-title-input" style="display:none;margin-top:0.75rem;"></select>
                    <div class="workout-meta" id="workout-meta">
                        <span><i class="fas fa-dumbbell"></i> 0 esercizi</span>
                        <span><i class="fas fa-clock"></i> ~0 min</span>
                    </div>
                </div>

                <div class="workout-body" id="workout-body">
                    <div class="exercises-empty">
                        <i class="fas fa-layer-group"></i>
                        <p>Gli esercizi appariranno qui</p>
                    </div>
                </div>

                <!-- 110/100: Recovery Prescription Panel -->
                <div id="recovery-prescription-panel" style="display:none;margin:0 16px 12px;padding:14px;background:linear-gradient(135deg,rgba(138,43,226,0.15),rgba(0,210,106,0.1));border:1px solid var(--purple);border-radius:12px;">
                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;">
                        <span style="font-size:20px;">ðŸ§˜</span>
                        <strong style="color:var(--purple);font-size:13px;text-transform:uppercase;letter-spacing:0.5px;">Recovery Prescription</strong>
                        <button onclick="toggleRecoveryDetails()" style="margin-left:auto;background:none;border:none;color:var(--gray-400);cursor:pointer;font-size:12px;">
                            <i class="fas fa-chevron-down" id="recovery-toggle-icon"></i>
                        </button>
                    </div>
                    <div id="recovery-quick-summary" style="font-size:13px;color:var(--gray-300);"></div>
                    <div id="recovery-details" style="display:none;margin-top:12px;padding-top:12px;border-top:1px solid var(--gray-700);">
                        <div id="recovery-full-prescription" style="font-size:12px;color:var(--gray-400);"></div>
                    </div>
                </div>

                <div class="workout-actions">
                    <button class="btn-add-exercise" onclick="addExercise()">
                        <i class="fas fa-plus"></i> Aggiungi Esercizio
                    </button>
                    <button class="btn-assign" onclick="saveWorkout()">
                        <i class="fas fa-paper-plane"></i> Assegna Workout
                    </button>
                </div>
            </div>
        </div>
    </main>

    <!-- Mobile FAB - outside main for visibility -->
    <button class="mobile-fab" onclick="toggleWorkoutPanel()">
        <i class="fas fa-dumbbell"></i>
    </button>

    <style>
        /* WORKOUT PANEL STYLES - NIKE SQUARED */
        .workout-panel {
            background: var(--gray-900);
            border-left: 1px solid var(--gray-700);
            display: flex;
            flex-direction: column;
        }

        .workout-header {
            padding: 20px;
            border-bottom: 1px solid var(--gray-700);
        }

        .workout-title-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .workout-title-input {
            flex: 1;
            background: none;
            border: none;
            color: var(--white);
            font-size: 18px;
            font-weight: 900;
            outline: none;
            text-transform: uppercase;
            letter-spacing: -0.5px;
        }

        .regenerate-btn {
            width: 40px; height: 40px;
            border-radius: 0;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            color: var(--gray-400);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .regenerate-btn:hover {
            background: var(--red);
            color: var(--white);
            border-color: var(--red);
            transform: rotate(180deg);
        }

        .workout-meta {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            font-size: 10px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .workout-meta i { margin-right: 6px; }

        .workout-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .exercises-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--gray-600);
            text-align: center;
        }

        .exercises-empty i { font-size: 36px; margin-bottom: 12px; }
        .exercises-empty p { font-size: 12px; text-transform: uppercase; letter-spacing: 0.1em; }

        /* EXERCISE CARD - NIKE STYLE */
        .exercise-card {
            background: var(--gray-800);
            border-radius: 0;
            padding: 14px;
            margin-bottom: 1px;
            border: none;
            transition: all var(--transition-fast);
            position: relative;
        }

        .exercise-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--red);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .exercise-card:hover { background: var(--gray-750); }
        .exercise-card:hover::before { opacity: 1; }

        .exercise-top {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exercise-drag {
            color: var(--gray-600);
            cursor: grab;
            padding: 4px;
        }

        .exercise-name {
            flex: 1;
            font-weight: 700;
            font-size: 13px;
        }

        .exercise-type {
            padding: 4px 10px;
            border-radius: 0;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .type-strength { background: rgba(215,25,33,0.15); color: var(--red); }
        .type-hypertrophy { background: rgba(156,39,176,0.15); color: var(--purple); }
        .type-conditioning { background: rgba(0,188,212,0.15); color: var(--cyan); }

        .exercise-params {
            display: flex;
            gap: 1px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--gray-700);
            background: var(--gray-700);
        }

        .param-group {
            flex: 1;
            text-align: center;
            background: var(--gray-900);
            padding: 10px 8px;
        }

        .param-label {
            font-size: 9px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 4px;
        }

        .param-value {
            font-size: 15px;
            font-weight: 700;
        }

        .exercise-actions {
            display: flex;
            gap: 1px;
            margin-top: 12px;
            background: var(--gray-700);
        }

        .ex-btn {
            flex: 1;
            padding: 10px;
            border-radius: 0;
            background: var(--gray-900);
            border: none;
            color: var(--gray-400);
            font-size: 10px;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .ex-btn:hover { background: var(--gray-800); color: var(--white); }
        .ex-btn.delete:hover { background: rgba(215,25,33,0.2); color: var(--red); }

        /* WORKOUT ACTIONS - NIKE STYLE */
        .workout-actions {
            padding: 16px;
            border-top: 1px solid var(--gray-700);
            display: flex;
            flex-direction: column;
            gap: 1px;
            background: var(--gray-700);
        }

        .btn-add-exercise {
            width: 100%;
            padding: 14px;
            border-radius: 0;
            background: var(--gray-800);
            border: 2px dashed var(--gray-600);
            color: var(--gray-400);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .btn-add-exercise:hover {
            border-color: var(--red);
            color: var(--white);
            background: var(--gray-750);
        }

        .btn-assign {
            width: 100%;
            padding: 16px;
            border-radius: 0;
            background: var(--white);
            border: none;
            color: var(--black);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-assign:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(255,255,255,0.1); }

        /* RESPONSIVE - Gestito da css/coach-layout.css */

        /*
          NIKE-STYLE COACHING REVAMP
          Big hierarchy + flush panels (matches coach pages), black theme + elegant red.
          Visual only: IDs/JS remain unchanged.
        */

        :root {
            --red: #D71921;
            --black: #000;
            --gray-900: #0A0A0A;
            --gray-850: #0E0E0E;
            --gray-800: #111;
            --gray-750: #151515;
            --gray-700: #1A1A1A;
            --gray-650: #1F1F1F;
            --gray-600: #222;
            --gray-500: #666;
            --gray-400: #888;
            --gray-300: #AAA;
            --white: #FFF;
            --ring: rgba(215,25,33,0.35);
        }

        .expert-avatar i,
        .empty-icon i,
        .quick-prompt i {
            font-size: 0.95em;
        }

        .quick-prompt {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        body {
            overflow-x: hidden;
            background: var(--black);
        }

        /* Global typography rhythm */
        .selector-label,
        .panel-title,
        .param-label,
        .hero-badge {
            letter-spacing: 0.22em;
        }

        /* Flush layout like coach-clients */
        .main-grid {
            gap: 0;
            padding: 0;
            min-height: calc(100vh - 240px);
            border-top: 1px solid var(--gray-700);
        }

        /* Make the conversation use all remaining height (fix "chat minuscola") */
        .main {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            max-width: 100%;
        }

        .main-grid {
            flex: 1;
            min-height: 0;
        }

        .experts-panel,
        .conversation-panel,
        .workout-panel {
            min-height: 0;
        }

        .experts-panel {
            background: var(--gray-900);
            border-right: 1px solid var(--gray-700);
            padding: 26px 22px;
        }

        .conversation-panel {
            background: var(--black);
        }

        .workout-panel {
            background: var(--gray-900);
            border-left: 1px solid var(--gray-700);
        }

        /* Sidebar: match coach pages */
        .sidebar {
            background: var(--gray-900);
            border-right: 1px solid var(--gray-600);
        }

        /* HERO: Nike coaching vibe - layout gestito da coach-layout.css */
        .hero-header {
            background-color: #000;
            background-image:
                linear-gradient(to bottom,
                    rgba(0,0,0,0.25) 0%,
                    rgba(0,0,0,0.65) 55%,
                    rgba(0,0,0,1) 100%
                ),
                url('assets/hero-gym.jpg');
            background-size: 100% auto, 100% auto;
            background-position: top center, top center;
            background-repeat: no-repeat, no-repeat;
            border-bottom: 1px solid var(--gray-700);
            position: relative;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .hero-header > .hero-top {
            grid-column: 1 / -1;
            padding: 54px 28px 26px;
        }

        .hero-header > .progress-line {
            grid-column: 1 / -1;
            margin: 0 28px 20px;
        }

        /* Remove red glow/blur on the hero background (photo + dark overlay only) */
        .hero-header::after { display: none; }
        .hero-header::before { display: none; }

        .hero-top {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 1fr;
            gap: 0;
            align-items: start;
            margin-bottom: 22px;
        }

        .hero-badge {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--red);
        }

        .hero-title {
            font-size: clamp(42px, 4.8vw, 68px);
            font-weight: 900;
            letter-spacing: -2.5px;
            line-height: 1.0;
            text-transform: uppercase;
        }

        .hero-title span {
            background: none;
            -webkit-text-fill-color: unset;
            color: var(--white);
        }

        .hero-subtitle {
            color: var(--gray-400);
            font-size: clamp(12px, 1.6vw, 14px);
            margin-top: 14px;
            max-width: 480px;
            line-height: 1.5;
        }

        /* Strong underline accent like Nike headings */
        .hero-left { position: relative; }
        .hero-left::after {
            content: '';
            display: block;
            width: 100px;
            height: 3px;
            background: var(--red);
            margin-top: 18px;
        }

        /* Simple progress line (replaces step cards) */
        .progress-line {
            height: 2px;
            background: var(--gray-800);
            border-radius: 0;
            overflow: hidden;
            margin-top: 16px;
        }

        .progress-line-fill {
            height: 100%;
            width: 33.33%;
            background: var(--red);
            border-radius: 0;
            transition: width var(--transition-medium);
        }

        /* Athlete bar (above Discussion) - NIKE SQUARED */
        .conversation-header {
            flex-direction: column;
            align-items: stretch;
            gap: 12px;
        }

        .conversation-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .athlete-bar {
            border: 1px solid var(--gray-700);
            background: var(--gray-900);
            border-radius: 0;
            padding: 8px;
            position: relative;
        }

        .athlete-bar-main {
            display: flex;
            align-items: center;
            gap: 1px;
            background: var(--gray-700);
        }

        .athlete-bar .athlete-avatar-lg {
            width: 40px;
            height: 40px;
            border-radius: 0;
            font-size: 13px;
            background: var(--gray-800);
        }

        .athlete-bar select {
            background: var(--gray-800);
            border: none;
            color: var(--white);
            font-size: 12px;
            font-weight: 700;
            outline: none;
            padding: 12px 14px;
            border-radius: 0;
            min-width: 0;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23FFF' stroke-width='2'%3E%3Cpolyline points='6,9 12,15 18,9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px;
            appearance: none;
            -webkit-appearance: none;
            transition: background var(--transition-fast);
        }

        .athlete-bar select:focus {
            background: var(--gray-750);
        }

        .athlete-bar #athlete-select { flex: 1; max-width: 180px; }
        .athlete-bar #ruleset-profile { flex: 0 0 auto; max-width: 120px; }

        .athlete-search-btn {
            width: 40px;
            height: 40px;
            border-radius: 0;
            border: none;
            background: var(--gray-800);
            color: var(--gray-400);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .athlete-search-btn:hover { color: var(--white); background: var(--red); }

        .athlete-bar-search {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            right: 0;
            z-index: 120;
            margin-top: 0;
            padding: 12px;
            border: 1px solid var(--gray-700);
            background: var(--gray-900);
            border-radius: 0;
        }

        .athlete-search-results {
            margin-top: 8px;
            border: 1px solid var(--gray-700);
            background: var(--black);
            border-radius: 0;
            overflow: hidden;
            max-height: 320px;
            overflow-y: auto;
            display: none;
        }

        .athlete-search-results.show { display: block; }

        .athlete-result {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--gray-700);
            transition: background var(--transition-fast);
        }

        .athlete-result:last-child { border-bottom: none; }

        .athlete-result:hover { background: var(--gray-800); }

        .athlete-result-avatar {
            width: 36px;
            height: 36px;
            border-radius: 0;
            overflow: hidden;
            background: var(--gray-800);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 12px;
            flex: 0 0 auto;
        }

        .athlete-result-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .athlete-result-meta {
            min-width: 0;
            flex: 1;
        }

        .athlete-result-name {
            font-weight: 700;
            font-size: 13px;
            color: var(--white);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .athlete-result-role {
            margin-top: 2px;
            font-size: 10px;
            color: var(--gray-500);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .athlete-search-input {
            width: 100%;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            border-radius: 0;
            padding: 12px 14px;
            color: var(--white);
            outline: none;
            font-size: 14px;
            transition: border-color var(--transition-fast);
        }

        .athlete-search-input:focus { border-color: var(--red); }

        .ruleset-suggestion {
            margin-top: 10px;
            font-size: 11px;
            color: var(--gray-500);
            line-height: 1.35;
            padding: 0 2px;
            display: none;
        }

        /* Hide FAB now that we have the header button */
        .mobile-fab { display: none !important; }

        .workout-toggle-btn {
            display: none;
            width: 36px;
            height: 36px;
            border-radius: 0;
            border: 1px solid var(--gray-700);
            background: var(--gray-800);
            color: var(--white);
            cursor: pointer;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .workout-toggle-btn:hover { background: var(--red); border-color: var(--red); }

        /* Layout responsive gestito da coach-layout.css */

        /* Remove quick-prompts spacing gap (prompts removed) */
        .coach-input-area { padding-top: 14px; }

        /* Send button as red square with arrow */
        .send-btn {
            border-radius: 0;
        }

        .send-btn:hover {
            background: #FF3040;
        }

        /* Athlete selector: feels like coach-clients search panel */
        .athlete-selector {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 0;
            padding: 20px;
        }

        .selector-label {
            color: var(--gray-400);
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .athlete-selector select {
            background: var(--gray-800);
            border: 2px solid var(--gray-600);
            border-radius: 12px;
            padding: 12px 14px;
        }

        .athlete-selector select:focus {
            outline: none;
            border-color: var(--red);
            box-shadow: 0 0 0 4px var(--ring);
        }

        /* Steps: crisp bar */
        .steps-container {
            position: relative;
            z-index: 1;
            border-radius: 16px;
            border: 1px solid var(--gray-700);
            background: var(--gray-900);
        }

        .step-item {
            padding: 18px 22px;
            border-right: 1px solid var(--gray-700);
        }

        .step-item:hover { background: var(--gray-800); }
        .step-item::after { height: 3px; }
        .step-num { background: var(--gray-800); }
        .step-item.active .step-num { background: var(--red); }

        /* Experts panel: more Nike list cards */
        .panel-title {
            color: var(--gray-500);
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
        }

        /* PANEL HEADERS: make sections feel intentional */
        .experts-panel .panel-title {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--gray-700);
        }

        /* TEAM AI: compact list (no big emoji/cards) */
        .expert-card {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: border-color 0.15s ease, background-color 0.15s ease, transform 0.15s ease;
        }

        .expert-card:hover {
            background: var(--gray-800);
            border-color: var(--gray-600);
            transform: translateY(-1px);
        }

        .expert-header {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .expert-avatar {
            width: 38px;
            height: 38px;
            border-radius: 12px;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            color: var(--white);
        }

        .expert-avatar i { font-size: 16px; }

        /* unify accents: keep red as the only strong accent */
        .expert-card::before { opacity: 0; }
        .expert-card.thinking {
            border-color: var(--red);
            background: rgba(215,25,33,0.10);
        }

        .expert-info h4 { font-size: 13px; font-weight: 800; letter-spacing: -0.2px; }
        .expert-info p { font-size: 11px; color: var(--gray-400); }

        .expert-status {
            margin-top: 0;
            font-size: 11px;
            color: var(--gray-400);
        }

        .status-indicator { background: var(--gray-600); }
        .status-indicator.ready { background: var(--gray-400); }
        .status-indicator.thinking { background: var(--red); animation: pulse 1s infinite; }

        /* Athlete context box becomes a clear section */
        .athlete-context-box {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 14px;
        }
        .context-stat { background: var(--gray-800); }
        .wearable-stat { background: var(--gray-800); }

        /* Conversation: tighter, cleaner */
        .conversation-header {
            padding: 20px 26px;
            border-bottom: 1px solid var(--gray-700);
            background: var(--black);
        }

        /* DISCUSSIONE TEAM: Nike-like header hierarchy */
        .conversation-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.22em;
            color: var(--gray-300);
            font-weight: 800;
        }

        .phase-badge {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 999px;
            padding: 10px 14px;
        }

        .phase-badge span { color: var(--gray-300); font-weight: 700; }

        .conversation-messages {
            padding: 26px;
            gap: 16px;
        }

        /* More breathing room like Nike layouts */
        .experts-panel { padding: 28px 24px; }
        .conversation-header { padding: 22px 28px; }
        .conversation-messages { padding: 28px; }
        .coach-input-area { padding: 18px 28px; }
        .workout-header { padding: 22px 22px; }
        .workout-body { padding: 20px; }
        .workout-actions { padding: 18px 20px; }

        .ai-message { gap: 12px; }

        /* Editorial conversation: less bubble, more feed */
        .conversation-messages {
            gap: 0;
        }

        .ai-message,
        .coach-message {
            padding: 16px 0;
        }

        .conversation-messages > .ai-message:not(:last-child),
        .conversation-messages > .coach-message:not(:last-child) {
            border-bottom: 1px solid var(--gray-700);
        }

        .ai-message .expert-avatar {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
        }

        .message-bubble {
            background: var(--gray-800);
            border-radius: 4px 16px 16px 16px;
            border: 1px solid transparent;
        }

        .message-bubble {
            background: transparent;
            border: none;
            padding: 0;
            max-width: 92%;
        }

        .message-header {
            margin-bottom: 8px;
        }

        .message-time {
            color: var(--gray-500);
        }

        .message-text {
            color: var(--gray-300);
            line-height: 1.75;
        }

        .ai-message:hover .message-bubble {
            border-color: transparent;
        }

        .ai-message:hover .message-bubble {
            border-color: transparent;
        }

        .message-header { margin-bottom: 10px; }
        .message-author { font-size: 11px; letter-spacing: 0.1em; }
        .confidence-badge { border-radius: 0; }

        .message-text {
            color: var(--gray-300);
            font-size: 14px;
        }

        .message-text i { margin-right: 8px; color: var(--gray-400); }

        .coach-bubble {
            border-radius: 0;
            background: var(--red);
        }

        .coach-message {
            justify-content: flex-start;
        }

        .coach-bubble {
            border-radius: 0;
            padding: 14px 16px;
            max-width: 90%;
            box-shadow: none;
        }

        .coach-input-area {
            background: var(--gray-900);
            border-top: 1px solid var(--gray-700);
            padding: 16px 24px;
        }

        .quick-prompt {
            border-radius: 0;
            border: 1px solid var(--gray-700);
            background: var(--gray-800);
        }

        .coach-input {
            background: var(--gray-800);
            border: none;
        }

        .coach-input:focus {
            background: var(--gray-750);
        }

        .send-btn {
            background: var(--red);
        }

        /* Workout builder: make it feel like a tool panel */
        .workout-header {
            padding: 20px;
            border-bottom: 1px solid var(--gray-700);
            background: var(--gray-900);
            position: sticky;
            top: 0;
            z-index: 2;
        }

        /* WORKOUT: stronger hierarchy + clearer meta */
        .workout-title-row { gap: 10px; }
        .workout-meta {
            margin-top: 12px;
            gap: 14px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-size: 10px;
        }

        .workout-title-row { align-items: center; }

        .workout-title-input {
            background: none;
            border: none;
            padding: 0;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: -0.5px;
            text-transform: uppercase;
        }

        .regenerate-btn {
            border-radius: 0;
            border: 1px solid var(--gray-700);
            background: var(--gray-800);
        }

        .regenerate-btn:hover {
            background: var(--red);
            border-color: var(--red);
            transform: rotate(180deg);
        }

        .workout-body { padding: 16px; background: var(--gray-900); }

        .exercise-card {
            background: var(--gray-800);
            border: none;
            border-radius: 0;
        }

        .exercise-card:hover {
            background: var(--gray-750);
        }

        .exercise-top { gap: 10px; }
        .exercise-name { font-size: 13px; font-weight: 700; }
        .exercise-drag { color: var(--gray-600); }

        .exercise-type {
            background: rgba(215,25,33,0.12);
            color: var(--red);
            border: none;
            border-radius: 0;
        }
        .type-strength, .type-hypertrophy, .type-conditioning { 
            background: rgba(215,25,33,0.12); 
            color: var(--red); 
        }

        .exercise-params { border-top: 1px solid var(--gray-700); }
        .param-label { letter-spacing: 0.12em; }
        .param-value { font-size: 15px; }

        .ex-btn { border-radius: 0; }

        .ex-btn {
            border: none;
            background: var(--gray-900);
        }

        .ex-btn:hover {
            background: var(--gray-800);
            color: var(--white);
        }

        .workout-actions {
            padding: 16px;
            border-top: 1px solid var(--gray-700);
            background: var(--gray-900);
        }

        .btn-add-exercise { border: 2px dashed var(--gray-600); }
        .btn-assign { text-transform: uppercase; letter-spacing: 0.15em; font-size: 11px; }

        .btn-add-exercise {
            border-radius: 0;
            border: 2px dashed var(--gray-600);
            background: var(--gray-800);
        }

        .btn-add-exercise:hover {
            border-color: var(--red);
            color: var(--white);
        }

        .btn-assign {
            border-radius: 0;
            background: var(--white);
            color: var(--black);
            transition: all var(--transition-fast);
        }

        .btn-assign:hover {
            background: var(--red);
            color: var(--white);
        }

        /* ==============================================
           LAYOUT RESPONSIVE - NIKE MOBILE OPTIMIZED
           ============================================== */

        /* Stili mobile per componenti specifici (non layout) */
        @media (max-width: 899px) {
            /* Show workout toggle button in header */
            .workout-toggle-btn { display: inline-flex; }
            
            /* Hide FAB - using header button instead */
            .mobile-fab { display: none !important; }
        }
        
        @media (max-width: 767px) {
            .hero-header > .hero-top { padding: 16px 16px 8px; }
            .hero-header > .progress-line { margin: 0 16px 10px; }
            .hero-top { gap: 10px; }
            .hero-title { font-size: 26px; letter-spacing: -1px; }
            .hero-subtitle { display: none; }
            .hero-left::after { width: 60px; height: 2px; margin-top: 12px; }
            
            .conversation-header { padding: 12px; gap: 10px; }
            .conversation-messages { padding: 12px; }
            .coach-input-area { padding: 12px; }
            
            .ai-message { padding: 14px 0; }
            .ai-message .expert-avatar { width: 28px; height: 28px; font-size: 12px; }
            .message-bubble { max-width: 100%; }
            .message-text { font-size: 13px; line-height: 1.6; }
            .message-author { font-size: 11px; }
            
            .coach-message { padding: 14px 0; }
            .coach-bubble { max-width: 95%; padding: 12px 14px; }
            
            .input-box { gap: 0; }
            .coach-input { min-height: 48px; font-size: 16px; padding: 14px; }
            .send-btn { width: 48px; height: 48px; font-size: 16px; }
            
            .athlete-bar { padding: 6px; border-radius: 0; }
            .athlete-bar-main { gap: 0; }
            .athlete-bar select { font-size: 11px; padding: 10px 8px; }
            .athlete-bar .athlete-avatar-lg { width: 36px; height: 36px; font-size: 11px; }
            .athlete-search-btn { width: 36px; height: 36px; }
            
            .quick-actions { flex-direction: column; gap: 8px; }
            .generate-main-btn { 
                width: 100%; 
                justify-content: center; 
                padding: 14px 16px !important;
                font-size: 13px !important;
            }
            
            /* Workout panel mobile overlay */
            .workout-panel.mobile-show {
                display: flex !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 70px !important;
                z-index: 200 !important;
                background: var(--gray-900) !important;
            }
            
            .workout-panel .close-mobile {
                display: flex;
                position: absolute;
                top: 12px;
                right: 12px;
                width: 40px;
                height: 40px;
                background: var(--gray-800);
                border: 1px solid var(--gray-700);
                border-radius: 0;
                color: var(--white);
                font-size: 16px;
                cursor: pointer;
                align-items: center;
                justify-content: center;
                z-index: 10;
            }
            
            .workout-header { padding: 16px; padding-top: 60px; }
            .workout-title-input { font-size: 16px; }
            .workout-body { padding: 12px; }
            .workout-actions { padding: 12px; }
            
            .exercise-card { padding: 12px; }
            .exercise-name { font-size: 12px; }
            .param-value { font-size: 14px; }
        }

        @media (max-width: 479px) {
            .hero-title { font-size: 22px; }
            .hero-left::after { width: 50px; }
            .conversation-messages { padding: 10px 8px; }
            .coach-input-area { padding: 10px 8px; }
            .athlete-bar-main { flex-wrap: wrap; }
            .athlete-bar select { max-width: 100%; }
            
            .generate-main-btn { font-size: 12px !important; }
            #auto-phase-badge { display: none; }
        }

        @media (prefers-reduced-motion: reduce) {
            * { animation: none !important; transition: none !important; }
        }
    </style>

    <!-- AI METRICS DASHBOARD OVERLAY -->
    <div class="ai-metrics-overlay" id="ai-metrics-overlay">
        <div class="ai-metrics-container">
            <div class="ai-metrics-header">
                <div class="ai-metrics-title">
                    <i class="fas fa-chart-line"></i>
                    <span>AI Metrics Dashboard</span>
                </div>
                <button class="ai-metrics-close" onclick="closeAIMetricsDashboard()" aria-label="Chiudi">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="ai-metrics-body">
                <!-- Main Metrics Grid -->
                <div class="ai-metrics-grid" id="ai-metrics-grid">
                    <!-- Populated by JS -->
                </div>

                <!-- Model Stats -->
                <div class="ai-metrics-section">
                    <div class="ai-metrics-section-title">
                        <i class="fas fa-robot"></i>
                        <span>Statistiche per Modello</span>
                    </div>
                    <table class="ai-metrics-table" id="ai-metrics-models-table">
                        <thead>
                            <tr>
                                <th>Modello</th>
                                <th>Chiamate</th>
                                <th>Successi</th>
                                <th>Tempo Medio</th>
                            </tr>
                        </thead>
                        <tbody id="ai-metrics-models-body"></tbody>
                    </table>
                </div>

                <!-- Recent Errors -->
                <div class="ai-metrics-section">
                    <div class="ai-metrics-section-title">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>Errori Recenti</span>
                    </div>
                    <div id="ai-metrics-errors"></div>
                </div>

                <!-- Test Suite -->
                <div class="ai-metrics-section">
                    <div class="ai-metrics-section-title">
                        <i class="fas fa-flask"></i>
                        <span>Test Suite</span>
                    </div>
                    <button class="ai-test-btn" id="ai-run-tests-btn" onclick="runAITestSuite()">
                        <i class="fas fa-play"></i>
                        <span>Esegui Test Suite</span>
                    </button>
                    <div class="ai-test-results" id="ai-test-results">
                        <div class="ai-test-progress">
                            <div class="ai-test-progress-bar" id="ai-test-progress-bar" style="width:0%"></div>
                        </div>
                        <div id="ai-test-output"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- FULLSCREEN CALENDAR OVERLAY -->
    <div class="calendar-overlay" id="calendar-overlay" aria-hidden="true">
        <div class="calendar-overlay-header">
            <div class="calendar-overlay-title">
                <i class="fas fa-calendar" aria-hidden="true"></i>
                <span>Calendario eventi</span>
            </div>
            <div class="calendar-overlay-actions">
                <button class="next-event-btn" id="calendar-overlay-import" type="button" title="Importa eventi da anamnesi/schedule">Importa</button>
                <button class="next-event-btn" id="calendar-overlay-close" type="button" title="Chiudi">Chiudi</button>
            </div>
        </div>
        <div class="calendar-overlay-body">
            <div class="calendar-overlay-left">
                <div class="calendar-month-header">
                    <button class="next-event-btn" id="calendar-month-prev" type="button" title="Mese precedente">â—€</button>
                    <div class="calendar-month-label" id="calendar-month-label">â€”</div>
                    <button class="next-event-btn" id="calendar-month-next" type="button" title="Mese successivo">â–¶</button>
                </div>
                <div class="calendar-weekdays" aria-hidden="true">
                    <div class="calendar-weekday">Lun</div>
                    <div class="calendar-weekday">Mar</div>
                    <div class="calendar-weekday">Mer</div>
                    <div class="calendar-weekday">Gio</div>
                    <div class="calendar-weekday">Ven</div>
                    <div class="calendar-weekday">Sab</div>
                    <div class="calendar-weekday">Dom</div>
                </div>
                <div class="calendar-month-grid" id="calendar-month-grid"></div>
            </div>

            <div class="calendar-overlay-right">
                <div class="cal-situation-panel" id="cal-situation-panel">
                    <div class="cal-situation-title"><i class="fas fa-user-clock"></i> Situazione Atleta</div>
                    <div id="cal-situation-content">Seleziona un atleta...</div>
                </div>

                <div class="calendar-overlay-panel-title">
                    <span><i class="fas fa-plus" style="margin-right:6px;"></i> Aggiungi evento</span>
                </div>
                <div class="next-event-grid" style="grid-template-columns: 1fr 1fr 1fr auto;">
                    <select class="next-event-input" id="calendar-overlay-event-type">
                        <option value="match">Partita/Gara</option>
                        <option value="fight">Match (boxe)</option>
                        <option value="other">Altro</option>
                    </select>
                    <input class="next-event-input" id="calendar-overlay-event-name" type="text" placeholder="Nome evento" value="" />
                    <input class="next-event-input" id="calendar-overlay-event-date" type="date" />
                    <button class="next-event-btn" id="calendar-overlay-event-add" type="button" title="Aggiungi evento">Aggiungi</button>
                </div>
                <div class="calendar-overlay-selected" id="calendar-overlay-selected">Seleziona un giorno per pre-compilare la data.</div>

                <div class="calendar-overlay-panel-title" style="margin-top:14px;">
                    <span><i class="fas fa-list" style="margin-right:6px;"></i> Tutti gli eventi</span>
                </div>
                <div id="calendar-overlay-events-list"></div>
            </div>
        </div>
    </div>

    <script src="js/supabase-client.js"></script>
    <script src="js/exercise-library.js"></script>
    <script src="js/exercise-library-v2.js"></script>
    <script src="js/training-methods.js"></script>
    <script src="js/training-methods-advanced.js"></script>
    <script src="js/workout-templates.js"></script>
    <script src="js/workout-postprocessor.js"></script>
    <script src="js/workout-intelligence.js"></script>
    <script src="js/workout-history.js"></script>
    <script src="js/weekly-logic.js"></script>
    <script src="js/periodization-engine.js?v=2"></script>
    <script src="js/macrocycle-planner.js"></script>
    <script src="js/return-to-play.js"></script>
    <script src="js/exercise-memory.js"></script>
    <script src="js/pre-workout-check.js"></script>
    <script src="js/feedback-engine.js"></script>
    <script src="js/injury-prevention.js"></script>
    <script src="js/performance-prediction.js"></script>
    <script src="js/workout-quality-audit.js"></script>
    <script src="js/coach-playbook.js"></script>
    <script src="js/coach-quality-engine.js"></script>
    <script src="js/boxing-rules.js"></script>
    <script src="js/dual-ai.js"></script>
    <script src="js/ai-json.js"></script>
    
    <!-- ðŸ§  REASONING ENGINE - Il cervello del coach AI -->
    <script src="js/rationale-engine.js?v=2"></script>
    
    <!-- ðŸ“… WEEK CONTEXT ENGINE - Logica MD-x -->
    <script src="js/week-context-engine.js"></script>
    
    <!-- ðŸ“Š EXTERNAL LOAD TRACKER - Carico squadra/sport -->
    <script src="js/external-load-tracker.js"></script>
    
    <!-- ðŸ§  DYNAMIC FATIGUE MODEL - Fatica multi-dimensionale -->
    <script src="js/dynamic-fatigue-model.js?v=9"></script>
    
    <!-- 110/100 SUPERHUMAN AI MODULES -->
    <script src="js/feedback-learner.js"></script>
    <script src="js/quick-readiness-check.js"></script>
    <script src="js/rpe-predictor.js?v=2"></script>
    <script src="js/cross-athlete-intelligence.js"></script>
    <script src="js/adaptive-load-optimizer.js"></script>
    <script src="js/recovery-prescriptor.js"></script>
    
    <!-- ðŸ§  SPORT INTELLIGENCE HUB - Expert Multi-Sport AI System -->
    <script src="js/expert-knowledge-base.js"></script>
    <script src="js/cognitive-reasoning-engine.js"></script>
    <script src="js/autonomous-adaptation-system.js"></script>
    <script src="js/sport-intelligence-hub.js"></script>
    
    <!-- ðŸ”¬ SCIENTIFIC CONSTRAINT SYSTEM - Deterministic Validation -->
    <script src="js/scientific-models.js"></script>
    <script src="js/constraint-engine.js?v=7"></script>
    
    <!-- ðŸ§ª AI STRESS TEST SUITE - Testing & Benchmarking -->
    <script src="js/ai-stress-test.js"></script>
    
    <!-- ðŸ”¬ SCIENTIFIC WORKOUT VALIDATOR - NASA-Level Validation -->
    <script src="js/scientific-workout-validator.js"></script>
    
    <!-- ðŸ“‹ SCIENTIFIC PROMPT RULES - Rules injection for AI -->
    <script src="js/scientific-prompt-rules.js"></script>
    
    <!-- ðŸ§¬ ATLAS - Autonomous Training Learning & Adaptation System -->
    <script src="js/atlas-core.js"></script>
    <script src="js/atlas-memory.js"></script>
    <script src="js/atlas-temporal.js"></script>
    <script src="js/atlas-science.js"></script>
    <script src="js/atlas-principles.js"></script>
    <script src="js/atlas-templates.js"></script>
    <script src="js/atlas-periodization.js"></script>
    <script src="js/atlas-anamnesi.js"></script>
    <script src="js/atlas-progression.js"></script>
    <script src="js/atlas-recovery.js"></script>
    
    <!-- ATLAS v2.0 NASA-Level Modules -->
    <script src="js/training-methods.js?v=2"></script>
    <script src="js/atlas-macro-planner.js?v=1"></script>
    <script src="js/atlas-progress-tracker.js?v=1"></script>
    <script src="js/atlas-week-generator.js?v=1"></script>
    <script src="js/atlas-auto-adjuster.js?v=1"></script>
    <script src="js/atlas-structural-balance.js?v=1"></script>
    
    <!-- ðŸ§  ATLAS Exercise Intelligence -->
    <script src="js/atlas-exercise-intelligence.js?v=1"></script>
    
    <script src="js/atlas-complete.js?v=9"></script>
    <script>
        // Check if coach is logged in
        if (localStorage.getItem('gr_coach_logged_in') !== 'true') {
            window.location.href = 'coach-login.html';
        }

        // Logout function
        function coachLogout(event) {
            if (event) event.preventDefault();
            localStorage.removeItem('gr_coach_logged_in');
            localStorage.removeItem('gr_coach_email');
            localStorage.removeItem('gr_coach_name');
            localStorage.removeItem('gr_coach_last_active');
            window.location.replace('coach-login.html');
        }
        
        // Toggle workout panel on mobile
        function toggleWorkoutPanel() {
            const panel = document.getElementById('workout-panel');
            panel.classList.toggle('mobile-show');
        }

        function setupAthleteSearch() {
            const toggleBtn = document.getElementById('athlete-search-toggle');
            const searchWrap = document.getElementById('athlete-search-wrap');
            const searchInput = document.getElementById('athlete-search');
            const select = document.getElementById('athlete-select');
            const results = document.getElementById('athlete-search-results');

            const athleteBar = document.getElementById('athlete-bar');

            if (!toggleBtn || !searchWrap || !searchInput || !select || !results) return;

            function getRoleLabel(a) {
                const sport = String(a?.sport || '').trim();
                const level = String(a?.experience_level || '').trim();
                if (sport && level) return `${sport} â€¢ ${level}`;
                if (sport) return sport;
                if (level) return level;
                return 'Atleta';
            }

            function renderResults(query) {
                const q = String(query || '').trim().toLowerCase();
                const list = (Array.isArray(athletes) ? athletes : []).filter(a => {
                    const full = `${a?.first_name || ''} ${a?.last_name || ''}`.trim();
                    if (!q) return true;
                    return String(full).toLowerCase().split(/\s+/).some(part => part.startsWith(q));
                });

                const items = list.slice(0, 30);
                results.innerHTML = items.map(a => {
                    const name = `${a?.first_name || ''} ${a?.last_name || ''}`.trim();
                    const initials = `${(a?.first_name || '')[0] || ''}${(a?.last_name || '')[0] || ''}`.toUpperCase();
                    const role = getRoleLabel(a);
                    const avatar = a?.profile_photo
                        ? `<img src="${a.profile_photo}" alt="">`
                        : `${escapeHtml(initials || '--')}`;
                    return `
                        <div class="athlete-result" role="option" data-athlete-id="${escapeHtml(a.id)}" tabindex="0">
                            <div class="athlete-result-avatar">${avatar}</div>
                            <div class="athlete-result-meta">
                                <div class="athlete-result-name">${escapeHtml(name || 'Atleta')}</div>
                                <div class="athlete-result-role">${escapeHtml(role)}</div>
                            </div>
                        </div>
                    `;
                }).join('');

                if (items.length) results.classList.add('show');
                else results.classList.remove('show');
            }

            function openSearch() {
                searchWrap.removeAttribute('hidden');
                renderResults(searchInput.value);
                searchInput.focus();
            }

            function closeSearch() {
                searchWrap.setAttribute('hidden', '');
                searchInput.value = '';
                results.classList.remove('show');
                results.innerHTML = '';
            }

            toggleBtn.addEventListener('click', () => {
                const isHidden = searchWrap.hasAttribute('hidden');
                if (isHidden) {
                    openSearch();
                } else {
                    closeSearch();
                }
            });

            searchInput.addEventListener('input', () => {
                renderResults(searchInput.value);
            });

            results.addEventListener('click', (e) => {
                const item = e.target?.closest?.('.athlete-result');
                if (!item) return;
                const id = item.getAttribute('data-athlete-id');
                if (!id) return;
                select.value = id;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                closeSearch();
            });

            results.addEventListener('keydown', (e) => {
                if (e.key !== 'Enter') return;
                const item = e.target?.closest?.('.athlete-result');
                if (!item) return;
                item.click();
            });

            // Close when tapping outside
            document.addEventListener('click', (e) => {
                if (searchWrap.hasAttribute('hidden')) return;
                const inside = athleteBar?.contains(e.target) || searchWrap.contains(e.target);
                if (!inside) closeSearch();
            });
        }
        
        // STATE
        let selectedAthlete = null;
        let athletes = [];
        let currentWorkout = { exercises: [] };
        let currentWeek = 1;
        let currentPhase = 'Adattamento';
        let lastCoachInstructions = '';
        let latestWearableData = null;
        let aiProgramState = null;
        let lastAiRun = null;
        let currentWeekPlan = null; // { workouts: [...] }
        let selectedWorkoutIndex = 0;

        // GROQ MODELS (used via /api/ai/groq-chat)
        const GROQ_MODELS = {
            main: 'llama-3.3-70b-versatile',
            fast: 'llama-3.1-8b-instant',
            // Keep this conservative: some older Groq models return 400 if unavailable.
            review: 'llama-3.1-8b-instant'
        };

        let warnedAiProgramStateMissing = false;

        // AI EXPERTS CONFIG
        const experts = {
            strength: { name: 'Coach Strength', avatarHtml: '<i class="fas fa-dumbbell" aria-hidden="true"></i>', class: 'strength', color: '#E63946' },
            recovery: { name: 'Recovery Pro', avatarHtml: '<i class="fas fa-bed" aria-hidden="true"></i>', class: 'recovery', color: '#00BCD4' },
            technique: { name: 'Tech Master', avatarHtml: '<i class="fas fa-bullseye" aria-hidden="true"></i>', class: 'technique', color: '#9C27B0' },
            athletic: { name: 'Coach Athletic', avatarHtml: '<i class="fas fa-person-running" aria-hidden="true"></i>', class: 'athletic', color: '#00D26A' },
            biomech: { name: 'Dr. Biomech', avatarHtml: '<i class="fas fa-bone" aria-hidden="true"></i>', class: 'biomech', color: '#2196F3' }
        };

        // EXERCISE DATABASE (sport-specific fallbacks)
        const exerciseDB = {
            // Generic fallbacks by phase
            adattamento: [
                { name: 'Dynamic Warm-up: 5min (High Knees + Butt Kicks + Arm Circles)', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' },
                { name: 'Goblet Squat', sets: 3, reps: '12', rest: '60s', type: 'hypertrophy' },
                { name: 'Push-ups', sets: 3, reps: '10-15', rest: '45s', type: 'hypertrophy' },
                { name: 'TRX Row', sets: 3, reps: '12', rest: '45s', type: 'hypertrophy' },
                { name: 'Plank', sets: 3, reps: '30s', rest: '30s', type: 'conditioning' },
                { name: 'Static Stretching: 5min', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' }
            ],
            accumulo: [
                { name: 'Dynamic Warm-up: 5min (Mobility Flow)', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' },
                { name: 'Back Squat', sets: 4, reps: '8', rest: '150s', type: 'strength' },
                { name: 'Bench Press', sets: 4, reps: '8', rest: '150s', type: 'strength' },
                { name: 'Barbell Row', sets: 4, reps: '8', rest: '120s', type: 'strength' },
                { name: 'Romanian Deadlift', sets: 3, reps: '10', rest: '90s', type: 'hypertrophy' },
                { name: 'Shoulder Press', sets: 3, reps: '10', rest: '90s', type: 'hypertrophy' },
                { name: 'Core: Plank + Dead Bug 3x30s each', sets: 3, reps: '30s', rest: '30s', type: 'conditioning' }
            ],
            intensificazione: [
                { name: 'Dynamic Warm-up + Activation', sets: 1, reps: '7 min', rest: '0s', type: 'conditioning' },
                { name: 'Back Squat', sets: 5, reps: '3-5 @ RPE 8', rest: '180s', type: 'strength' },
                { name: 'Deadlift', sets: 4, reps: '3 @ RPE 8', rest: '240s', type: 'strength' },
                { name: 'Bench Press', sets: 5, reps: '3-5 @ RPE 8', rest: '180s', type: 'strength' },
                { name: 'Weighted Pull-ups', sets: 4, reps: '5', rest: '150s', type: 'strength' },
                { name: 'Cool Down: 5min stretch', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' }
            ],
            deload: [
                { name: 'Mobility Flow: 10min (Cat-Cow, Hip Circles, T-Spine)', sets: 1, reps: '10 min', rest: '0s', type: 'conditioning' },
                { name: 'Goblet Squat', sets: 2, reps: '10 @ RPE 5', rest: '60s', type: 'hypertrophy' },
                { name: 'Light DB Press', sets: 2, reps: '12 @ RPE 5', rest: '45s', type: 'hypertrophy' },
                { name: 'Band Pull-aparts', sets: 3, reps: '15', rest: '30s', type: 'conditioning' },
                { name: 'Foam Rolling + Static Stretch', sets: 1, reps: '10 min', rest: '0s', type: 'conditioning' }
            ],
            // Sport-specific fallbacks
            boxe: [
                { name: 'Dynamic Warm-up: Jump Rope 3min + Shadow Boxing 2min', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' },
                { name: 'Shadow Boxing: 3x3min (R1: Jab-Cross, R2: Hooks, R3: Combos)', sets: 3, reps: '3 min', rest: '60s', type: 'conditioning' },
                { name: 'Heavy Bag: 4x3min (Jab-Cross-Hook power combos)', sets: 4, reps: '3 min', rest: '60s', type: 'conditioning' },
                { name: 'A1: Trap Bar Deadlift (superset con A2)', sets: 4, reps: '5 @ RPE 8', rest: '0s', type: 'strength' },
                { name: 'A2: Plyo Push-up', sets: 4, reps: '8', rest: '150s', type: 'strength' },
                { name: 'B1: Bulgarian Split Squat', sets: 3, reps: '8/leg', rest: '0s', type: 'strength' },
                { name: 'B2: Face Pull', sets: 3, reps: '15', rest: '90s', type: 'hypertrophy' },
                { name: 'Medicine Ball Rotational Throw: alternating sides', sets: 3, reps: '8/side', rest: '45s', type: 'conditioning' },
                { name: 'Core: Pallof Press + Dead Bug', sets: 3, reps: '10 each', rest: '30s', type: 'conditioning' },
                { name: 'Cool Down: Static Stretching 5min (shoulders, hips, thoracic)', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' }
            ],
            calcio: [
                { name: 'Dynamic Warm-up: Jog + Dynamic Stretches', sets: 1, reps: '7 min', rest: '0s', type: 'conditioning' },
                { name: 'Sprint: 6x30m with walk back recovery', sets: 6, reps: '30m', rest: '90s', type: 'conditioning' },
                { name: 'Box Jump', sets: 4, reps: '5', rest: '120s', type: 'strength' },
                { name: 'Bulgarian Split Squat', sets: 3, reps: '8/leg', rest: '90s', type: 'strength' },
                { name: 'Nordic Curl', sets: 3, reps: '5', rest: '120s', type: 'strength' },
                { name: 'Agility Ladder: Icky Shuffle + In-Out', sets: 4, reps: '2 patterns', rest: '45s', type: 'conditioning' },
                { name: 'Core: Pallof Press + Side Plank', sets: 3, reps: '10 + 30s/side', rest: '30s', type: 'conditioning' }
            ],
            basket: [
                { name: 'Dynamic Warm-up: Court Jog + Mobility', sets: 1, reps: '5 min', rest: '0s', type: 'conditioning' },
                { name: 'Depth Jump to Vertical', sets: 4, reps: '5', rest: '150s', type: 'strength' },
                { name: 'Lateral Lunge', sets: 3, reps: '8/side', rest: '60s', type: 'strength' },
                { name: 'Single-Leg RDL', sets: 3, reps: '8/leg', rest: '60s', type: 'strength' },
                { name: 'Defensive Slides: 4x20s', sets: 4, reps: '20s', rest: '40s', type: 'conditioning' },
                { name: 'Lane Agility Drill', sets: 4, reps: '1 rep', rest: '60s', type: 'conditioning' },
                { name: 'Core: Med Ball Rotations + Dead Bug', sets: 3, reps: '10 + 10', rest: '30s', type: 'conditioning' }
            ]
        };

        // INIT
        document.addEventListener('DOMContentLoaded', async () => {
            checkModulesStatus(); // Verifica caricamento moduli
            await loadAthletes();
            setupAthleteSearch();
            setupEventListeners();
            checkUrlParams();
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DIAGNOSTICA MODULI - Verifica che tutti i componenti siano caricati
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function checkModulesStatus() {
            const modules = {
                // Core AI
                DualAI: window.DualAI,
                GR_AI_JSON: window.GR_AI_JSON,
                
                // Librerie Esercizi
                ExerciseLibraryV2: window.ExerciseLibraryV2,
                GR_getExerciseLibrary: window.GR_getExerciseLibrary,
                
                // Metodologie
                TRAINING_METHODS: window.TRAINING_METHODS,
                MethodSelector: window.MethodSelector,
                AdvancedMethodSelector: window.AdvancedMethodSelector,
                
                // Periodizzazione
                PeriodizationEngine: window.PeriodizationEngine,
                MacrocyclePlanner: window.MacrocyclePlanner,
                WeeklyLogic: window.WeeklyLogic,
                
                // Feedback & Analytics
                FeedbackEngine: window.FeedbackEngine,
                WorkoutHistory: window.WorkoutHistory,
                PerformancePrediction: window.PerformancePrediction,
                
                // Sicurezza & Prevenzione
                InjuryPrevention: window.InjuryPrevention,
                ReturnToPlay: window.ReturnToPlay,
                
                // Post-processing
                WorkoutIntelligence: window.WorkoutIntelligence,
                WorkoutPostProcessor: window.WorkoutPostProcessor,
                TemplateSelector: window.TemplateSelector,
                
                // Memoria
                ExerciseMemory: window.ExerciseMemory,
                PreWorkoutCheck: window.PreWorkoutCheck,
                
                // 110/100 SUPERHUMAN AI MODULES
                FeedbackLearner: window.FeedbackLearner,
                QuickReadinessCheck: window.QuickReadinessCheck,
                RPEPredictor: window.RPEPredictor,
                CrossAthleteIntelligence: window.CrossAthleteIntelligence,
                AdaptiveLoadOptimizer: window.AdaptiveLoadOptimizer,
                RecoveryPrescriptor: window.RecoveryPrescriptor,
                RationaleEngine: window.RationaleEngine,
                WeekContextEngine: window.WeekContextEngine,
                ExternalLoadTracker: window.ExternalLoadTracker,
                DynamicFatigueModel: window.DynamicFatigueModel
            };
            
            const loaded = [];
            const missing = [];
            
            for (const [name, module] of Object.entries(modules)) {
                if (module) {
                    loaded.push(name);
                } else {
                    missing.push(name);
                }
            }
            
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('ðŸ”§ GR PERFORM - STATO MODULI AI');
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log(`âœ… Caricati: ${loaded.length}/${Object.keys(modules).length}`);
            
            if (missing.length > 0) {
                console.warn(`âš ï¸ MANCANTI: ${missing.join(', ')}`);
                // Mostra warning visivo se moduli critici mancano
                const critical = ['DualAI', 'PeriodizationEngine', 'ExerciseLibraryV2'];
                const missingCritical = missing.filter(m => critical.includes(m));
                if (missingCritical.length > 0) {
                    console.error(`ðŸ”´ MODULI CRITICI MANCANTI: ${missingCritical.join(', ')}`);
                    // Mostra alert visivo dopo che la pagina Ã¨ pronta
                    setTimeout(() => {
                        const messages = document.getElementById('messages');
                        if (messages) {
                            messages.innerHTML = `
                                <div class="ai-message" style="background: #FF3B30; color: white; padding: 16px; border-radius: 0;">
                                    <div class="message-bubble" style="background: transparent; border: none;">
                                        <div class="message-text">
                                            <strong>âš ï¸ ERRORE CARICAMENTO MODULI</strong><br>
                                            I seguenti moduli critici non sono stati caricati: <strong>${missingCritical.join(', ')}</strong><br>
                                            La generazione AI potrebbe non funzionare correttamente.<br>
                                            <small>Ricarica la pagina o controlla la console per dettagli.</small>
                                        </div>
                                    </div>
                                </div>
                            ` + messages.innerHTML;
                        }
                    }, 500);
                }
            } else {
                console.log('âœ… Tutti i moduli caricati correttamente');
            }
            console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // Salva stato per debug
            window.GR_MODULES_STATUS = { loaded, missing, total: Object.keys(modules).length };
            
            return { loaded, missing };
        }

        async function loadAthletes() {
            athletes = await supabase.fetch('athletes', '?select=*&order=first_name.asc');
            const select = document.getElementById('athlete-select');
            athletes.forEach(a => {
                const option = document.createElement('option');
                option.value = a.id;
                option.textContent = `${a.first_name} ${a.last_name}`;
                select.appendChild(option);
            });
        }

        function setupEventListeners() {
            document.getElementById('athlete-select').addEventListener('change', onAthleteSelect);

            document.getElementById('ruleset-profile').addEventListener('change', async (e) => {
                const value = String(e.target.value || 'balanced');
                if (!selectedAthlete?.id) return;
                await saveAIProgramState(selectedAthlete.id, { preferences: { ruleset_profile: value } });
                try {
                    addAIMessageSafe('strength', `Profilo programmazione impostato su: ${formatRulesetProfile(value)}.`, 'high');
                } catch {
                    // ignore
                }
            });
            
            document.getElementById('coach-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendCoachMessage();
                }
            });

            // Macrocycle buttons
            const btnCreateMacro = document.getElementById('btn-create-macro');
            const btnCreateMacroFull = document.getElementById('btn-create-macro-full');
            
            if (btnCreateMacro) {
                btnCreateMacro.addEventListener('click', () => {
                    if (selectedAthlete) {
                        showMacrocycleModal(selectedAthlete.id, selectedAthlete.sport);
                    }
                });
            }
            
            if (btnCreateMacroFull) {
                btnCreateMacroFull.addEventListener('click', () => {
                    if (selectedAthlete) {
                        showMacrocycleModal(selectedAthlete.id, selectedAthlete.sport);
                    }
                });
            }

            // Next event override (per-atleta, localStorage + aiProgramState)
            const nextEventNameEl = document.getElementById('next-event-name');
            const nextEventDateEl = document.getElementById('next-event-date');
            const nextEventClearEl = document.getElementById('next-event-clear');
            const md0PrimerEl = document.getElementById('md0-primer-enabled');

            // Calendar add
            const calTypeEl = document.getElementById('calendar-event-type');
            const calNameEl = document.getElementById('calendar-event-name');
            const calDateEl = document.getElementById('calendar-event-date');
            const calAddEl = document.getElementById('calendar-event-add');
            const onNextEventChange = () => {
                if (!selectedAthlete?.id) return;
                setNextEventActive(selectedAthlete.id, {
                    name: nextEventNameEl?.value,
                    date: nextEventDateEl?.value,
                    md0_mode: md0PrimerEl?.checked ? 'primer' : 'off'
                });
                syncNextEventUI(selectedAthlete.id);
            };
            if (nextEventNameEl) nextEventNameEl.addEventListener('input', onNextEventChange);
            if (nextEventDateEl) nextEventDateEl.addEventListener('change', onNextEventChange);
            if (md0PrimerEl) md0PrimerEl.addEventListener('change', onNextEventChange);
            if (nextEventClearEl) {
                nextEventClearEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    clearNextEventActive(selectedAthlete.id);
                    syncNextEventUI(selectedAthlete.id);
                });
            }

            if (calAddEl) {
                calAddEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const row = normalizeEventRow({
                        type: calTypeEl?.value || 'match',
                        name: calNameEl?.value,
                        date: calDateEl?.value,
                        md0_mode: (md0PrimerEl?.checked ? 'primer' : 'off')
                    });
                    if (!row) {
                        try { showToast('âš ï¸ Inserisci nome o data evento', 'error'); } catch {}
                        return;
                    }
                    const cal = getCalendarActive(selectedAthlete.id);
                    const patched = upsertEventIntoCalendar(cal, row);
                    const out = { ...patched, active_event_id: String(row.id) };
                    setCalendarActive(selectedAthlete.id, out);

                    // Sync "evento attivo" fields from new active event
                    try {
                        setNextEventActive(selectedAthlete.id, row);
                    } catch {
                        // ignore
                    }

                    if (calNameEl) calNameEl.value = '';
                    if (calDateEl) calDateEl.value = '';
                    syncNextEventUI(selectedAthlete.id);
                });
            }

            // Fullscreen calendar overlay
            const openOverlayEl = document.getElementById('calendar-open-overlay');
            const overlayCloseEl = document.getElementById('calendar-overlay-close');
            const overlayImportEl = document.getElementById('calendar-overlay-import');
            const monthPrevEl = document.getElementById('calendar-month-prev');
            const monthNextEl = document.getElementById('calendar-month-next');
            const ovTypeEl = document.getElementById('calendar-overlay-event-type');
            const ovNameEl = document.getElementById('calendar-overlay-event-name');
            const ovDateEl = document.getElementById('calendar-overlay-event-date');
            const ovAddEl = document.getElementById('calendar-overlay-event-add');

            if (openOverlayEl) {
                openOverlayEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    openCalendarOverlay(selectedAthlete.id);
                });
            }
            if (overlayCloseEl) overlayCloseEl.addEventListener('click', closeCalendarOverlay);
            if (overlayImportEl) {
                overlayImportEl.addEventListener('click', async () => {
                    if (!selectedAthlete?.id) return;
                    await importCalendarEventsBestEffort(selectedAthlete.id);
                    if (isCalendarOverlayOpen()) renderCalendarOverlay(selectedAthlete.id);
                });
            }
            if (monthPrevEl) {
                monthPrevEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    shiftOverlayMonth(-1);
                    renderCalendarOverlay(selectedAthlete.id);
                });
            }
            if (monthNextEl) {
                monthNextEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    shiftOverlayMonth(1);
                    renderCalendarOverlay(selectedAthlete.id);
                });
            }
            if (ovAddEl) {
                ovAddEl.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const row = normalizeEventRow({
                        type: ovTypeEl?.value || 'match',
                        name: ovNameEl?.value,
                        date: ovDateEl?.value,
                        md0_mode: (md0PrimerEl?.checked ? 'primer' : 'off')
                    });
                    if (!row) {
                        try { showToast('âš ï¸ Inserisci nome o data evento', 'error'); } catch {}
                        return;
                    }
                    const cal = getCalendarActive(selectedAthlete.id);
                    const patched = upsertEventIntoCalendar(cal, row);
                    const out = { ...patched, active_event_id: String(row.id) };
                    setCalendarActive(selectedAthlete.id, out);

                    try { setNextEventActive(selectedAthlete.id, row); } catch {}

                    if (ovNameEl) ovNameEl.value = '';
                    syncNextEventUI(selectedAthlete.id);
                    renderCalendarOverlay(selectedAthlete.id);
                });
            }

            // Close overlay on ESC
            document.addEventListener('keydown', (evt) => {
                if (evt.key === 'Escape' && isCalendarOverlayOpen()) {
                    closeCalendarOverlay();
                }
            });
        }

        function checkUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const athleteId = urlParams.get('athlete');
            if (athleteId) {
                document.getElementById('athlete-select').value = athleteId;
                onAthleteSelect({ target: { value: athleteId } });
            }
        }

        // ATHLETE SELECTION
        async function onAthleteSelect(e) {
            const id = e.target.value;
            if (!id) return;

            // Clear the chat empty-state / watermark immediately
            try {
                const messages = document.getElementById('messages');
                if (messages) messages.innerHTML = '';
            } catch {
                // ignore
            }

            selectedAthlete = athletes.find(a => a.id === id);
            
            // Update avatar
            const initials = (selectedAthlete.first_name?.[0] || '') + (selectedAthlete.last_name?.[0] || '');
            const avatarEl = document.getElementById('athlete-avatar');
            if (selectedAthlete.profile_photo) {
                avatarEl.innerHTML = `<img src="${selectedAthlete.profile_photo}" alt="">`;
            } else {
                avatarEl.textContent = initials;
            }

            // Show context box
            document.getElementById('athlete-context').classList.add('show');
            // document.getElementById('live-badge').style.display = 'inline';

            // Update workflow step
            setWorkflowStep(1);

            // Load athlete data
            const workouts = await supabase.fetch('workouts', `?athlete_id=eq.${id}&select=*`) || [];

            // Load AI program state (Supabase) - best effort, no hard dependency
            aiProgramState = await loadAIProgramState(id);

            // Sync ruleset selector from persisted per-athlete preference
            try {
                const rulesetEl = document.getElementById('ruleset-profile');
                if (rulesetEl) rulesetEl.value = getRulesetProfile();
            } catch {
                // ignore
            }
            
            // Load wearable data (safe fallback)
            let wearableData = { hasData: false, status: 'none' };
            try {
                wearableData = await loadWearableData(id);
            } catch (e) {
                wearableData = { hasData: false, status: 'none' };
                updateWearableUI(null);
            }
            latestWearableData = wearableData;

            // Calculate current week and phase
            currentWeek = Math.min(8, Math.max(1, Math.ceil((workouts.length + 1) / 3)));
            currentPhase = getPhase(currentWeek);
            
            // Update phase indicator in UI
            if (typeof updatePhaseIndicator === 'function') {
                updatePhaseIndicator();
            }
            
            // Calculate stats (simplified without feedback table)
            const avgRpe = '7.0';
            const compliance = workouts.length 
                ? Math.round((workouts.filter(w => w.status === 'completed').length / workouts.length) * 100) 
                : 100;

            // Suggest per-athlete ruleset (non-binding)
            try {
                const suggestion = suggestRulesetProfile({ athlete: selectedAthlete, compliance, wearableData: latestWearableData });
                updateRulesetSuggestionText(suggestion);
            } catch {
                updateRulesetSuggestionText(null);
            }

            // Update UI
            document.getElementById('ctx-week').textContent = `${currentWeek}/8`;
            document.getElementById('ctx-phase').textContent = currentPhase;
            document.getElementById('ctx-rpe').textContent = avgRpe;
            document.getElementById('ctx-compliance').textContent = `${compliance}%`;
            document.getElementById('week-label').textContent = `Sett. ${currentWeek} - ${currentPhase}`;

            // Update periodization UI
            updatePeriodizationUI(currentWeek, selectedAthlete, {
                avgRpe: parseFloat(avgRpe) || 0,
                compliance: compliance
            });

            // Update macrocycle UI
            updateMacrocycleUI(selectedAthlete.id);

            // Sync next-event override UI
            syncNextEventUI(selectedAthlete.id);

            // Render coach alerts panel
            try {
                renderCoachAlerts(selectedAthlete.id);
            } catch (e) {
                console.warn('Coach alerts render failed:', e);
            }

            // Avoid auto-triggering full AI generation on athlete select (Ollama can be slow).
            // User can trigger generation via the existing "Rigenera" button.
            try {
                addAIMessageSafe('strength', 'Atleta caricato. Premi â€œRigeneraâ€ per generare la settimana.', 'medium');
            } catch {
                // ignore
            }
            setWorkflowStep(1);
        }

        function nowIso() {
            return new Date().toISOString();
        }

        function hashString(input) {
            // small stable hash (FNV-1a 32-bit)
            const str = String(input || '');
            let h = 0x811c9dc5;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 0x01000193);
            }
            return (h >>> 0).toString(16).padStart(8, '0');
        }

        function deepMerge(base, patch) {
            if (!patch || typeof patch !== 'object' || Array.isArray(patch)) return patch;
            const out = (base && typeof base === 'object' && !Array.isArray(base)) ? { ...base } : {};
            for (const key of Object.keys(patch)) {
                const pv = patch[key];
                if (pv && typeof pv === 'object' && !Array.isArray(pv)) {
                    out[key] = deepMerge(out[key], pv);
                } else {
                    out[key] = pv;
                }
            }
            return out;
        }

        function defaultAIProgramState(athleteId) {
            return {
                version: 1,
                athlete_id: athleteId,
                created_at: nowIso(),
                updated_at: nowIso(),
                preferences: {
                    language: 'it',
                    coach_style: 'diretto',
                    avoid_repeats_window: 6,
                    // Per-cliente: conservative | balanced | aggressive
                    ruleset_profile: 'balanced'
                },
                constraints: {
                    injuries: [],
                    exercises_to_avoid: [],
                    equipment: null,
                    availability: null,
                    next_event: null,
                    events: [],
                    active_event_id: null
                },
                history: {
                    recent_workout_hashes: [],
                    last_phase: null,
                    last_week: null,
                    last_titles: []
                },
                last_context: {
                    last_coach_instructions: '',
                    last_wearable_summary: ''
                }
            };
        }

        async function loadAIProgramState(athleteId) {
            try {
                // Use raw fetch to avoid noisy console errors if the table is not installed yet.
                const url = `${SUPABASE_URL}/rest/v1/ai_program_state?athlete_id=eq.${athleteId}&select=state,updated_at`;
                const res = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });

                if (!res.ok) {
                    if (!warnedAiProgramStateMissing && res.status === 404) {
                        warnedAiProgramStateMissing = true;
                        console.warn(
                            'Tabella Supabase mancante: ai_program_state. Esegui supabase-ai-program-state.sql nel SQL Editor per abilitare la memoria AI.'
                        );
                    }
                    // If the table doesn't exist / RLS blocks, just fall back to local defaults.
                    return defaultAIProgramState(athleteId);
                }

                const rows = await res.json();
                const row = rows && rows[0] ? rows[0] : null;
                const base = defaultAIProgramState(athleteId);
                const merged = deepMerge(base, row?.state || {});
                merged.updated_at = row?.updated_at || merged.updated_at;
                return merged;
            } catch {
                return defaultAIProgramState(athleteId);
            }
        }

        function getRulesetProfile() {
            const p = String(aiProgramState?.preferences?.ruleset_profile || 'balanced').toLowerCase();
            if (p === 'conservative' || p === 'aggressive' || p === 'balanced') return p;
            return 'balanced';
        }

        function formatRulesetProfile(profile) {
            return {
                conservative: 'Conservativo (rischio basso)',
                balanced: 'Bilanciato',
                aggressive: 'Aggressivo (spinta alta)'
            }[String(profile || '').toLowerCase()] || 'Bilanciato';
        }

        function normalizeExperienceLevel(level) {
            const v = String(level || '').toLowerCase();
            if (!v) return 'unknown';
            if (v.includes('begin') || v.includes('princ') || v.includes('base') || v.includes('nov')) return 'beginner';
            if (v.includes('inter') || v.includes('medio')) return 'intermediate';
            if (v.includes('avanz') || v.includes('advanced') || v.includes('pro') || v.includes('Ã©lite') || v.includes('elite')) return 'advanced';
            return 'unknown';
        }

        function suggestRulesetProfile({ athlete, compliance, wearableData }) {
            const reasons = [];
            const exp = normalizeExperienceLevel(athlete?.experience_level);
            const c = Number(compliance);
            const hasWearable = Boolean(wearableData?.hasData);
            const wearableUsable = Boolean(wearableData?.usable);
            const readiness = wearableData?.readiness != null ? Number(wearableData.readiness) : null;

            if (Number.isFinite(c) && c < 60) reasons.push(`compliance bassa (${c}%)`);
            if (!hasWearable) reasons.push('nessun wearable');
            if (hasWearable && !wearableUsable) reasons.push('dati wearable troppo vecchi');
            if (exp === 'beginner') reasons.push('livello principiante');

            if (
                (Number.isFinite(c) && c < 60) ||
                (hasWearable && !wearableUsable) ||
                exp === 'beginner'
            ) {
                return { profile: 'conservative', reasons };
            }

            const strongCompliance = Number.isFinite(c) ? c >= 85 : false;
            const wearableOk = !hasWearable || wearableUsable;
            const readinessOk = readiness == null || (Number.isFinite(readiness) && readiness >= 70);
            if (exp === 'advanced' && strongCompliance && wearableOk && readinessOk) {
                if (strongCompliance) reasons.push(`compliance alta (${c}%)`);
                if (readiness != null && Number.isFinite(readiness)) reasons.push(`readiness ${readiness}/100`);
                return { profile: 'aggressive', reasons };
            }

            if (!reasons.length) reasons.push('dati nella norma');
            return { profile: 'balanced', reasons };
        }

        function updateRulesetSuggestionText(suggestion) {
            const el = document.getElementById('ruleset-suggestion');
            if (!el) return;
            if (!suggestion) {
                el.textContent = '';
                return;
            }
            const profileLabel = formatRulesetProfile(suggestion.profile);
            const why = (suggestion.reasons || []).filter(Boolean).slice(0, 3).join(', ');
            el.textContent = `Consiglio: ${profileLabel}${why ? ` (per: ${why})` : ''}.`;
        }

        async function saveAIProgramState(athleteId, patch) {
            try {
                if (!athleteId) return;
                const base = aiProgramState || defaultAIProgramState(athleteId);
                const merged = deepMerge(base, patch || {});
                merged.updated_at = nowIso();
                aiProgramState = merged;

                // If the table isn't installed, upsert will fail: swallow it (best-effort).
                const payload = { athlete_id: athleteId, state: merged };
                const res = await supabase.upsert('ai_program_state', payload, 'athlete_id');
                if (res && res.error) {
                    const code = res?.details?.code || res?.details?.error?.code || res?.code;
                    const msg = String(res?.message || 'Upsert ai_program_state fallito');
                    if (!warnedAiProgramStateMissing && (code === 'PGRST205' || msg.includes('ai_program_state'))) {
                        warnedAiProgramStateMissing = true;
                        console.warn(
                            'Impossibile salvare ai_program_state (manca tabella o schema cache). Esegui supabase-ai-program-state.sql nel SQL Editor di Supabase.'
                        );
                    }
                    // keep local memory even if Supabase write failed
                    return;
                }
            } catch {
                // ignore
            }
        }
        
        // WEARABLE DATA LOADING WITH FRESHNESS CHECK
        // NOTE: In this project, wearable data is stored in athletes.biometrics_data (JSON), not in a biometrics table.
        async function loadWearableData(athleteId) {
            try {
                const rows = await supabase.fetch('athletes', `?id=eq.${athleteId}&select=biometrics_data,updated_at`);
                const row = rows && rows[0] ? rows[0] : null;
                const data = row?.biometrics_data;

                if (!data || !data.hasData) {
                    updateWearableUI(null);
                    return { hasData: false, status: 'none' };
                }

                const lastSync = row?.updated_at ? new Date(row.updated_at) : null;
                const now = new Date();
                const hoursAgo = lastSync ? (now - lastSync) / (1000 * 60 * 60) : 0;

                // Determine freshness status (best-effort)
                let freshness = { status: 'fresh', label: 'Aggiornato', usable: true };
                if (lastSync) {
                    if (hoursAgo > 72) {
                        freshness = { status: 'old', label: '> 3 giorni', usable: false };
                    } else if (hoursAgo > 24) {
                        freshness = { status: 'stale', label: `${Math.round(hoursAgo)}h fa`, usable: true };
                    }
                }

                const result = {
                    hasData: true,
                    usable: freshness.usable,
                    status: freshness.status,
                    hoursAgo: hoursAgo,
                    // Map what we actually have in biometrics_data
                    hrv: data.hrv || data.hrv_average || null,
                    hrvTrend: data.hrvTrend || data.hrv_trend || null,
                    sleep: data.sleep || data.sleep_hours || data.sleep_duration || null,
                    sleepQuality: data.sleepQuality || data.sleep_quality || null,
                    readiness: data.readiness || data.readiness_score || null,
                    rhr: data.rhr || data.resting_hr || null,
                    source: data.source || 'Wearable'
                };

                updateWearableUI(result, freshness);
                return result;
            } catch (error) {
                updateWearableUI(null);
                return { hasData: false, status: 'none' };
            }
        }
        
        function updateWearableUI(data, freshness = null) {
            const badge = document.getElementById('freshness-badge');
            const warning = document.getElementById('wearable-warning');
            
            if (!data || !data.hasData) {
                // No wearable
                badge.textContent = 'Non connesso';
                badge.className = 'freshness-badge none';
                document.getElementById('ctx-hrv').textContent = '-';
                document.getElementById('ctx-sleep').textContent = '-';
                document.getElementById('ctx-readiness').textContent = '-';
                warning.style.display = 'none';
                return;
            }
            
            // Update badge
            badge.textContent = freshness.label;
            badge.className = `freshness-badge ${freshness.status}`;
            
            // Update stats
            document.getElementById('ctx-hrv').textContent = data.hrv ? `${data.hrv} ms` : '-';
            document.getElementById('ctx-sleep').textContent = data.sleep ? `${data.sleep}h` : '-';
            document.getElementById('ctx-readiness').textContent = data.readiness ? `${data.readiness}/100` : '-';
            
            // Show warning if data is stale or old
            if (freshness.status === 'stale') {
                warning.style.display = 'flex';
                warning.classList.remove('critical');
                document.getElementById('warning-text').textContent = 
                    `Dati di ${Math.round(data.hoursAgo)}h fa - Uso con cautela`;
            } else if (freshness.status === 'old') {
                warning.style.display = 'flex';
                warning.classList.add('critical');
                document.getElementById('warning-text').textContent = 
                    `Dati troppo vecchi (${Math.round(data.hoursAgo/24)} giorni) - Ignoro, uso solo RPE`;
            } else {
                warning.style.display = 'none';
            }
        }

        function getPhase(week) {
            if (week <= 2) return 'Adattamento';
            if (week <= 4) return 'Accumulo';
            if (week <= 6) return 'Intensificazione';
            if (week <= 7) return 'Peaking';
            return 'Deload';
        }

        /**
         * Aggiorna l'UI della sezione periodizzazione
         */
        function updatePeriodizationUI(weekNumber, athlete, feedback = {}) {
            try {
                if (!window.PeriodizationEngine) return;
                
                const sportKey = String(athlete?.sport || '').toLowerCase();
                const athleteContext = {
                    experience_level: athlete?.experience_level || 'intermediate',
                    sport: sportKey,
                    goal: 'massa',
                    compliance: feedback.compliance || 100
                };
                
                // Get parameters
                let params = window.PeriodizationEngine.getWeekParameters(weekNumber, athleteContext);
                params = window.PeriodizationEngine.adaptFromFeedback(params, feedback);
                
                // Update model badge
                const modelEl = document.getElementById('periodization-model');
                if (modelEl) {
                    const modelShort = (params.modelName || '').replace(/\s+/g, ' ').split(' ').slice(0, 2).join(' ');
                    modelEl.textContent = modelShort || 'Standard';
                }
                
                // Update volume bar
                const volumeBar = document.getElementById('volume-bar');
                const volumePct = document.getElementById('volume-pct');
                if (volumeBar && volumePct) {
                    const vol = Math.min(130, Math.max(50, params.volume));
                    volumeBar.style.width = `${vol}%`;
                    volumePct.textContent = `${Math.round(vol)}%`;
                }
                
                // Update intensity bar
                const intensityBar = document.getElementById('intensity-bar');
                const intensityPctEl = document.getElementById('intensity-pct');
                if (intensityBar && intensityPctEl) {
                    const intens = Math.min(100, Math.max(50, params.intensity));
                    intensityBar.style.width = `${intens}%`;
                    intensityPctEl.textContent = `${Math.round(intens)}%`;
                }
                
                // Update focus
                const focusEl = document.getElementById('week-focus');
                if (focusEl) {
                    focusEl.textContent = params.focus || 'Base building';
                }
                
                // Update adjustments
                const adjSection = document.getElementById('periodization-adjustments');
                const adjText = document.getElementById('adjustments-text');
                if (adjSection && adjText) {
                    if (params.adjustments && params.adjustments.length > 0) {
                        adjText.textContent = params.adjustments.join(' | ');
                        adjSection.style.display = 'flex';
                    } else {
                        adjSection.style.display = 'none';
                    }
                }
                
                console.log('ðŸ“Š Periodization UI updated:', params);
            } catch (e) {
                console.warn('updatePeriodizationUI error:', e);
            }
        }

        // ============================================
        // MACROCYCLE UI FUNCTIONS
        // ============================================
        
        function updateMacrocycleUI(athleteId) {
            const section = document.getElementById('macrocycle-section');
            const activeContent = document.getElementById('macro-active-content');
            const emptyContent = document.getElementById('macro-empty-content');
            
            if (!section || !window.MacrocyclePlanner) {
                if (section) section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            const macro = window.MacrocyclePlanner.getActive(athleteId);
            
            if (!macro) {
                activeContent.style.display = 'none';
                emptyContent.style.display = 'block';
                return;
            }
            
            activeContent.style.display = 'block';
            emptyContent.style.display = 'none';
            
            // Event info
            document.getElementById('macro-event-name').textContent = macro.eventName || 'Obiettivo';
            document.getElementById('macro-event-date').textContent = formatMacroDate(macro.targetDate);
            
            // Progress
            const globalWeek = window.MacrocyclePlanner.getGlobalWeek(athleteId);
            const progressPct = Math.min(100, (globalWeek / macro.totalWeeks) * 100);
            document.getElementById('macro-progress-fill').style.width = `${progressPct}%`;
            document.getElementById('macro-week-info').textContent = `Settimana ${globalWeek}/${macro.totalWeeks}`;
            
            const daysLeft = Math.ceil((new Date(macro.targetDate) - new Date()) / (24 * 60 * 60 * 1000));
            document.getElementById('macro-days-left').textContent = `${daysLeft} giorni`;
            
            // Phases
            const phasesContainer = document.getElementById('macro-phases');
            const currentPhase = window.MacrocyclePlanner.getCurrentPhase(athleteId);
            
            phasesContainer.innerHTML = macro.phases.map(phase => {
                let className = 'macro-phase-chip';
                if (currentPhase && phase.code === currentPhase.code) {
                    className += ' active';
                } else if (new Date(phase.endDate) < new Date()) {
                    className += ' completed';
                }
                return `<span class="${className}">${phase.name}</span>`;
            }).join('');
        }

        // ============================================
        // NEXT EVENT (match/fight) OVERRIDE
        // ============================================

        const NEXT_EVENT_STORAGE_KEY = 'gr_perform_next_event_v1';
        const EVENTS_STORAGE_KEY = 'gr_perform_events_v1';
        let nextEventSaveTimer = null;

        function loadNextEventMap() {
            try {
                const raw = localStorage.getItem(NEXT_EVENT_STORAGE_KEY);
                const parsed = raw ? JSON.parse(raw) : null;
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch {
                return {};
            }
        }

        function saveNextEventMap(map) {
            try {
                localStorage.setItem(NEXT_EVENT_STORAGE_KEY, JSON.stringify(map || {}));
            } catch {
                // ignore
            }
        }

        function loadEventsMap() {
            try {
                const raw = localStorage.getItem(EVENTS_STORAGE_KEY);
                const parsed = raw ? JSON.parse(raw) : null;
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch {
                return {};
            }
        }

        function saveEventsMap(map) {
            try {
                localStorage.setItem(EVENTS_STORAGE_KEY, JSON.stringify(map || {}));
            } catch {
                // ignore
            }
        }

        function normalizeEventRow(row) {
            if (!row || typeof row !== 'object') return null;
            const id = String(row.id || '').trim() || (crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`);
            const type = String(row.type || 'match').toLowerCase().trim();
            const name = String(row.name || '').trim();
            const date = String(row.date || '').trim();
            const md0Mode = String(row.md0_mode || row.md0Mode || 'off').toLowerCase().trim() || 'off';
            if (!name && !date) return null;
            return {
                id,
                type: (type === 'fight' || type === 'other' || type === 'match') ? type : 'match',
                name,
                date,
                md0_mode: (md0Mode === 'primer') ? 'primer' : 'off',
                updated_at: row.updated_at || new Date().toISOString()
            };
        }

        function getCalendarFromProgramState() {
            try {
                const evs = aiProgramState?.constraints?.events;
                const activeId = aiProgramState?.constraints?.active_event_id;
                const out = Array.isArray(evs) ? evs.map(normalizeEventRow).filter(Boolean) : [];
                return { events: out, active_event_id: activeId ? String(activeId) : null };
            } catch {
                return { events: [], active_event_id: null };
            }
        }

        function getCalendarFromLocal(athleteId) {
            try {
                const map = loadEventsMap();
                const v = map[String(athleteId)];
                const events = Array.isArray(v?.events) ? v.events.map(normalizeEventRow).filter(Boolean) : [];
                const activeId = v?.active_event_id ? String(v.active_event_id) : null;
                return { events, active_event_id: activeId };
            } catch {
                return { events: [], active_event_id: null };
            }
        }

        function persistCalendarLocal(athleteId, calendar) {
            if (!athleteId) return;
            try {
                const map = loadEventsMap();
                map[String(athleteId)] = {
                    events: Array.isArray(calendar?.events) ? calendar.events : [],
                    active_event_id: calendar?.active_event_id || null,
                    updated_at: new Date().toISOString()
                };
                saveEventsMap(map);
            } catch {
                // ignore
            }
        }

        function persistCalendarStateDebounced(athleteId, calendar) {
            if (!athleteId) return;
            if (nextEventSaveTimer) clearTimeout(nextEventSaveTimer);
            nextEventSaveTimer = setTimeout(async () => {
                try {
                    await saveAIProgramState(athleteId, {
                        constraints: {
                            events: Array.isArray(calendar?.events) ? calendar.events : [],
                            active_event_id: calendar?.active_event_id || null
                        }
                    });
                } catch {
                    // ignore
                }
            }, 450);
        }

        function pickAutoActiveEventId(events) {
            const list = Array.isArray(events) ? events : [];
            const today = new Date();
            const todayDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const withDate = list
                .map(e => ({ e, d: parseDateOnly(e?.date) }))
                .filter(x => x.d && !Number.isNaN(x.d.getTime()));
            if (!withDate.length) return null;

            const future = withDate
                .filter(x => x.d >= todayDate)
                .sort((a, b) => a.d - b.d);
            if (future.length) return String(future[0].e.id);

            const past = withDate.sort((a, b) => b.d - a.d);
            return past.length ? String(past[0].e.id) : null;
        }

        function getCalendarActive(athleteId) {
            // Priority: aiProgramState â†’ localStorage
            const fromState = getCalendarFromProgramState();
            if (fromState.events.length) {
                const existing = fromState.active_event_id && fromState.events.some(e => String(e.id) === String(fromState.active_event_id));
                const activeId = existing ? String(fromState.active_event_id) : pickAutoActiveEventId(fromState.events);
                return { events: fromState.events, active_event_id: activeId };
            }
            return getCalendarFromLocal(athleteId);
        }

        function setCalendarActive(athleteId, calendar) {
            persistCalendarLocal(athleteId, calendar);
            persistCalendarStateDebounced(athleteId, calendar);
        }

        function upsertEventIntoCalendar(calendar, eventRow) {
            const e = normalizeEventRow(eventRow);
            if (!e) return calendar;
            const events = Array.isArray(calendar?.events) ? [...calendar.events] : [];
            const idx = events.findIndex(x => String(x.id) === String(e.id));
            if (idx >= 0) events[idx] = { ...events[idx], ...e, updated_at: new Date().toISOString() };
            else events.push({ ...e, updated_at: new Date().toISOString() });
            // sort asc by date (missing date goes bottom)
            events.sort((a, b) => {
                const da = parseDateOnly(a.date);
                const db = parseDateOnly(b.date);
                if (!da && !db) return 0;
                if (!da) return 1;
                if (!db) return -1;
                return da - db;
            });
            return { ...(calendar || {}), events };
        }

        function removeEventFromCalendar(calendar, id) {
            const events = Array.isArray(calendar?.events) ? calendar.events.filter(e => String(e.id) !== String(id)) : [];
            const activeId = String(calendar?.active_event_id || '');
            const nextActive = activeId && String(activeId) === String(id) ? pickAutoActiveEventId(events) : (activeId || pickAutoActiveEventId(events));
            return { events, active_event_id: nextActive };
        }

        function getActiveEventFromCalendar(calendar) {
            const events = Array.isArray(calendar?.events) ? calendar.events : [];
            const id = calendar?.active_event_id ? String(calendar.active_event_id) : null;
            if (id) {
                const found = events.find(e => String(e.id) === String(id));
                if (found) return found;
            }
            const autoId = pickAutoActiveEventId(events);
            return autoId ? (events.find(e => String(e.id) === String(autoId)) || null) : null;
        }

        function getNextEventForAthlete(athleteId) {
            if (!athleteId) return null;
            const map = loadNextEventMap();
            const v = map[String(athleteId)];
            if (!v || typeof v !== 'object') return null;
            const name = String(v.name || '').trim();
            const date = String(v.date || '').trim();
            const md0Mode = String(v.md0_mode || v.md0Mode || '').trim();
            if (!name && !date && !md0Mode) return null;
            return { name, date, md0_mode: md0Mode || undefined };
        }

        function setNextEventForAthlete(athleteId, nextEvent) {
            if (!athleteId) return;
            const map = loadNextEventMap();
            const name = String(nextEvent?.name || '').trim();
            const date = String(nextEvent?.date || '').trim();
            const md0Mode = String(nextEvent?.md0_mode || nextEvent?.md0Mode || '').trim();
            if (!name && !date && !md0Mode) {
                delete map[String(athleteId)];
            } else {
                map[String(athleteId)] = { name, date, md0_mode: md0Mode || 'off', updated_at: new Date().toISOString() };
            }
            saveNextEventMap(map);
        }

        function clearNextEventForAthlete(athleteId) {
            if (!athleteId) return;
            const map = loadNextEventMap();
            delete map[String(athleteId)];
            saveNextEventMap(map);
        }

        function getNextEventFromProgramState() {
            try {
                const v = aiProgramState?.constraints?.next_event;
                if (!v || typeof v !== 'object') return null;
                const name = String(v.name || '').trim();
                const date = String(v.date || '').trim();
                const md0Mode = String(v.md0_mode || v.md0Mode || '').trim();
                if (!name && !date && !md0Mode) return null;
                return { name, date, md0_mode: md0Mode || undefined };
            } catch {
                return null;
            }
        }

        function getNextEventActive(athleteId) {
            // Priority: Calendar active event (aiProgramState â†’ localStorage) â†’ legacy next_event â†’ legacy localStorage
            try {
                const cal = getCalendarActive(athleteId);
                const active = getActiveEventFromCalendar(cal);
                if (active) return active;
            } catch {
                // ignore
            }
            const fromState = getNextEventFromProgramState();
            if (fromState) return fromState;
            return getNextEventForAthlete(athleteId);
        }

        function setNextEventActive(athleteId, nextEvent) {
            // Always mirror to localStorage (fast UX)
            setNextEventForAthlete(athleteId, nextEvent);

            // Also upsert into the athlete calendar and set as active
            try {
                const cal = getCalendarActive(athleteId);
                const active = getActiveEventFromCalendar(cal);
                const baseId = active?.id || (crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`);
                const patched = upsertEventIntoCalendar(cal, { id: baseId, type: nextEvent?.type || 'match', name: nextEvent?.name, date: nextEvent?.date, md0_mode: nextEvent?.md0_mode || 'off' });
                const out = { ...patched, active_event_id: String(baseId) };
                setCalendarActive(athleteId, out);
            } catch {
                // ignore
            }

            // Best-effort persist to Supabase via aiProgramState (debounced)
            if (nextEventSaveTimer) clearTimeout(nextEventSaveTimer);
            nextEventSaveTimer = setTimeout(async () => {
                try {
                    if (!athleteId) return;
                    const name = String(nextEvent?.name || '').trim();
                    const date = String(nextEvent?.date || '').trim();
                    const md0Mode = String(nextEvent?.md0_mode || nextEvent?.md0Mode || 'off').trim() || 'off';
                    const payload = (!name && !date && !md0Mode) ? null : { name, date, md0_mode: md0Mode };
                    await saveAIProgramState(athleteId, { constraints: { next_event: payload } });
                } catch {
                    // ignore
                }
            }, 450);
        }

        function clearNextEventActive(athleteId) {
            clearNextEventForAthlete(athleteId);
            // Also clear active event selection (keeps calendar history)
            try {
                const cal = getCalendarActive(athleteId);
                const out = { ...(cal || {}), active_event_id: null };
                setCalendarActive(athleteId, out);
            } catch {
                // ignore
            }
            if (nextEventSaveTimer) clearTimeout(nextEventSaveTimer);
            nextEventSaveTimer = setTimeout(async () => {
                try {
                    if (!athleteId) return;
                    await saveAIProgramState(athleteId, { constraints: { next_event: null } });
                } catch {
                    // ignore
                }
            }, 200);
        }

        function renderCalendarUI(athleteId) {
            const listEl = document.getElementById('calendar-events-list');
            if (!listEl) return;
            const cal = getCalendarActive(athleteId);
            const events = Array.isArray(cal?.events) ? cal.events : [];
            const activeId = cal?.active_event_id ? String(cal.active_event_id) : null;

            if (!events.length) {
                listEl.innerHTML = '<div class="next-event-hint">Nessun evento in calendario.</div>';
                return;
            }

            listEl.innerHTML = events.map(e => {
                const isActive = activeId && String(e.id) === String(activeId);
                const typeLabel = e.type === 'fight' ? 'Fight' : e.type === 'other' ? 'Altro' : 'Match';
                const md0Label = String(e.md0_mode || 'off') === 'primer' ? 'MD0: primer' : 'MD0: off';
                return `
                    <div class="calendar-item ${isActive ? 'active' : ''}">
                        <div class="calendar-item-left">
                            <div class="calendar-item-title">${escapeHtml(String(e.name || 'Evento'))}</div>
                            <div class="calendar-item-sub">${escapeHtml(String(e.date || 'N/A'))}</div>
                        </div>
                        <div class="calendar-item-actions">
                            <span class="calendar-pill">${typeLabel}</span>
                            <span class="calendar-pill">${md0Label}</span>
                            <button class="next-event-btn" type="button" data-cal-set="${escapeHtml(String(e.id))}">Usa</button>
                            <button class="next-event-btn" type="button" data-cal-del="${escapeHtml(String(e.id))}">Rimuovi</button>
                        </div>
                    </div>
                `;
            }).join('');

            // Wire buttons
            listEl.querySelectorAll('[data-cal-set]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const id = btn.getAttribute('data-cal-set');
                    const cal2 = getCalendarActive(selectedAthlete.id);
                    const out = { ...(cal2 || {}), active_event_id: id };
                    setCalendarActive(selectedAthlete.id, out);
                    syncNextEventUI(selectedAthlete.id);
                });
            });
            listEl.querySelectorAll('[data-cal-del]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const id = btn.getAttribute('data-cal-del');
                    const cal2 = getCalendarActive(selectedAthlete.id);
                    const out = removeEventFromCalendar(cal2, id);
                    setCalendarActive(selectedAthlete.id, out);
                    syncNextEventUI(selectedAthlete.id);
                });
            });
        }

        // ============================================
        // FULLSCREEN CALENDAR OVERLAY (month view)
        // ============================================

        const calendarOverlayState = {
            monthAnchor: null, // Date (1st day of month)
            selectedDate: null, // YYYY-MM-DD
            trainingDays: [],   // array of day-of-week indices (0=Mon..6=Sun)
            workoutDates: {},   // { 'YYYY-MM-DD': [{name, status}] }
            scheduleLoaded: false
        };

        function isCalendarOverlayOpen() {
            const el = document.getElementById('calendar-overlay');
            return Boolean(el && el.classList.contains('show'));
        }

        async function openCalendarOverlay(athleteId) {
            const overlay = document.getElementById('calendar-overlay');
            if (!overlay) return;

            // Choose initial month: active event date, else today
            const cal = getCalendarActive(athleteId);
            const active = getActiveEventFromCalendar(cal);
            const activeDate = active?.date ? parseDateOnly(active.date) : null;
            const base = activeDate || new Date();
            calendarOverlayState.monthAnchor = new Date(base.getFullYear(), base.getMonth(), 1);
            calendarOverlayState.selectedDate = active?.date && parseDateOnly(active.date) ? String(active.date) : null;

            // Load training days from schedule + workout history (once per open)
            calendarOverlayState.trainingDays = [];
            calendarOverlayState.workoutDates = {};
            calendarOverlayState.scheduleLoaded = false;

            overlay.classList.add('show');
            overlay.setAttribute('aria-hidden', 'false');

            // Prefill add-date with selected date (if any)
            const ovDateEl = document.getElementById('calendar-overlay-event-date');
            if (ovDateEl && calendarOverlayState.selectedDate) ovDateEl.value = calendarOverlayState.selectedDate;

            // Fetch schedule + history async then re-render
            await loadCalendarScheduleAndHistory(athleteId);
            renderCalendarOverlay(athleteId);
        }

        function closeCalendarOverlay() {
            const overlay = document.getElementById('calendar-overlay');
            if (!overlay) return;
            overlay.classList.remove('show');
            overlay.setAttribute('aria-hidden', 'true');
        }

        function shiftOverlayMonth(deltaMonths) {
            const anchor = calendarOverlayState.monthAnchor;
            const base = anchor instanceof Date && !Number.isNaN(anchor.getTime()) ? anchor : new Date();
            calendarOverlayState.monthAnchor = new Date(base.getFullYear(), base.getMonth() + Number(deltaMonths || 0), 1);
        }

        async function loadCalendarScheduleAndHistory(athleteId) {
            // Training days from weekly_schedule
            try {
                const schedule = await supabase.fetch('weekly_schedule', `?athlete_id=eq.${athleteId}`).then(r => (r && r[0]) ? r[0] : {}).catch(() => ({}));
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                const trainingDays = [];
                days.forEach((d, idx) => {
                    const v = String(schedule[d] || '').toLowerCase();
                    if (v === 'gr_available' || v === 'gr_perform' || v === 'both') {
                        trainingDays.push(idx); // 0=Mon..6=Sun
                    }
                });
                calendarOverlayState.trainingDays = trainingDays;
            } catch {
                calendarOverlayState.trainingDays = [];
            }

            // Workout history from workouts table (last 6 months)
            try {
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const isoFrom = dateToIso(sixMonthsAgo);
                const workouts = await supabase.fetch('workouts', `?athlete_id=eq.${athleteId}&created_at=gte.${isoFrom}&select=id,name,status,created_at,scheduled_date`).catch(() => []);
                const byDate = {};
                (Array.isArray(workouts) ? workouts : []).forEach(w => {
                    const dateStr = w.scheduled_date || (w.created_at ? w.created_at.slice(0, 10) : null);
                    if (!dateStr) return;
                    const iso = normalizeDateToIso(dateStr);
                    if (!iso) return;
                    if (!byDate[iso]) byDate[iso] = [];
                    byDate[iso].push({ name: w.name || 'Workout', status: w.status || 'assigned' });
                });
                calendarOverlayState.workoutDates = byDate;
            } catch {
                calendarOverlayState.workoutDates = {};
            }

            // Also pull workout_session_feedback for completed sessions
            try {
                const sessions = await supabase.fetch('workout_session_feedback', `?athlete_id=eq.${athleteId}&order=completed_at.desc&limit=100&select=workout_id,completed_at`).catch(() => []);
                (Array.isArray(sessions) ? sessions : []).forEach(s => {
                    const dateStr = s.completed_at ? s.completed_at.slice(0, 10) : null;
                    if (!dateStr) return;
                    const iso = normalizeDateToIso(dateStr);
                    if (!iso) return;
                    if (!calendarOverlayState.workoutDates[iso]) calendarOverlayState.workoutDates[iso] = [];
                    const existing = calendarOverlayState.workoutDates[iso].find(x => x.status === 'completed');
                    if (!existing) {
                        calendarOverlayState.workoutDates[iso].push({ name: 'Sessione completata', status: 'completed' });
                    }
                });
            } catch {
                // ignore
            }

            calendarOverlayState.scheduleLoaded = true;
        }

        function getDayOfWeekIndex(dateObj) {
            // Returns 0=Mon..6=Sun from JS Date (which is 0=Sun..6=Sat)
            const jsDay = dateObj.getDay();
            return (jsDay + 6) % 7;
        }

        function formatMonthLabel(dateObj) {
            try {
                const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
                if (Number.isNaN(d.getTime())) return 'â€”';
                return d.toLocaleDateString('it-IT', { month: 'long', year: 'numeric' });
            } catch {
                return 'â€”';
            }
        }

        function dateToIso(dateObj) {
            const d = dateObj instanceof Date ? dateObj : new Date(dateObj);
            if (Number.isNaN(d.getTime())) return '';
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        function addDays(dateObj, days) {
            const d = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
            d.setDate(d.getDate() + Number(days || 0));
            return d;
        }

        function startOfMonthGridMonday(firstOfMonth) {
            const first = new Date(firstOfMonth.getFullYear(), firstOfMonth.getMonth(), 1);
            return startOfWeekMonday(first);
        }

        function getMacroPhaseLabelForDate(athleteId, dateObj) {
            try {
                if (!window.MacrocyclePlanner?.getCurrentPhase) return '';
                const p = window.MacrocyclePlanner.getCurrentPhase(athleteId, dateObj);
                const name = String(p?.name || '').trim();
                return name;
            } catch {
                return '';
            }
        }

        function groupEventsByDate(events) {
            const out = {};
            (Array.isArray(events) ? events : []).forEach(e => {
                const key = String(e?.date || '').trim();
                if (!key) return;
                if (!out[key]) out[key] = [];
                out[key].push(e);
            });
            return out;
        }

        // Compute MD label for a day relative to active event date
        // Returns: 'md-3', 'md-2', 'md-1', 'md0', 'md+1', 'md+2', 'md+3' or null if too far
        function computeMdLabelForDay(dayDate, eventDate) {
            if (!dayDate || !eventDate) return null;
            try {
                const d = new Date(dayDate);
                const e = new Date(eventDate);
                if (isNaN(d.getTime()) || isNaN(e.getTime())) return null;
                // Reset to midnight for accurate day diff
                d.setHours(0, 0, 0, 0);
                e.setHours(0, 0, 0, 0);
                const diffMs = d.getTime() - e.getTime();
                const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));
                if (diffDays === 0) return 'md0';
                if (diffDays > 0 && diffDays <= 7) return `md+${diffDays}`;
                if (diffDays < 0 && diffDays >= -7) return `md${diffDays}`;
                return null; // too far from event
            } catch {
                return null;
            }
        }

        // Render the situation panel showing current athlete status
        function renderSituationPanel(athleteId, activeEvent, containerEl) {
            if (!containerEl) return;
            if (!athleteId) {
                containerEl.innerHTML = '<p style="color:#888;">Seleziona un atleta per vedere la situazione.</p>';
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayIso = dateToIso(today);

            // Calculate MD for today
            let mdToday = null;
            let eventDateDisplay = '';
            let eventName = '';
            let daysUntilEvent = null;

            if (activeEvent?.date) {
                const evDate = parseDateOnly(activeEvent.date);
                if (evDate) {
                    evDate.setHours(0, 0, 0, 0);
                    const diffMs = evDate.getTime() - today.getTime();
                    daysUntilEvent = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    mdToday = computeMdLabelForDay(today, evDate);
                    eventDateDisplay = formatDateDisplay(evDate);
                    eventName = activeEvent.name || 'Evento';
                }
            }

            // Build status HTML
            let html = '';

            if (activeEvent && daysUntilEvent !== null) {
                const urgencyClass = daysUntilEvent <= 1 ? 'urgent' : (daysUntilEvent <= 3 ? 'soon' : 'normal');
                html += `<div class="situation-row">`;
                html += `<span class="situation-label">Prossimo evento:</span>`;
                html += `<span class="situation-value ${urgencyClass}">${escapeHtml(eventName)}</span>`;
                html += `</div>`;
                html += `<div class="situation-row">`;
                html += `<span class="situation-label">Data:</span>`;
                html += `<span class="situation-value">${escapeHtml(eventDateDisplay)}</span>`;
                html += `</div>`;
                html += `<div class="situation-row">`;
                html += `<span class="situation-label">Tra:</span>`;
                html += `<span class="situation-value ${urgencyClass}">${daysUntilEvent} giorn${daysUntilEvent === 1 ? 'o' : 'i'}</span>`;
                html += `</div>`;
            } else {
                html += `<div class="situation-row">`;
                html += `<span class="situation-label">Prossimo evento:</span>`;
                html += `<span class="situation-value" style="color:#888;">Nessun evento programmato</span>`;
                html += `</div>`;
            }

            // MD Today
            if (mdToday) {
                const mdClass = mdToday.replace('+', '').replace('-', '-');
                html += `<div class="situation-row situation-md">`;
                html += `<span class="situation-label">Oggi:</span>`;
                html += `<span class="cal-md-badge ${mdClass}">${mdToday.toUpperCase()}</span>`;
                html += `</div>`;
            }

            // Tactical suggestion based on MD
            let suggestion = '';
            let suggestionIcon = '';
            if (mdToday) {
                const mdNum = parseInt(mdToday.replace('md', ''), 10) || 0;
                if (mdNum === 0) {
                    suggestion = 'GARA/PARTITA - Attivazione leggera pre-match';
                    suggestionIcon = 'ðŸ”¥';
                } else if (mdNum === -1) {
                    suggestion = 'Priming neuromuscolare - NO fatica, solo attivazione';
                    suggestionIcon = 'âš¡';
                } else if (mdNum === -2) {
                    suggestion = 'Deload moderato - Volume ridotto, intensitÃ  OK';
                    suggestionIcon = 'ðŸ“‰';
                } else if (mdNum <= -3) {
                    suggestion = 'Allenamento normale con focus recupero';
                    suggestionIcon = 'ðŸ’ª';
                } else if (mdNum === 1) {
                    suggestion = 'Recovery attivo - Defaticamento leggero';
                    suggestionIcon = 'ðŸ§˜';
                } else if (mdNum >= 2) {
                    suggestion = 'Ripresa graduale - Valuta fatica accumulata';
                    suggestionIcon = 'ðŸ“ˆ';
                }
            }

            if (suggestion) {
                html += `<div class="situation-suggestion">`;
                html += `<span class="suggestion-icon">${suggestionIcon}</span>`;
                html += `<span class="suggestion-text">${escapeHtml(suggestion)}</span>`;
                html += `</div>`;
            }

            // Current macrocycle phase
            const phaseToday = getMacroPhaseLabelForDate(athleteId, today);
            if (phaseToday) {
                html += `<div class="situation-row">`;
                html += `<span class="situation-label">Fase macro:</span>`;
                html += `<span class="situation-value situation-phase">${escapeHtml(phaseToday)}</span>`;
                html += `</div>`;
            }

            containerEl.innerHTML = html || '<p style="color:#888;">Nessun dato disponibile.</p>';
        }

        // Helper to format date for display
        function formatDateDisplay(d) {
            if (!d) return '';
            const days = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'];
            const months = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            return `${days[d.getDay()]} ${d.getDate()} ${months[d.getMonth()]} ${d.getFullYear()}`;
        }

        // ========== COACH ALERTS SYSTEM ==========
        // Proactive alerts that appear before generation
        const coachAlertsState = {
            alerts: [],
            decisions: []
        };

        function analyzePreGenerationAlerts(athleteId) {
            const alerts = [];
            if (!athleteId || !selectedAthlete) return alerts;

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Get active event from calendar
            const cal = getCalendarActive(athleteId);
            const activeEvent = getActiveEventFromCalendar(cal);

            if (activeEvent?.date) {
                const evDate = parseDateOnly(activeEvent.date);
                if (evDate) {
                    evDate.setHours(0, 0, 0, 0);
                    const diffDays = Math.round((evDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

                    // Alert: Match day!
                    if (diffDays === 0) {
                        alerts.push({
                            type: 'danger',
                            icon: 'fire',
                            title: 'OGGI Ãˆ GARA!',
                            text: `${activeEvent.name || 'Evento'} Ã¨ oggi. Solo attivazione leggera o riposo completo.`
                        });
                    }
                    // Alert: Tomorrow is match
                    else if (diffDays === 1) {
                        alerts.push({
                            type: 'danger',
                            icon: 'exclamation-triangle',
                            title: 'Domani gara!',
                            text: `MD-1 per ${activeEvent.name || 'evento'}. Evitare fatica, solo priming neuromuscolare.`
                        });
                    }
                    // Alert: 2 days before
                    else if (diffDays === 2) {
                        alerts.push({
                            type: 'warning',
                            icon: 'clock',
                            title: 'Gara tra 2 giorni',
                            text: `MD-2: deload moderato. Ridurre volume, mantenere intensitÃ  se necessario.`
                        });
                    }
                    // Alert: 3 days before
                    else if (diffDays === 3) {
                        alerts.push({
                            type: 'warning',
                            icon: 'calendar-day',
                            title: 'Gara tra 3 giorni',
                            text: `MD-3: iniziare taper. Ridurre volume del 30-40%.`
                        });
                    }
                    // Alert: Day after match
                    else if (diffDays === -1) {
                        alerts.push({
                            type: 'info',
                            icon: 'bed',
                            title: 'Post-gara (MD+1)',
                            text: `Recovery day dopo ${activeEvent.name || 'evento'}. Solo recupero attivo leggero.`
                        });
                    }
                }
            }

            // Check wearable data for fatigue
            if (latestWearableData) {
                const hrv = latestWearableData.hrv;
                const readiness = latestWearableData.readiness;
                const sleep = latestWearableData.sleep;

                if (readiness && readiness < 40) {
                    // Verifica se l'atleta Ã¨ fermo - in tal caso non serve deload
                    let daysSinceLastWorkout = 0;
                    if (window.PeriodizationEngine?.getDaysSinceLastWorkout) {
                        daysSinceLastWorkout = window.PeriodizationEngine.getDaysSinceLastWorkout([]);
                    }
                    
                    if (daysSinceLastWorkout >= 5 && daysSinceLastWorkout < 999) {
                        alerts.push({
                            type: 'warning',
                            icon: 'battery-quarter',
                            title: 'Readiness bassa dopo pausa',
                            text: `Readiness ${readiness}/100 dopo ${daysSinceLastWorkout} giorni di stop. Inizia con ripresa leggera.`
                        });
                    } else {
                        alerts.push({
                            type: 'danger',
                            icon: 'battery-quarter',
                            title: 'Readiness molto bassa',
                            text: `Readiness ${readiness}/100. Considerare deload o riposo.`
                        });
                    }
                } else if (readiness && readiness < 60) {
                    alerts.push({
                        type: 'warning',
                        icon: 'battery-half',
                        title: 'Readiness sotto media',
                        text: `Readiness ${readiness}/100. Ridurre intensitÃ  se possibile.`
                    });
                }

                if (sleep && sleep < 5) {
                    alerts.push({
                        type: 'warning',
                        icon: 'moon',
                        title: 'Sonno insufficiente',
                        text: `Solo ${sleep}h di sonno. Performance e recupero compromessi.`
                    });
                }

                if (hrv && hrv < 30) {
                    alerts.push({
                        type: 'danger',
                        icon: 'heartbeat',
                        title: 'HRV critico',
                        text: `HRV ${hrv}ms molto basso. Sistema nervoso sotto stress.`
                    });
                }
            }

            // Check recent workout history for overtraining OR inactivity
            if (aiProgramState?.history?.recent_workout_hashes?.length >= 5) {
                const recentCount = aiProgramState.history.recent_workout_hashes.length;
                
                // Calcola giorni dall'ultimo allenamento
                let daysSinceLastWorkout = 0;
                if (window.PeriodizationEngine?.getDaysSinceLastWorkout) {
                    daysSinceLastWorkout = window.PeriodizationEngine.getDaysSinceLastWorkout([]);
                }
                
                // Se atleta fermo da 5+ giorni: suggerisci ripresa graduale, NON deload
                if (daysSinceLastWorkout >= 5 && daysSinceLastWorkout < 999) {
                    alerts.push({
                        type: 'info',
                        icon: 'redo',
                        title: 'Ripresa dopo pausa',
                        text: `${daysSinceLastWorkout} giorni dall'ultimo allenamento. Sessione di ripresa graduale consigliata.`
                    });
                } else if (recentCount >= 10 && daysSinceLastWorkout < 5) {
                    // Solo se si sta allenando attivamente e ha alto volume
                    alerts.push({
                        type: 'info',
                        icon: 'chart-line',
                        title: 'Volume alto recente',
                        text: `${recentCount} workout nelle ultime settimane. Valuta necessitÃ  di deload.`
                    });
                }
            }

            return alerts;
        }

        function renderCoachAlerts(athleteId) {
            const panel = document.getElementById('coach-alerts-panel');
            const list = document.getElementById('coach-alerts-list');
            const count = document.getElementById('coach-alerts-count');
            if (!panel || !list) return;

            const alerts = analyzePreGenerationAlerts(athleteId);
            coachAlertsState.alerts = alerts;

            if (alerts.length === 0) {
                panel.classList.remove('has-alerts');
                return;
            }

            panel.classList.add('has-alerts');
            count.textContent = alerts.length;

            list.innerHTML = alerts.map(a => `
                <li class="coach-alert-item ${a.type}">
                    <i class="fas fa-${a.icon} coach-alert-icon ${a.type}"></i>
                    <div class="coach-alert-text">
                        <strong>${escapeHtml(a.title)}</strong><br>
                        ${escapeHtml(a.text)}
                    </div>
                </li>
            `).join('');
        }

        // ========== AI RELIABILITY SYSTEM ==========
        // Telemetria errori per tracciare fallimenti AI
        const aiTelemetry = {
            errors: [],
            successes: 0,
            failures: 0,
            lastError: null,
            sessionStart: Date.now(),
            // Enhanced metrics for dashboard
            responseTimesMs: [],
            modelStats: {},
            confidenceScores: [],
            retryCount: 0,
            cacheHits: 0
        };

        // Response cache for intelligent retry
        const aiResponseCache = new Map();
        const AI_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

        function getCacheKey(messages, model) {
            const msgHash = hashString(JSON.stringify(messages));
            return `${model}_${msgHash}`;
        }

        function getCachedResponse(messages, model) {
            const key = getCacheKey(messages, model);
            const cached = aiResponseCache.get(key);
            if (cached && (Date.now() - cached.ts < AI_CACHE_TTL_MS)) {
                aiTelemetry.cacheHits++;
                console.log('ðŸ“¦ AI Cache HIT');
                return cached.response;
            }
            return null;
        }

        function setCachedResponse(messages, model, response) {
            const key = getCacheKey(messages, model);
            aiResponseCache.set(key, { ts: Date.now(), response });
            // Limit cache size
            if (aiResponseCache.size > 50) {
                const oldest = aiResponseCache.keys().next().value;
                aiResponseCache.delete(oldest);
            }
        }

        function logAIError(stage, error, context = {}) {
            const entry = {
                ts: Date.now(),
                stage,
                error: String(error?.message || error),
                context: JSON.stringify(context).substring(0, 500),
                stack: error?.stack?.substring(0, 300) || null
            };
            aiTelemetry.errors.push(entry);
            aiTelemetry.failures++;
            aiTelemetry.lastError = entry;
            // Keep only last 50 errors
            if (aiTelemetry.errors.length > 50) aiTelemetry.errors.shift();
            console.error(`ðŸ”´ AI ERROR [${stage}]:`, error, context);
        }

        function logAISuccess(stage, meta = {}) {
            aiTelemetry.successes++;
            if (meta.responseTimeMs) {
                aiTelemetry.responseTimesMs.push(meta.responseTimeMs);
                if (aiTelemetry.responseTimesMs.length > 100) aiTelemetry.responseTimesMs.shift();
            }
            if (meta.model) {
                aiTelemetry.modelStats[meta.model] = aiTelemetry.modelStats[meta.model] || { calls: 0, successes: 0, totalMs: 0 };
                aiTelemetry.modelStats[meta.model].calls++;
                aiTelemetry.modelStats[meta.model].successes++;
                if (meta.responseTimeMs) aiTelemetry.modelStats[meta.model].totalMs += meta.responseTimeMs;
            }
            if (meta.confidence) {
                aiTelemetry.confidenceScores.push(meta.confidence);
                if (aiTelemetry.confidenceScores.length > 50) aiTelemetry.confidenceScores.shift();
            }
            console.log(`ðŸŸ¢ AI SUCCESS [${stage}]`, meta);
        }

        function getAIReliabilityScore() {
            const total = aiTelemetry.successes + aiTelemetry.failures;
            if (total === 0) return 100;
            return Math.round((aiTelemetry.successes / total) * 100);
        }

        function getAIMetricsSummary() {
            const total = aiTelemetry.successes + aiTelemetry.failures;
            const avgResponseTime = aiTelemetry.responseTimesMs.length > 0
                ? Math.round(aiTelemetry.responseTimesMs.reduce((a, b) => a + b, 0) / aiTelemetry.responseTimesMs.length)
                : 0;
            const avgConfidence = aiTelemetry.confidenceScores.length > 0
                ? Math.round(aiTelemetry.confidenceScores.reduce((a, b) => a + b, 0) / aiTelemetry.confidenceScores.length)
                : 100;
            
            return {
                reliability: getAIReliabilityScore(),
                totalCalls: total,
                successes: aiTelemetry.successes,
                failures: aiTelemetry.failures,
                avgResponseTimeMs: avgResponseTime,
                avgConfidence,
                cacheHits: aiTelemetry.cacheHits,
                retries: aiTelemetry.retryCount,
                modelStats: aiTelemetry.modelStats,
                recentErrors: aiTelemetry.errors.slice(-5),
                sessionDurationMin: Math.round((Date.now() - aiTelemetry.sessionStart) / 60000)
            };
        }

        // Confidence score per workout generato
        function calculateWorkoutConfidence(workout, context = {}) {
            let score = 100;
            const issues = [];

            const exercises = workout?.exercises || [];
            
            // PenalitÃ  per numero esercizi fuori range
            if (exercises.length < 5) {
                score -= 20;
                issues.push('Troppo pochi esercizi');
            }
            if (exercises.length > 10) {
                score -= 10;
                issues.push('Molti esercizi (durata?)');
            }

            // PenalitÃ  per esercizi senza nome valido
            const badNames = exercises.filter(e => !e.name || e.name.length < 3);
            if (badNames.length > 0) {
                score -= badNames.length * 10;
                issues.push(`${badNames.length} esercizi con nome invalido`);
            }

            // PenalitÃ  per sets/reps mancanti
            const badSets = exercises.filter(e => !e.sets || isNaN(parseInt(e.sets)));
            if (badSets.length > 0) {
                score -= badSets.length * 5;
                issues.push(`${badSets.length} esercizi senza sets validi`);
            }

            // PenalitÃ  per tipi invalidi
            const validTypes = new Set(['strength', 'hypertrophy', 'conditioning']);
            const badTypes = exercises.filter(e => !validTypes.has(e.type));
            if (badTypes.length > 0) {
                score -= badTypes.length * 5;
                issues.push(`${badTypes.length} esercizi con type invalido`);
            }

            // PenalitÃ  per duplicati
            const names = exercises.map(e => String(e.name || '').toLowerCase().trim());
            const uniqueNames = new Set(names);
            if (names.length > uniqueNames.size) {
                score -= (names.length - uniqueNames.size) * 10;
                issues.push('Esercizi duplicati');
            }

            // PenalitÃ  per assenza titolo
            if (!workout.title || workout.title.length < 5) {
                score -= 10;
                issues.push('Titolo mancante');
            }

            // PenalitÃ  per assenza coach_notes
            if (!workout.coach_notes) {
                score -= 5;
                issues.push('Nessuna nota coach');
            }

            // Bonus per coerenza con contesto
            if (context.phase) {
                const phaseKeywords = {
                    'Accumulo': ['volume', 'ipertrofia', 'hypertrophy'],
                    'Intensificazione': ['forza', 'strength', 'pesante'],
                    'Deload': ['leggero', 'recupero', 'mobilitÃ '],
                    'Peaking': ['esplosivo', 'potenza', 'velocitÃ ']
                };
                const keywords = phaseKeywords[context.phase] || [];
                const titleLower = (workout.title || '').toLowerCase();
                const notesLower = (workout.coach_notes || '').toLowerCase();
                const hasKeyword = keywords.some(k => titleLower.includes(k) || notesLower.includes(k));
                if (hasKeyword) {
                    score += 5;
                }
            }

            return {
                score: Math.max(0, Math.min(100, score)),
                level: score >= 80 ? 'high' : score >= 60 ? 'medium' : 'low',
                issues
            };
        }

        // Auto-fix esercizi con problemi comuni
        function autoFixExercises(exercises) {
            const fixes = [];
            
            return exercises.map((ex, idx) => {
                const fixed = { ...ex };
                const nameLower = String(ex.name || '').toLowerCase();
                
                // Fix 1: Sets mancanti o invalidi
                if (!fixed.sets || isNaN(parseInt(fixed.sets)) || parseInt(fixed.sets) < 1) {
                    fixed.sets = 3;
                    fixes.push(`[${idx}] sets â†’ 3 (default)`);
                }
                
                // Fix 2: Reps mancanti
                if (!fixed.reps || String(fixed.reps).trim() === '') {
                    if (nameLower.includes('plank') || nameLower.includes('hold')) {
                        fixed.reps = '30-45s';
                    } else if (nameLower.includes('cardio') || nameLower.includes('interval')) {
                        fixed.reps = '30s on/30s off';
                    } else {
                        fixed.reps = '8-12';
                    }
                    fixes.push(`[${idx}] reps â†’ ${fixed.reps}`);
                }
                
                // Fix 3: Type invalido
                const validTypes = new Set(['strength', 'hypertrophy', 'conditioning']);
                if (!validTypes.has(fixed.type)) {
                    // Infer type from name
                    if (nameLower.includes('squat') || nameLower.includes('deadlift') || nameLower.includes('bench') || nameLower.includes('press')) {
                        fixed.type = 'strength';
                    } else if (nameLower.includes('curl') || nameLower.includes('extension') || nameLower.includes('fly') || nameLower.includes('raise')) {
                        fixed.type = 'hypertrophy';
                    } else if (nameLower.includes('cardio') || nameLower.includes('plank') || nameLower.includes('interval') || nameLower.includes('mobility')) {
                        fixed.type = 'conditioning';
                    } else {
                        fixed.type = 'hypertrophy';
                    }
                    fixes.push(`[${idx}] type â†’ ${fixed.type}`);
                }
                
                // Fix 4: Rest mancante
                if (!fixed.rest || String(fixed.rest).trim() === '') {
                    if (fixed.type === 'strength') {
                        fixed.rest = '120s';
                    } else if (fixed.type === 'conditioning') {
                        fixed.rest = '30s';
                    } else {
                        fixed.rest = '60s';
                    }
                }
                
                // Fix 5: Nome troppo lungo (troncato)
                if (fixed.name && fixed.name.length > 100) {
                    fixed.name = fixed.name.substring(0, 97) + '...';
                    fixes.push(`[${idx}] nome troncato`);
                }
                
                // Fix 6: Sets eccessivi
                if (parseInt(fixed.sets) > 10) {
                    fixed.sets = 10;
                    fixes.push(`[${idx}] sets capped a 10`);
                }
                
                return fixed;
            });
        }

        // Sanity check finale prima di mostrare workout
        function sanityCheckWorkout(workout, phase) {
            const checks = [];
            const exercises = workout?.exercises || [];
            
            // Check 1: Almeno 4 esercizi
            if (exercises.length < 4) {
                checks.push({ level: 'error', msg: 'Meno di 4 esercizi - workout incompleto' });
            }
            
            // Check 2: Coerenza fase
            const phaseExpectations = {
                'Deload': { maxSets: 3, maxExercises: 6 },
                'Accumulo': { minSets: 3, minExercises: 5 },
                'Intensificazione': { minSets: 2, maxReps: 8 },
                'Peaking': { maxExercises: 6 }
            };
            
            const exp = phaseExpectations[phase];
            if (exp) {
                const avgSets = exercises.reduce((s, e) => s + (parseInt(e.sets) || 0), 0) / Math.max(1, exercises.length);
                
                if (exp.maxSets && avgSets > exp.maxSets + 1) {
                    checks.push({ level: 'warning', msg: `Fase ${phase}: sets medi (${avgSets.toFixed(1)}) alti per questa fase` });
                }
                if (exp.minSets && avgSets < exp.minSets - 1) {
                    checks.push({ level: 'warning', msg: `Fase ${phase}: sets medi (${avgSets.toFixed(1)}) bassi per questa fase` });
                }
                if (exp.maxExercises && exercises.length > exp.maxExercises) {
                    checks.push({ level: 'warning', msg: `Fase ${phase}: troppi esercizi (${exercises.length}) per questa fase` });
                }
            }
            
            // Check 3: VarietÃ  muscolare (almeno 2 pattern diversi)
            const patterns = new Set();
            for (const ex of exercises) {
                const name = String(ex.name || '').toLowerCase();
                if (name.includes('squat') || name.includes('lunge') || name.includes('leg')) patterns.add('legs');
                if (name.includes('bench') || name.includes('push') || name.includes('chest') || name.includes('dip')) patterns.add('push');
                if (name.includes('row') || name.includes('pull') || name.includes('back') || name.includes('lat')) patterns.add('pull');
                if (name.includes('deadlift') || name.includes('hinge') || name.includes('hip')) patterns.add('hinge');
                if (name.includes('core') || name.includes('plank') || name.includes('ab')) patterns.add('core');
                if (name.includes('shoulder') || name.includes('press') || name.includes('lateral')) patterns.add('shoulders');
            }
            
            if (patterns.size < 2) {
                checks.push({ level: 'warning', msg: 'Poca varietÃ  muscolare - considera piÃ¹ pattern di movimento' });
            }
            
            // Check 4: Equilibrio tipi
            const types = exercises.map(e => e.type);
            const typeCount = {};
            types.forEach(t => typeCount[t] = (typeCount[t] || 0) + 1);
            
            const strengthRatio = (typeCount.strength || 0) / exercises.length;
            const conditioningRatio = (typeCount.conditioning || 0) / exercises.length;
            
            if (phase !== 'Deload' && conditioningRatio > 0.5) {
                checks.push({ level: 'info', msg: 'Alto rapporto conditioning - verifica sia intenzionale' });
            }
            
            return checks;
        }

        // Mostra confidence badge nel UI
        function renderConfidenceBadge(confidence) {
            const colors = {
                high: 'var(--green)',
                medium: 'var(--orange)',
                low: 'var(--red)'
            };
            const icons = {
                high: 'check-circle',
                medium: 'exclamation-circle',
                low: 'times-circle'
            };
            
            return `<span class="confidence-badge" style="
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                background: ${colors[confidence.level]}20;
                color: ${colors[confidence.level]};
            ">
                <i class="fas fa-${icons[confidence.level]}"></i>
                ${confidence.score}%
            </span>`;
        }

        // ========== AI DECISION LOG ==========
        function addAIDecision(icon, text, reason) {
            coachAlertsState.decisions.push({ icon, text, reason, ts: Date.now() });
            renderAIDecisionLog();
            updateReliabilityBadge();
        }

        function clearAIDecisions() {
            coachAlertsState.decisions = [];
            renderAIDecisionLog();
        }

        function renderAIDecisionLog() {
            const log = document.getElementById('ai-decision-log');
            const list = document.getElementById('ai-decision-list');
            if (!log || !list) return;

            const decisions = coachAlertsState.decisions;
            if (decisions.length === 0) {
                log.classList.remove('visible');
                return;
            }

            log.classList.add('visible');
            list.innerHTML = decisions.slice(-15).map(d => `
                <li class="ai-decision-item">
                    <i class="fas fa-${d.icon} ai-decision-icon"></i>
                    <div class="ai-decision-text">
                        ${escapeHtml(d.text)}
                        ${d.reason ? `<br><span class="ai-decision-reason">â†’ ${escapeHtml(d.reason)}</span>` : ''}
                    </div>
                </li>
            `).join('');
        }

        function toggleAIDecisionLog() {
            const log = document.getElementById('ai-decision-log');
            if (log) log.classList.toggle('expanded');
        }

        function updateReliabilityBadge() {
            const badge = document.getElementById('ai-reliability-badge');
            if (!badge) return;
            
            const score = getAIReliabilityScore();
            const total = aiTelemetry.successes + aiTelemetry.failures;
            
            if (total < 1) {
                badge.style.display = 'none';
                return;
            }
            
            badge.style.display = 'inline-flex';
            const color = score >= 90 ? 'var(--green)' : score >= 70 ? 'var(--orange)' : 'var(--red)';
            const icon = score >= 90 ? 'check-circle' : score >= 70 ? 'exclamation-circle' : 'times-circle';
            
            badge.innerHTML = `<i class="fas fa-${icon}" style="color:${color};margin-right:4px;"></i><span style="color:${color};font-size:10px;font-weight:600;">${score}%</span>`;
        }

        // ========== ðŸ§  RATIONALE ENGINE UI ==========
        function displayRationaleCard(rationaleUI) {
            if (!rationaleUI) return;
            
            // Create or update rationale card in conversation panel
            let rationaleCard = document.getElementById('rationale-card');
            if (!rationaleCard) {
                rationaleCard = document.createElement('div');
                rationaleCard.id = 'rationale-card';
                rationaleCard.className = 'rationale-card';
                
                // Insert at top of messages
                const messages = document.getElementById('messages');
                if (messages) {
                    messages.insertBefore(rationaleCard, messages.firstChild);
                }
            }
            
            const summary = rationaleUI.summary || {};
            const emoji = summary.emoji || 'ðŸ§ ';
            const decision = summary.decision || 'Sessione standard';
            const confidence = summary.confidence || 80;
            
            const keyFactors = rationaleUI.keyFactors || [];
            const modifications = rationaleUI.modifications || [];
            const explanation = rationaleUI.explanation || '';
            const alternatives = rationaleUI.alternatives || [];
            const monitoring = rationaleUI.monitoring || [];
            
            const confidenceColor = confidence >= 85 ? 'var(--green)' : confidence >= 70 ? 'var(--orange)' : 'var(--gray-400)';
            
            rationaleCard.innerHTML = `
                <div class="rationale-header">
                    <div class="rationale-title">
                        <span class="rationale-emoji">${emoji}</span>
                        <span class="rationale-decision">${decision}</span>
                        <span class="rationale-confidence" style="background: ${confidenceColor}20; color: ${confidenceColor};">
                            ${confidence}% confidenza
                        </span>
                    </div>
                    <button class="rationale-expand-btn" onclick="toggleRationaleDetails()">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
                
                ${keyFactors.length > 0 ? `
                <div class="rationale-factors">
                    ${keyFactors.map(f => `
                        <span class="rationale-factor ${f.priority}">
                            <span class="factor-icon">${f.icon}</span>
                            ${f.text}
                        </span>
                    `).join('')}
                </div>
                ` : ''}
                
                <div class="rationale-details" id="rationale-details">
                    ${explanation ? `
                    <div class="rationale-section">
                        <div class="rationale-section-title">ðŸ’¬ PerchÃ© questa decisione</div>
                        <p class="rationale-explanation">${explanation}</p>
                    </div>
                    ` : ''}
                    
                    ${modifications.length > 0 ? `
                    <div class="rationale-section">
                        <div class="rationale-section-title">âš¡ Modifiche applicate</div>
                        <ul class="rationale-list">
                            ${modifications.map(m => `<li>${m.icon || 'â€¢'} ${m.text}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    ${alternatives.length > 0 ? `
                    <div class="rationale-section">
                        <div class="rationale-section-title">ðŸ”„ Alternative scartate</div>
                        <ul class="rationale-list alternatives">
                            ${alternatives.map(a => `<li><strong>${a.name}</strong>: ${a.reason}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    ${monitoring.length > 0 ? `
                    <div class="rationale-section">
                        <div class="rationale-section-title">ðŸ‘ï¸ Cosa monitorare</div>
                        <ul class="rationale-list monitoring">
                            ${monitoring.map(m => `<li>â€¢ ${m}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                </div>
            `;
            
            console.log('ðŸ§  Rationale card displayed');
        }
        
        function toggleRationaleDetails() {
            const details = document.getElementById('rationale-details');
            const btn = document.querySelector('.rationale-expand-btn i');
            if (details && btn) {
                details.classList.toggle('expanded');
                btn.classList.toggle('fa-chevron-down');
                btn.classList.toggle('fa-chevron-up');
            }
        }

        // ========== 110/100 READINESS CHECK INTEGRATION ==========
        function openReadinessCheck() {
            if (!window.QuickReadinessCheck) {
                console.error('QuickReadinessCheck module not loaded');
                showNotification('Modulo readiness non disponibile', 'error');
                return;
            }
            if (!selectedAthlete?.id) {
                showNotification('Seleziona prima un atleta', 'error');
                return;
            }
            
            window.QuickReadinessCheck.open(selectedAthlete.id, 'standard')
                .then(result => {
                    if (result) {
                        // Show readiness badge
                        const badge = document.getElementById('readiness-badge');
                        if (badge) {
                            const score = result.scores.overall;
                            badge.style.display = 'inline-block';
                            badge.textContent = `ðŸŽ¯ Readiness: ${score}%`;
                            badge.style.background = score >= 75 ? 'var(--green)' : score >= 50 ? 'var(--orange)' : 'var(--red)';
                        }
                        
                        // Add AI message
                        const modifiers = result.modifiers;
                        let msg = `<strong>Readiness Check completato</strong>: ${result.scores.overall}%<br>`;
                        if (modifiers.volumeModifier !== 1) msg += `ðŸ“Š Volume: ${modifiers.volumeModifier > 1 ? '+' : ''}${Math.round((modifiers.volumeModifier-1)*100)}%<br>`;
                        if (modifiers.intensityModifier !== 1) msg += `ðŸ’ª IntensitÃ : ${modifiers.intensityModifier > 1 ? '+' : ''}${Math.round((modifiers.intensityModifier-1)*100)}%<br>`;
                        if (modifiers.avoidAreas.length) msg += `ðŸš« Evita: ${modifiers.avoidAreas.join(', ')}<br>`;
                        if (modifiers.notes.length) msg += `ðŸ“ ${modifiers.notes.join(' | ')}`;
                        
                        addAIMessage('recovery', msg, 'high');
                        
                        showNotification('Readiness check salvato - verrÃ  usato nella generazione', 'success');
                    }
                })
                .catch(err => {
                    console.error('Readiness check error:', err);
                });
        }

        // Get current readiness for AI context
        function getCurrentReadinessContext() {
            if (!window.QuickReadinessCheck || !selectedAthlete?.id) return null;
            return window.QuickReadinessCheck.getLastCheck(selectedAthlete.id);
        }

        // ========== 110/100 RECOVERY PRESCRIPTION UI ==========
        function showRecoveryPrescription() {
            if (!window.RecoveryPrescriptor || !selectedAthlete?.id) return;
            
            try {
                const context = {
                    athleteId: selectedAthlete.id,
                    fatigue: latestWearableData?.readiness ? (100 - latestWearableData.readiness) : 50,
                    soreness: aiProgramState?.anamnesis?.injuries?.map(i => i.area) || [],
                    stress: aiProgramState?.telemetry?.stress_level || 5,
                    sleep: latestWearableData?.sleep || 7,
                    readiness: latestWearableData?.readiness || 70,
                    phase: currentPhase
                };
                
                const prescription = window.RecoveryPrescriptor.prescribe(context);
                const quickRec = window.RecoveryPrescriptor.getQuickRecommendation(context);
                
                const panel = document.getElementById('recovery-prescription-panel');
                const summary = document.getElementById('recovery-quick-summary');
                const details = document.getElementById('recovery-full-prescription');
                
                if (panel && summary && quickRec) {
                    panel.style.display = 'block';
                    
                    // Quick summary - usa icon, title, text dal quickRec
                    summary.innerHTML = `
                        <div style="display:flex;align-items:center;gap:6px;margin-bottom:6px;">
                            <span style="font-size:16px;">${quickRec.icon || 'ðŸ’†'}</span>
                            <strong style="color:var(--white);">${quickRec.title || 'Recupero'}</strong>
                        </div>
                        <div style="color:${quickRec.color || 'var(--gray-300)'}">${quickRec.text || ''}</div>
                    `;
                    
                    // Full details - usa prescription.prescription (l'array di strategie)
                    if (details && prescription && prescription.prescription) {
                        const priorityStrats = prescription.prescription.slice(0, 3);
                        const urgency = prescription.urgency;
                        const notes = Array.isArray(prescription.notes) 
                            ? prescription.notes.map(n => n.text || n).join(' | ')
                            : (prescription.notes || '');
                        
                        details.innerHTML = `
                            <div style="margin-bottom:10px;">
                                <strong style="color:var(--purple);font-size:11px;text-transform:uppercase;">Strategie Prioritarie (${prescription.protocolName || 'Standard'})</strong>
                                ${priorityStrats.map(s => `
                                    <div style="margin-top:6px;padding:6px 8px;background:rgba(255,255,255,0.05);border-radius:6px;">
                                        <span style="font-size:14px;">ðŸ’«</span>
                                        <strong style="color:var(--white);font-size:12px;">${s.name || 'Strategia'}</strong>
                                        <div style="font-size:11px;color:var(--gray-400);margin-top:2px;">${s.duration || ''} - ${s.description || ''}</div>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="font-size:11px;color:var(--gray-500);">
                                âš¡ Urgenza: ${urgency || 'normal'} | â° Prossimo check: ${prescription.nextCheckIn || '48h'}
                            </div>
                            ${notes ? `<div style="margin-top:8px;font-size:11px;color:var(--orange);">âš ï¸ ${notes}</div>` : ''}
                        `;
                    }
                }
            } catch (e) {
                console.warn('Failed to show recovery prescription:', e);
            }
        }
        
        function toggleRecoveryDetails() {
            const details = document.getElementById('recovery-details');
            const icon = document.getElementById('recovery-toggle-icon');
            if (details && icon) {
                const isOpen = details.style.display !== 'none';
                details.style.display = isOpen ? 'none' : 'block';
                icon.className = isOpen ? 'fas fa-chevron-down' : 'fas fa-chevron-up';
            }
        }
        
        function hideRecoveryPrescription() {
            const panel = document.getElementById('recovery-prescription-panel');
            if (panel) panel.style.display = 'none';
        }

        // ========== AI METRICS DASHBOARD ==========
        function openAIMetricsDashboard() {
            const overlay = document.getElementById('ai-metrics-overlay');
            if (overlay) {
                overlay.classList.add('open');
                renderAIMetricsDashboard();
            }
        }

        function closeAIMetricsDashboard() {
            const overlay = document.getElementById('ai-metrics-overlay');
            if (overlay) overlay.classList.remove('open');
        }

        function renderAIMetricsDashboard() {
            const metrics = getAIMetricsSummary();
            
            // Main metrics grid
            const grid = document.getElementById('ai-metrics-grid');
            if (grid) {
                const reliabilityColor = metrics.reliability >= 90 ? 'green' : metrics.reliability >= 70 ? 'orange' : 'red';
                const confidenceColor = metrics.avgConfidence >= 80 ? 'green' : metrics.avgConfidence >= 60 ? 'orange' : 'red';
                
                grid.innerHTML = `
                    <div class="ai-metric-card">
                        <div class="ai-metric-value ${reliabilityColor}">${metrics.reliability}%</div>
                        <div class="ai-metric-label">AffidabilitÃ </div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value">${metrics.totalCalls}</div>
                        <div class="ai-metric-label">Chiamate Totali</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value green">${metrics.successes}</div>
                        <div class="ai-metric-label">Successi</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value red">${metrics.failures}</div>
                        <div class="ai-metric-label">Fallimenti</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value purple">${metrics.avgResponseTimeMs}ms</div>
                        <div class="ai-metric-label">Tempo Medio Risposta</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value ${confidenceColor}">${metrics.avgConfidence}%</div>
                        <div class="ai-metric-label">Confidence Media</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value">${metrics.cacheHits}</div>
                        <div class="ai-metric-label">Cache Hits</div>
                    </div>
                    <div class="ai-metric-card">
                        <div class="ai-metric-value orange">${metrics.retries}</div>
                        <div class="ai-metric-label">Retry Totali</div>
                    </div>
                `;
            }
            
            // Model stats table
            const modelsBody = document.getElementById('ai-metrics-models-body');
            if (modelsBody) {
                const modelEntries = Object.entries(metrics.modelStats);
                if (modelEntries.length === 0) {
                    modelsBody.innerHTML = '<tr><td colspan="4" style="color:var(--gray-500);text-align:center;">Nessun dato ancora</td></tr>';
                } else {
                    modelsBody.innerHTML = modelEntries.map(([model, stats]) => {
                        const avgTime = stats.calls > 0 ? Math.round(stats.totalMs / stats.calls) : 0;
                        const successRate = stats.calls > 0 ? Math.round((stats.successes / stats.calls) * 100) : 0;
                        return `
                            <tr>
                                <td><strong>${escapeHtml(model)}</strong></td>
                                <td>${stats.calls}</td>
                                <td>${stats.successes} (${successRate}%)</td>
                                <td>${avgTime}ms</td>
                            </tr>
                        `;
                    }).join('');
                }
            }
            
            // Recent errors
            const errorsContainer = document.getElementById('ai-metrics-errors');
            if (errorsContainer) {
                if (metrics.recentErrors.length === 0) {
                    errorsContainer.innerHTML = '<p style="color:var(--gray-500);font-size:12px;">Nessun errore recente ðŸŽ‰</p>';
                } else {
                    errorsContainer.innerHTML = metrics.recentErrors.map(err => {
                        const timeAgo = Math.round((Date.now() - err.ts) / 60000);
                        return `
                            <div class="ai-metrics-error-item">
                                <div class="ai-metrics-error-stage">[${escapeHtml(err.stage)}]</div>
                                <div class="ai-metrics-error-msg">${escapeHtml(err.error)}</div>
                                <div class="ai-metrics-error-time">${timeAgo} min fa</div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }

        // ========== AI TEST SUITE ==========
        const aiTestCases = [
            { name: 'Accumulo - Palestra', sport: 'palestra', phase: 'Accumulo', week: 2 },
            { name: 'Intensificazione - Boxe', sport: 'boxe', phase: 'Intensificazione', week: 4 },
            { name: 'Deload - Calcio', sport: 'calcio', phase: 'Deload', week: 4 },
            { name: 'Peaking - MMA', sport: 'mma', phase: 'Peaking', week: 7 },
            { name: 'Accumulo - Basket', sport: 'basket', phase: 'Accumulo', week: 1 },
            { name: 'Intensificazione - Palestra', sport: 'palestra', phase: 'Intensificazione', week: 5 },
            { name: 'Adattamento - Principiante', sport: 'palestra', phase: 'Adattamento', week: 1, experience: 'beginner' },
            { name: 'Match Day - Calcio', sport: 'calcio', phase: 'Deload', week: 8, matchDay: true }
        ];

        let aiTestRunning = false;

        async function runAITestSuite() {
            if (aiTestRunning) return;
            aiTestRunning = true;
            
            const btn = document.getElementById('ai-run-tests-btn');
            const results = document.getElementById('ai-test-results');
            const progress = document.getElementById('ai-test-progress-bar');
            const output = document.getElementById('ai-test-output');
            
            if (btn) btn.disabled = true;
            if (results) results.classList.add('visible');
            if (output) output.innerHTML = '<p>Avvio test suite...</p>';
            if (progress) progress.style.width = '0%';
            
            const testResults = [];
            const total = aiTestCases.length;
            
            for (let i = 0; i < total; i++) {
                const tc = aiTestCases[i];
                const pct = Math.round(((i + 1) / total) * 100);
                if (progress) progress.style.width = `${pct}%`;
                
                try {
                    const result = await runSingleAITest(tc);
                    testResults.push({ ...tc, ...result });
                } catch (e) {
                    testResults.push({ ...tc, passed: false, error: e.message });
                }
                
                // Update output
                if (output) {
                    const passCount = testResults.filter(r => r.passed).length;
                    const failCount = testResults.filter(r => !r.passed).length;
                    output.innerHTML = `
                        <p style="margin-bottom:8px;"><strong>Progresso:</strong> ${i + 1}/${total}</p>
                        <p style="color:var(--green);">âœ… Passati: ${passCount}</p>
                        <p style="color:var(--red);">âŒ Falliti: ${failCount}</p>
                        <div style="margin-top:12px;max-height:200px;overflow-y:auto;">
                            ${testResults.map(r => `
                                <div style="padding:6px 0;border-bottom:1px solid var(--gray-700);font-size:11px;">
                                    ${r.passed ? 'âœ…' : 'âŒ'} <strong>${escapeHtml(r.name)}</strong>
                                    ${r.confidence ? ` - ${r.confidence}%` : ''}
                                    ${r.error ? ` - <span style="color:var(--red);">${escapeHtml(r.error)}</span>` : ''}
                                    ${r.warnings?.length ? ` - <span style="color:var(--orange);">${r.warnings.length} warning</span>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                // Small delay between tests
                await new Promise(r => setTimeout(r, 500));
            }
            
            aiTestRunning = false;
            if (btn) btn.disabled = false;
            
            // Final summary
            const passCount = testResults.filter(r => r.passed).length;
            const avgConfidence = testResults.filter(r => r.confidence).reduce((a, r) => a + r.confidence, 0) / Math.max(1, testResults.filter(r => r.confidence).length);
            
            addAIDecision('flask', `Test suite completata: ${passCount}/${total}`, `Confidence media: ${Math.round(avgConfidence)}%`);
        }

        async function runSingleAITest(testCase) {
            // Create a minimal test prompt
            const prompt = [
                `Genera un singolo workout per fase ${testCase.phase}, sport ${testCase.sport}.`,
                'Output SOLO JSON valido.',
                '{"title":"...","exercises":[{"name":"...","sets":3,"reps":"8-10","type":"strength"}],"coach_notes":"..."}'
            ].join('\n');
            
            try {
                const { content } = await groqChat({
                    model: GROQ_MODELS.fast,
                    messages: [
                        { role: 'system', content: 'Sei un preparatore atletico. Rispondi SOLO con JSON valido.' },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3,
                    max_tokens: 600,
                    useCache: false
                });
                
                // Try to parse
                const obj = parseAiJsonOrThrow(content, 'Test');
                
                // Validate
                const validation = validateWorkoutDraft(obj);
                const confidence = calculateWorkoutConfidence(obj, { phase: testCase.phase });
                
                return {
                    passed: validation.errors.length === 0,
                    warnings: validation.warnings,
                    confidence: confidence.score,
                    exerciseCount: obj.exercises?.length || 0
                };
            } catch (e) {
                return {
                    passed: false,
                    error: e.message
                };
            }
        }

        // ========== PRE-GENERATION VALIDATION ==========
        function validatePreGeneration(athleteId) {
            const warnings = [];
            const blocks = [];

            if (!athleteId || !selectedAthlete) {
                blocks.push('Nessun atleta selezionato');
                return { valid: false, warnings, blocks };
            }

            // Check if today is match day
            const cal = getCalendarActive(athleteId);
            const activeEvent = getActiveEventFromCalendar(cal);
            if (activeEvent?.date) {
                const evDate = parseDateOnly(activeEvent.date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                if (evDate) {
                    evDate.setHours(0, 0, 0, 0);
                    if (evDate.getTime() === today.getTime()) {
                        warnings.push('Oggi Ã¨ giorno di gara - confermando genererai solo attivazione leggera');
                    }
                }
            }

            // Check severe readiness
            if (latestWearableData?.readiness && latestWearableData.readiness < 30) {
                warnings.push(`Readiness critica (${latestWearableData.readiness}/100) - workout sarÃ  adattato al recupero`);
            }

            return { valid: blocks.length === 0, warnings, blocks };
        }

        function renderCalendarOverlay(athleteId) {
            const overlay = document.getElementById('calendar-overlay');
            if (!overlay) return;
            if (!isCalendarOverlayOpen()) return;

            const labelEl = document.getElementById('calendar-month-label');
            const gridEl = document.getElementById('calendar-month-grid');
            const selectedEl = document.getElementById('calendar-overlay-selected');
            const listEl = document.getElementById('calendar-overlay-events-list');
            const situationEl = document.getElementById('cal-situation-content');
            if (!gridEl || !listEl) return;

            const anchor = calendarOverlayState.monthAnchor instanceof Date && !Number.isNaN(calendarOverlayState.monthAnchor.getTime())
                ? calendarOverlayState.monthAnchor
                : new Date(new Date().getFullYear(), new Date().getMonth(), 1);

            if (labelEl) labelEl.textContent = formatMonthLabel(anchor);

            const cal = getCalendarActive(athleteId);
            const events = Array.isArray(cal?.events) ? cal.events : [];
            const eventsByDate = groupEventsByDate(events);

            // Get active event for MD calculation
            const activeEvent = getActiveEventFromCalendar(cal);
            const activeEventDate = activeEvent?.date ? parseDateOnly(activeEvent.date) : null;

            // Render situation panel
            renderSituationPanel(athleteId, activeEvent, situationEl);

            // Month grid: 6 weeks x 7 days
            const gridStart = startOfMonthGridMonday(anchor);
            const monthIndex = anchor.getMonth();
            const selectedIso = calendarOverlayState.selectedDate ? String(calendarOverlayState.selectedDate) : '';

            const cells = [];
            const trainingDays = calendarOverlayState.trainingDays || [];
            const workoutDates = calendarOverlayState.workoutDates || {};

            for (let i = 0; i < 42; i++) {
                const day = addDays(gridStart, i);
                const iso = dateToIso(day);
                const inMonth = day.getMonth() === monthIndex;
                const isSelected = selectedIso && iso === selectedIso;
                const dayEvents = eventsByDate[iso] || [];

                // Training day (recurring from schedule)
                const dowIdx = getDayOfWeekIndex(day);
                const isTrainingDay = trainingDays.includes(dowIdx);

                // Workout completed/assigned on this date
                const dayWorkouts = workoutDates[iso] || [];
                const hasWorkout = dayWorkouts.length > 0;
                const hasCompleted = dayWorkouts.some(w => w.status === 'completed');

                const phaseLabel = getMacroPhaseLabelForDate(athleteId, day);

                // Calculate MD for this day relative to active event
                const mdLabel = computeMdLabelForDay(day, activeEventDate);

                // Dots for events (match/fight/other)
                const eventDots = dayEvents
                    .slice(0, 3)
                    .map(ev => {
                        const t = String(ev?.type || 'match');
                        const cls = (t === 'fight' || t === 'other' || t === 'match') ? t : 'match';
                        return `<span class="cal-dot ${cls}" title="${escapeHtml(String(ev?.name || 'Evento'))}"></span>`;
                    })
                    .join('');

                // Dot for workout if any
                const workoutDot = hasWorkout
                    ? `<span class="cal-dot workout" title="${hasCompleted ? 'Sessione completata' : 'Workout assegnato'}"></span>`
                    : '';

                // Extra classes
                const extraClasses = [
                    inMonth ? '' : 'other-month',
                    isSelected ? 'selected' : '',
                    isTrainingDay ? 'training-day' : '',
                    hasCompleted ? 'has-workout' : ''
                ].filter(Boolean).join(' ');

                // Icons row
                let icons = '';
                if (isTrainingDay || hasWorkout || dayEvents.length) {
                    const parts = [];
                    if (isTrainingDay) parts.push('<i class="fas fa-dumbbell icon-training" title="Giorno allenamento"></i>');
                    if (hasCompleted) parts.push('<i class="fas fa-check-circle icon-workout" title="Completato"></i>');
                    else if (hasWorkout) parts.push('<i class="fas fa-clock icon-workout" title="Workout assegnato"></i>');
                    if (dayEvents.some(e => e.type === 'match')) parts.push('<i class="fas fa-futbol icon-match" title="Partita/Gara"></i>');
                    if (dayEvents.some(e => e.type === 'fight')) parts.push('<i class="fas fa-fist-raised icon-fight" title="Match"></i>');
                    icons = `<div class="cal-day-icons">${parts.join('')}</div>`;
                }

                // MD badge (only show within Â±3 days of event)
                let mdBadge = '';
                if (mdLabel && /^md[+-]?[0-3]$/i.test(mdLabel)) {
                    const mdClass = mdLabel.replace('+', '').replace('-', '-');
                    mdBadge = `<span class="cal-md-badge ${mdClass}">${mdLabel.toUpperCase()}</span>`;
                }

                cells.push(
                    `<div class="cal-day ${extraClasses}" data-cal-day="${escapeHtml(iso)}">` +
                    `  <div>` +
                    `    <div class="cal-day-top">` +
                    `      <div class="cal-day-number">${day.getDate()}</div>` +
                    `      <div class="cal-event-dots">${eventDots}${workoutDot}</div>` +
                    `    </div>` +
                    `    ${icons}` +
                    `    ${mdBadge}` +
                    `    <div class="cal-day-phase">${escapeHtml(phaseLabel || '')}</div>` +
                    `  </div>` +
                    `</div>`
                );
            }
            gridEl.innerHTML = cells.join('');

            gridEl.querySelectorAll('[data-cal-day]').forEach(el => {
                el.addEventListener('click', () => {
                    const iso = el.getAttribute('data-cal-day');
                    calendarOverlayState.selectedDate = iso ? String(iso) : null;
                    const ovDateEl = document.getElementById('calendar-overlay-event-date');
                    if (ovDateEl && calendarOverlayState.selectedDate) ovDateEl.value = calendarOverlayState.selectedDate;
                    renderCalendarOverlay(athleteId);
                });
            });

            if (selectedEl) {
                selectedEl.textContent = selectedIso
                    ? `Giorno selezionato: ${selectedIso}`
                    : 'Seleziona un giorno per pre-compilare la data.';
            }

            // Events list (all events)
            const activeId = cal?.active_event_id ? String(cal.active_event_id) : null;
            if (!events.length) {
                listEl.innerHTML = '<div class="next-event-hint">Nessun evento in calendario.</div>';
                return;
            }

            listEl.innerHTML = events.map(e => {
                const isActive = activeId && String(e.id) === String(activeId);
                const typeLabel = e.type === 'fight' ? 'Fight' : e.type === 'other' ? 'Altro' : 'Match';
                const md0Label = String(e.md0_mode || 'off') === 'primer' ? 'MD0: primer' : 'MD0: off';
                return `
                    <div class="calendar-item ${isActive ? 'active' : ''}">
                        <div class="calendar-item-left">
                            <div class="calendar-item-title">${escapeHtml(String(e.name || 'Evento'))}</div>
                            <div class="calendar-item-sub">${escapeHtml(String(e.date || 'N/A'))}</div>
                        </div>
                        <div class="calendar-item-actions">
                            <span class="calendar-pill">${typeLabel}</span>
                            <span class="calendar-pill">${md0Label}</span>
                            <button class="next-event-btn" type="button" data-ov-set="${escapeHtml(String(e.id))}">Usa</button>
                            <button class="next-event-btn" type="button" data-ov-del="${escapeHtml(String(e.id))}">Rimuovi</button>
                        </div>
                    </div>
                `;
            }).join('');

            listEl.querySelectorAll('[data-ov-set]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const id = btn.getAttribute('data-ov-set');
                    const cal2 = getCalendarActive(selectedAthlete.id);
                    const out = { ...(cal2 || {}), active_event_id: id };
                    setCalendarActive(selectedAthlete.id, out);
                    syncNextEventUI(selectedAthlete.id);
                    renderCalendarOverlay(selectedAthlete.id);
                });
            });
            listEl.querySelectorAll('[data-ov-del]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!selectedAthlete?.id) return;
                    const id = btn.getAttribute('data-ov-del');
                    const cal2 = getCalendarActive(selectedAthlete.id);
                    const out = removeEventFromCalendar(cal2, id);
                    setCalendarActive(selectedAthlete.id, out);
                    syncNextEventUI(selectedAthlete.id);
                    renderCalendarOverlay(selectedAthlete.id);
                });
            });
        }

        function humanizeKey(key) {
            const s = String(key || '').replace(/_/g, ' ').trim();
            if (!s) return 'Evento';
            return s.charAt(0).toUpperCase() + s.slice(1);
        }

        function isIsoDateString(v) {
            return /^\d{4}-\d{2}-\d{2}$/.test(String(v || '').trim());
        }

        function parseDateFlexibleToDate(input) {
            const raw = String(input || '').trim();
            if (!raw) return null;

            // 1) YYYY-MM-DD
            if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
                const [y, m, d] = raw.split('-').map(n => parseInt(n, 10));
                const dt = new Date(y, m - 1, d);
                return Number.isFinite(dt.getTime()) ? dt : null;
            }

            // 2) DD/MM/YYYY or DD-MM-YYYY
            const dmy = raw.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
            if (dmy) {
                const d = parseInt(dmy[1], 10);
                const m = parseInt(dmy[2], 10);
                const y = parseInt(dmy[3], 10);
                const dt = new Date(y, m - 1, d);
                return Number.isFinite(dt.getTime()) ? dt : null;
            }

            // 3) YYYY/MM/DD
            const ymd = raw.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
            if (ymd) {
                const y = parseInt(ymd[1], 10);
                const m = parseInt(ymd[2], 10);
                const d = parseInt(ymd[3], 10);
                const dt = new Date(y, m - 1, d);
                return Number.isFinite(dt.getTime()) ? dt : null;
            }

            // 4) "19 dicembre 2025" / "19 dic 2025"
            const it = raw
                .toLowerCase()
                .replace(/\s+/g, ' ')
                .replace(/\./g, '')
                .trim();
            const itMatch = it.match(/^(\d{1,2})\s+([a-zÃ Ã¨Ã©Ã¬Ã²Ã¹]+)\s+(\d{4})$/i);
            if (itMatch) {
                const d = parseInt(itMatch[1], 10);
                const monthName = String(itMatch[2] || '').toLowerCase();
                const y = parseInt(itMatch[3], 10);
                const monthMap = {
                    gennaio: 1, gen: 1,
                    febbraio: 2, feb: 2,
                    marzo: 3, mar: 3,
                    aprile: 4, apr: 4,
                    maggio: 5, mag: 5,
                    giugno: 6, giu: 6,
                    luglio: 7, lug: 7,
                    agosto: 8, ago: 8,
                    settembre: 9, set: 9,
                    ottobre: 10, ott: 10,
                    novembre: 11, nov: 11,
                    dicembre: 12, dic: 12
                };
                const m = monthMap[monthName];
                if (m) {
                    const dt = new Date(y, m - 1, d);
                    return Number.isFinite(dt.getTime()) ? dt : null;
                }
            }

            // 5) "20 dicembre" / "20 dic" (anno implicito: se giÃ  passato -> anno prossimo)
            const itNoYear = it.match(/^(\d{1,2})\s+([a-zÃ Ã¨Ã©Ã¬Ã²Ã¹]+)$/i);
            if (itNoYear) {
                const d = parseInt(itNoYear[1], 10);
                const monthName = String(itNoYear[2] || '').toLowerCase();
                const monthMap = {
                    gennaio: 1, gen: 1,
                    febbraio: 2, feb: 2,
                    marzo: 3, mar: 3,
                    aprile: 4, apr: 4,
                    maggio: 5, mag: 5,
                    giugno: 6, giu: 6,
                    luglio: 7, lug: 7,
                    agosto: 8, ago: 8,
                    settembre: 9, set: 9,
                    ottobre: 10, ott: 10,
                    novembre: 11, nov: 11,
                    dicembre: 12, dic: 12
                };
                const m = monthMap[monthName];
                if (m) {
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    let y = today.getFullYear();
                    let dt = new Date(y, m - 1, d);
                    if (dt < today) {
                        y = y + 1;
                        dt = new Date(y, m - 1, d);
                    }
                    return Number.isFinite(dt.getTime()) ? dt : null;
                }
            }

            // 6) "20/12" or "20-12" (anno implicito: se giÃ  passato -> anno prossimo)
            const dmNoYear = raw.match(/^(\d{1,2})[\/\-](\d{1,2})$/);
            if (dmNoYear) {
                const d = parseInt(dmNoYear[1], 10);
                const m = parseInt(dmNoYear[2], 10);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                let y = today.getFullYear();
                let dt = new Date(y, m - 1, d);
                if (dt < today) {
                    y = y + 1;
                    dt = new Date(y, m - 1, d);
                }
                return Number.isFinite(dt.getTime()) ? dt : null;
            }

            return null;
        }

        function normalizeDateToIso(input) {
            const dt = parseDateFlexibleToDate(input);
            if (!dt) return null;
            const y = dt.getFullYear();
            const m = String(dt.getMonth() + 1).padStart(2, '0');
            const d = String(dt.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        function extractEventCandidatesFromObject(obj, { athleteSport = '', path = '' } = {}) {
            const out = [];
            const sportKey = String(athleteSport || '').toLowerCase();
            const defaultType = sportKey === 'boxe' ? 'fight' : 'match';

            const walk = (value, keyPath) => {
                if (!value) return;
                if (typeof value === 'string') {
                    const s = value.trim();
                    if (!s) return;
                    const iso = normalizeDateToIso(s);
                    if (iso && /(match|fight|gara|partita|evento|competition|target|date|data)/.test(keyPath)) {
                        out.push({ type: defaultType, name: humanizeKey(keyPath.split('.').pop()), date: iso });
                    }
                    return;
                }
                if (Array.isArray(value)) {
                    value.forEach((v, idx) => walk(v, `${keyPath}.${idx}`));
                    return;
                }
                if (typeof value === 'object') {
                    for (const [k, v] of Object.entries(value)) {
                        const kp = keyPath ? `${keyPath}.${String(k).toLowerCase()}` : String(k).toLowerCase();
                        // Common shapes: {date, name, type}
                        if (v && typeof v === 'object' && !Array.isArray(v)) {
                            const maybeDate = v.date || v.data || v.match_date || v.event_date || v.fight_date;
                            const maybeName = v.name || v.event_name || v.title;
                            const iso = normalizeDateToIso(maybeDate);
                            if (iso && /(match|fight|gara|partita|evento|competition|target|date|data)/.test(kp)) {
                                const name = String(maybeName || humanizeKey(k)).trim();
                                out.push({ type: defaultType, name, date: String(iso).trim() });
                                // still recurse for additional dates
                            }
                        }
                        walk(v, kp);
                    }
                }
            };

            walk(obj, String(path || '').toLowerCase());
            return out;
        }

        function dedupeEventCandidates(list) {
            const out = [];
            const seen = new Set();
            (Array.isArray(list) ? list : []).forEach(e => {
                const type = String(e?.type || '').toLowerCase().trim() || 'match';
                const name = String(e?.name || '').toLowerCase().trim();
                const dateRaw = String(e?.date || '').trim();
                const date = normalizeDateToIso(dateRaw);
                if (!date) return;
                const key = `${type}::${date}::${name}`;
                if (seen.has(key)) return;
                seen.add(key);
                out.push({ type, name: String(e?.name || '').trim() || 'Evento', date });
            });
            return out;
        }

        async function importCalendarEventsBestEffort(athleteId) {
            if (!athleteId) return;
            const sportKey = String(selectedAthlete?.sport || '').toLowerCase();

            let extra = { sportData: {}, schedule: {}, goals: [] };
            try {
                extra = await fetchExtraAthleteContext(athleteId);
            } catch {
                extra = { sportData: {}, schedule: {}, goals: [] };
            }

            const candidates = [];

            // 0) Macrocycle target (if any)
            try {
                const macro = window.MacrocyclePlanner?.getActive ? window.MacrocyclePlanner.getActive(athleteId) : null;
                const iso = normalizeDateToIso(macro?.targetDate);
                if (macro && iso) {
                    candidates.push({ type: 'other', name: String(macro.eventName || 'Obiettivo').trim() || 'Obiettivo', date: iso });
                }
            } catch {}

            // 1) Legacy next_event (if any)
            try {
                const ne = getNextEventFromProgramState() || getNextEventForAthlete(athleteId);
                const iso = normalizeDateToIso(ne?.date);
                if (ne && iso) {
                    const neType = sportKey === 'boxe' ? 'fight' : 'match';
                    candidates.push({ type: neType, name: String(ne?.name || 'Evento').trim() || 'Evento', date: iso });
                }
            } catch {}

            try {
                if (aiProgramState?.anamnesis) {
                    candidates.push(...extractEventCandidatesFromObject(aiProgramState.anamnesis, { athleteSport: sportKey, path: 'anamnesis' }));
                }
            } catch {}
            try {
                if (extra?.sportData) {
                    candidates.push(...extractEventCandidatesFromObject(extra.sportData, { athleteSport: sportKey, path: 'sportData' }));
                }
            } catch {}
            try {
                if (extra?.schedule) {
                    candidates.push(...extractEventCandidatesFromObject(extra.schedule, { athleteSport: sportKey, path: 'schedule' }));
                }
            } catch {}
            try {
                if (Array.isArray(extra?.goals) && extra.goals.length) {
                    candidates.push(...extractEventCandidatesFromObject(extra.goals, { athleteSport: sportKey, path: 'goals' }));
                }
            } catch {}

            const unique = dedupeEventCandidates(candidates);
            if (!unique.length) {
                try { showToast('Nessun evento importabile trovato in anamnesi/schedule.', 'info'); } catch {}
                return;
            }

            const cal = getCalendarActive(athleteId);
            const before = Array.isArray(cal?.events) ? cal.events.length : 0;

            let patched = cal;
            unique.forEach(row => {
                // Dedup against existing by (type,date,name)
                const exists = (Array.isArray(patched?.events) ? patched.events : []).some(e => {
                    return String(e?.type || 'match') === String(row.type || 'match')
                        && String(e?.date || '') === String(row.date || '')
                        && String(e?.name || '').trim().toLowerCase() === String(row.name || '').trim().toLowerCase();
                });
                if (exists) return;
                patched = upsertEventIntoCalendar(patched, {
                    id: crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    type: row.type,
                    name: row.name,
                    date: row.date,
                    md0_mode: 'off'
                });
            });

            const after = Array.isArray(patched?.events) ? patched.events.length : 0;
            if (after === before) {
                try { showToast('Import completato: nessun nuovo evento (giÃ  presenti).', 'info'); } catch {}
                return;
            }

            const out = { ...patched, active_event_id: patched?.active_event_id || pickAutoActiveEventId(patched?.events) };
            setCalendarActive(athleteId, out);
            syncNextEventUI(athleteId);
            try { showToast(`Importati ${after - before} eventi.`, 'success'); } catch {}
        }

        function parseDateOnly(dateStr) {
            // Parse YYYY-MM-DD as local date (no timezone shift)
            const s = String(dateStr || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
            const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
            const dt = new Date(y, (m - 1), d);
            return Number.isFinite(dt.getTime()) ? dt : null;
        }

        function startOfWeekMonday(date) {
            const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            const jsDay = d.getDay(); // 0=Sun..6=Sat
            const mondayIndex = (jsDay + 6) % 7; // 0=Mon..6=Sun
            d.setDate(d.getDate() - mondayIndex);
            return d;
        }

        function dayIndexFromLabel(dayLabel) {
            const d = String(dayLabel || '').toLowerCase().trim();
            const map = {
                monday: 0, mon: 0, lun: 0, lunedi: 0, 'lunedÃ¬': 0,
                tuesday: 1, tue: 1, mar: 1, martedi: 1, 'martedÃ¬': 1,
                wednesday: 2, wed: 2, mer: 2, mercoledi: 2, 'mercoledÃ¬': 2,
                thursday: 3, thu: 3, gio: 3, giovedi: 3, 'giovedÃ¬': 3,
                friday: 4, fri: 4, ven: 4, venerdi: 4, 'venerdÃ¬': 4,
                saturday: 5, sat: 5, sab: 5, sabato: 5,
                sunday: 6, sun: 6, dom: 6, domenica: 6
            };
            return Object.prototype.hasOwnProperty.call(map, d) ? map[d] : null;
        }

        function computeMatchDayTypeForWorkoutDay(dayOfWeekLabel, matchDateStr) {
            const matchDate = parseDateOnly(matchDateStr);
            if (!matchDate) return null;

            const idx = dayIndexFromLabel(dayOfWeekLabel);
            if (idx == null) return null;

            const weekStart = startOfWeekMonday(matchDate);
            const workoutDate = new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate());
            workoutDate.setDate(workoutDate.getDate() + idx);

            const diffDays = Math.round((matchDate - workoutDate) / (24 * 60 * 60 * 1000));
            if (diffDays === 0) return 'md0';
            if (diffDays > 0) return `md-${Math.min(7, diffDays)}`;
            return `md+${Math.min(7, Math.abs(diffDays))}`;
        }

        function inferSeasonPhaseForAthlete(athlete, nextEvent) {
            const sportKey = String(athlete?.sport || '').toLowerCase();
            const teamSport = sportKey === 'calcio' || sportKey === 'basket';

            // Prefer Macrocycle phase if present
            try {
                if (teamSport && window.MacrocyclePlanner?.getCurrentPhase && athlete?.id) {
                    const p = window.MacrocyclePlanner.getCurrentPhase(athlete.id);
                    const name = String(p?.name || '').toLowerCase();
                    const code = String(p?.code || '').toLowerCase();
                    const hint = `${name} ${code}`;
                    if (/competition|compet|gara|match|season|campionato/.test(hint)) return 'in_season';
                    if (/pre\s*season|preseason|build\s*up|build-up|base|gpp|accumulo|preparazione/.test(hint)) return 'pre_season';
                    if (/taper|peaking|picco/.test(hint)) return 'in_season';
                    if (/post\s*season|off\s*season|offseason|transizione|rest|recovery/.test(hint)) return 'post_season';
                }
            } catch {
                // ignore
            }

            // Fallback: if user explicitly sets a match/partita, treat as in-season for team sports
            const name = String(nextEvent?.name || '').toLowerCase();
            const hasEvent = Boolean(String(nextEvent?.date || '').trim());
            if (teamSport && hasEvent && /(partita|match|gara|campionato|playoff|league)/.test(name)) return 'in_season';
            return null;
        }

        function formatNextEventContext(nextEvent, athlete) {
            const name = String(nextEvent?.name || '').trim();
            const date = String(nextEvent?.date || '').trim();
            if (!name && !date) return '';
            const seasonPhase = inferSeasonPhaseForAthlete(athlete, nextEvent);
            const seasonText = seasonPhase ? ` | seasonPhase=${seasonPhase}` : '';
            return `PROSSIMO EVENTO (override): ${name || 'N/A'} | data=${date || 'N/A'}${seasonText}`;
        }

        function syncNextEventUI(athleteId) {
            const nameEl = document.getElementById('next-event-name');
            const dateEl = document.getElementById('next-event-date');
            const md0PrimerEl = document.getElementById('md0-primer-enabled');
            const hintEl = document.getElementById('next-event-hint');
            if (!nameEl || !dateEl) return;

            const v = getNextEventActive(athleteId);
            nameEl.value = v?.name || '';
            dateEl.value = v?.date || '';
            if (md0PrimerEl) md0PrimerEl.checked = String(v?.md0_mode || 'off') === 'primer';

            // If Supabase memory has it, keep localStorage in sync (compat / offline)
            try {
                const fromState = getNextEventFromProgramState();
                if (fromState) setNextEventForAthlete(athleteId, fromState);
            } catch {
                // ignore
            }

            // Render calendar list
            try { renderCalendarUI(athleteId); } catch { /* ignore */ }
            try { if (isCalendarOverlayOpen()) renderCalendarOverlay(athleteId); } catch { /* ignore */ }

            if (hintEl) {
                if (v?.date) {
                    hintEl.textContent = 'Override attivo: MD-1/MD0/MD+1 calcolati sulla settimana della data inserita.';
                } else {
                    hintEl.textContent = 'Usato per calcolare MD-1/MD0/MD+1 e applicare regole in-season (calcio/basket) e match-week (boxe). Se cambia la partita, aggiorna qui prima di generare.';
                }
            }
        }
        
        function formatMacroDate(dateStr) {
            const d = new Date(dateStr);
            const options = { day: 'numeric', month: 'short', year: 'numeric' };
            return d.toLocaleDateString('it-IT', options);
        }
        
        function showMacrocycleModal(athleteId, athleteSport) {
            // Remove existing modal
            const existing = document.getElementById('macro-modal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.id = 'macro-modal';
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content macro-modal">
                    <div class="modal-header">
                        <h3><i class="fas fa-calendar-alt"></i> Pianifica Obiettivo</h3>
                        <button class="modal-close" onclick="closeMacroModal()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="macro-event-input">Nome Evento/Obiettivo</label>
                            <input type="text" id="macro-event-input" placeholder="es. Match Campionato, Maratona Milano..." value="">
                        </div>
                        <div class="form-group">
                            <label for="macro-date-input">Data Obiettivo</label>
                            <input type="date" id="macro-date-input" min="${getTodayDate()}">
                        </div>
                        <div class="form-group">
                            <label>Sport: <strong>${athleteSport || 'Non specificato'}</strong></label>
                        </div>
                        <div id="macro-preview" class="macro-preview" style="display: none;">
                            <!-- Preview will be rendered here -->
                        </div>
                        <div id="macro-error" class="macro-error" style="display: none;"></div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-secondary" onclick="closeMacroModal()">Annulla</button>
                        <button class="btn-primary" id="btn-save-macro" onclick="saveMacrocycle('${athleteId}', '${athleteSport}')" disabled>
                            <i class="fas fa-check"></i> Crea Piano
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners for preview
            document.getElementById('macro-date-input').addEventListener('change', () => previewMacrocycle(athleteSport));
            document.getElementById('macro-event-input').addEventListener('input', () => previewMacrocycle(athleteSport));
            
            // Add modal styles if not present
            addMacroModalStyles();
        }
        
        function getTodayDate() {
            return new Date().toISOString().split('T')[0];
        }
        
        function previewMacrocycle(sport) {
            const dateInput = document.getElementById('macro-date-input');
            const eventInput = document.getElementById('macro-event-input');
            const previewEl = document.getElementById('macro-preview');
            const errorEl = document.getElementById('macro-error');
            const saveBtn = document.getElementById('btn-save-macro');
            
            if (!dateInput.value) {
                previewEl.style.display = 'none';
                saveBtn.disabled = true;
                return;
            }
            
            const preview = window.MacrocyclePlanner.preview(sport, dateInput.value);
            
            if (!preview.success) {
                errorEl.textContent = preview.error;
                errorEl.style.display = 'block';
                previewEl.style.display = 'none';
                saveBtn.disabled = true;
                return;
            }
            
            errorEl.style.display = 'none';
            previewEl.style.display = 'block';
            saveBtn.disabled = false;
            
            previewEl.innerHTML = `
                <h4>ðŸ“… Preview Piano (${preview.totalWeeks} settimane)</h4>
                <div class="macro-timeline">
                    ${preview.phases.map((phase, idx) => `
                        <div class="timeline-phase" style="--phase-color: ${getPhaseColor(idx)}">
                            <div class="phase-marker"></div>
                            <div class="phase-info">
                                <strong>${phase.name}</strong> (${phase.weeks} sett.)
                                <span class="phase-dates">${formatMacroDate(phase.startDate)} â†’ ${formatMacroDate(phase.endDate)}</span>
                                <span class="phase-focus">${phase.focus}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                ${preview.deloads.length > 0 ? `
                    <div class="deload-info">
                        <i class="fas fa-bed"></i> Deload programmati: settimane ${preview.deloads.map(d => d.week).join(', ')}
                    </div>
                ` : ''}
            `;
        }
        
        function getPhaseColor(index) {
            const colors = ['#00D26A', '#2196F3', '#FF9800', '#E63946'];
            return colors[index % colors.length];
        }
        
        function saveMacrocycle(athleteId, sport) {
            const eventName = document.getElementById('macro-event-input').value || 'Obiettivo';
            const targetDate = document.getElementById('macro-date-input').value;
            
            if (!targetDate) return;
            
            const result = window.MacrocyclePlanner.create(athleteId, sport, targetDate, eventName);
            
            if (result.success) {
                closeMacroModal();
                updateMacrocycleUI(athleteId);
                showToast('âœ… Macrociclo creato con successo!', 'success');
            } else {
                document.getElementById('macro-error').textContent = result.error;
                document.getElementById('macro-error').style.display = 'block';
            }
        }
        
        function closeMacroModal() {
            const modal = document.getElementById('macro-modal');
            if (modal) modal.remove();
        }
        
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = message;
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${type === 'success' ? '#00D26A' : type === 'error' ? '#E63946' : '#2196F3'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: 600;
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
        
        function addMacroModalStyles() {
            if (document.getElementById('macro-modal-styles')) return;
            
            const style = document.createElement('style');
            style.id = 'macro-modal-styles';
            style.textContent = `
                .modal-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                }
                .macro-modal {
                    background: #1a1a1a;
                    border-radius: 16px;
                    width: 90%;
                    max-width: 500px;
                    max-height: 90vh;
                    overflow: auto;
                }
                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 20px;
                    border-bottom: 1px solid #333;
                }
                .modal-header h3 {
                    margin: 0;
                    color: #FF9800;
                }
                .modal-header h3 i { margin-right: 8px; }
                .modal-close {
                    background: none;
                    border: none;
                    color: #888;
                    font-size: 20px;
                    cursor: pointer;
                }
                .modal-close:hover { color: #fff; }
                .modal-body {
                    padding: 20px;
                }
                .form-group {
                    margin-bottom: 16px;
                }
                .form-group label {
                    display: block;
                    color: #888;
                    font-size: 12px;
                    margin-bottom: 6px;
                }
                .form-group input {
                    width: 100%;
                    padding: 12px;
                    background: #0a0a0a;
                    border: 1px solid #333;
                    border-radius: 8px;
                    color: #fff;
                    font-size: 14px;
                }
                .form-group input:focus {
                    outline: none;
                    border-color: #FF9800;
                }
                .modal-footer {
                    padding: 20px;
                    border-top: 1px solid #333;
                    display: flex;
                    justify-content: flex-end;
                    gap: 10px;
                }
                .btn-secondary {
                    background: #333;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    color: #fff;
                    cursor: pointer;
                }
                .btn-primary {
                    background: linear-gradient(135deg, #FF9800, #ff5722);
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    color: #fff;
                    font-weight: 600;
                    cursor: pointer;
                }
                .btn-primary:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                .macro-preview {
                    background: #0a0a0a;
                    border-radius: 12px;
                    padding: 16px;
                    margin-top: 16px;
                }
                .macro-preview h4 {
                    margin: 0 0 12px 0;
                    color: #FF9800;
                    font-size: 14px;
                }
                .macro-timeline {
                    position: relative;
                    padding-left: 20px;
                }
                .timeline-phase {
                    position: relative;
                    padding: 8px 0 8px 16px;
                    border-left: 2px solid #333;
                }
                .timeline-phase:last-child {
                    border-left-color: transparent;
                }
                .phase-marker {
                    position: absolute;
                    left: -7px;
                    top: 12px;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: var(--phase-color);
                }
                .phase-info {
                    display: flex;
                    flex-direction: column;
                    gap: 2px;
                }
                .phase-info strong {
                    color: #fff;
                    font-size: 13px;
                }
                .phase-dates {
                    font-size: 11px;
                    color: #666;
                }
                .phase-focus {
                    font-size: 10px;
                    color: #888;
                    font-style: italic;
                }
                .deload-info {
                    margin-top: 12px;
                    padding: 8px 12px;
                    background: rgba(33, 150, 243, 0.1);
                    border-radius: 6px;
                    font-size: 11px;
                    color: #2196F3;
                }
                .deload-info i { margin-right: 6px; }
                .macro-error {
                    background: rgba(230, 57, 70, 0.1);
                    color: #E63946;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 12px;
                    margin-top: 12px;
                }
                @keyframes slideIn {
                    from { transform: translateY(20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }

        function setWorkflowStep(step) {
            document.querySelectorAll('.step-item').forEach((el, i) => {
                el.classList.remove('active', 'completed');
                if (i + 1 < step) el.classList.add('completed');
                if (i + 1 === step) el.classList.add('active');
            });

            // Progress line (3 phases)
            const fill = document.getElementById('progress-line-fill');
            if (fill) {
                const s = Math.max(1, Math.min(3, Number(step) || 1));
                const pct = (s / 3) * 100;
                fill.style.width = `${pct}%`;
            }
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function nl2br(text) {
            return String(text).replace(/\n/g, '<br>');
        }

        function stripMarkdownLite(text) {
            let t = String(text || '');
            // remove common markdown emphasis
            t = t.replace(/\*\*(.*?)\*\*/g, '$1');
            t = t.replace(/__(.*?)__/g, '$1');
            t = t.replace(/`([^`]+)`/g, '$1');
            // normalize bullets
            t = t.replace(/^\s*[*+-]\s+/gm, '');
            return t;
        }

        // AI Mode management
        function changeAIMode(mode) {
            if (window.DualAI) {
                window.DualAI.setMode(mode);
                console.log('ðŸ¤– AI Mode changed to:', mode);
            }
        }

        // Use DualAI if available, fallback to legacy groqChat
        async function groqChat({ model, messages, temperature = 0.3, max_tokens = 700, useCache = true }) {
            const startTime = Date.now();
            
            // Check cache first
            if (useCache) {
                const cached = getCachedResponse(messages, model);
                if (cached) {
                    return cached;
                }
            }
            
            // Try DualAI first (supports both Groq and Gemini)
            if (window.DualAI) {
                try {
                    const modelType = model.includes('8b') ? 'fast' : 'balanced';
                    const result = await window.DualAI.chat({
                        messages,
                        model: modelType,
                        temperature,
                        maxTokens: max_tokens
                    });
                    
                    // Log AI info
                    const stats = window.DualAI.getStats();
                    const responseTime = Date.now() - startTime;
                    console.log(`ðŸ¤– DualAI [${result.provider}${result.validated ? ' âœ“' : ''}${result.fallback ? ' (fallback)' : ''}] ${responseTime}ms | Groq: ${stats.groqCalls} | Gemini: ${stats.geminiCalls}`);
                    
                    const response = { data: {}, content: result.content };
                    
                    // Cache successful response
                    if (useCache) setCachedResponse(messages, model, response);
                    
                    // Log model stats
                    logAISuccess('dual_ai', { model: result.provider, responseTimeMs: responseTime });
                    
                    return response;
                } catch (e) {
                    console.warn('DualAI failed, falling back to legacy:', e.message);
                    logAIError('dual_ai', e, { model });
                }
            }
            
            // Legacy Groq-only fallback with enhanced retry
            const MAX_TOKENS_CAP = 2000;
            const maxAttempts = 4; // Increased from 3
            const retryableErrors = [429, 500, 502, 503, 504]; // Rate limit + server errors
            let attempt = 0;
            let lastError = null;
            
            while (attempt < maxAttempts) {
                try {
                    const attemptStart = Date.now();
                    const safeMessages = Array.isArray(messages)
                        ? messages.map(m => {
                            const role = m?.role;
                            const content = String(m?.content ?? '');
                            // Progressive truncation on retries
                            const maxLen = attempt === 0 ? 12000 : (12000 - attempt * 2000);
                            const clipped = content.length > maxLen ? `${content.slice(0, maxLen)}\nâ€¦[TRUNCATED]` : content;
                            return { role, content: clipped };
                        })
                        : [];
                    
                    // Increase temperature slightly on retries for variety
                    const adjustedTemp = Math.min(1.0, temperature + (attempt * 0.1));
                    
                    const res = await fetch('/api/ai/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model,
                            messages: safeMessages,
                            temperature: adjustedTemp,
                            max_tokens: Math.min(Number.isFinite(Number(max_tokens)) ? Number(max_tokens) : 700, MAX_TOKENS_CAP)
                        })
                    });

                    const text = await res.text();
                    let data;
                    try { data = JSON.parse(text); } catch { data = { raw: text }; }
                    
                    if (!res.ok) {
                        const err = data?.error || 'Errore AI';
                        const details = data?.details ? JSON.stringify(data.details) : text;
                        const e = new Error(`${err}: ${details}`);
                        e.status = res.status;
                        lastError = e;

                        if (retryableErrors.includes(res.status) && attempt < maxAttempts - 1) {
                            aiTelemetry.retryCount++;
                            const retryAfter = res.headers.get('Retry-After');
                            const retryAfterMs = retryAfter && !Number.isNaN(Number(retryAfter)) ? (Number(retryAfter) * 1000) : null;
                            // Exponential backoff: 1s, 2s, 4s, 8s
                            const backoffMs = retryAfterMs != null ? retryAfterMs : Math.min(8000, 1000 * Math.pow(2, attempt));
                            console.warn(`â³ AI Retry ${attempt + 1}/${maxAttempts} in ${backoffMs}ms (status ${res.status})`);
                            addAIDecision('sync', `Retry ${attempt + 1}`, `Status ${res.status}, attendo ${backoffMs}ms`);
                            await new Promise(r => setTimeout(r, backoffMs));
                            attempt++;
                            continue;
                        }

                        throw e;
                    }

                    const content = data?.choices?.[0]?.message?.content;
                    if (!content) {
                        lastError = new Error('Risposta AI vuota');
                        if (attempt < maxAttempts - 1) {
                            aiTelemetry.retryCount++;
                            console.warn(`â³ AI Retry ${attempt + 1}/${maxAttempts}: risposta vuota`);
                            await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));
                            attempt++;
                            continue;
                        }
                        throw lastError;
                    }
                    
                    const responseTime = Date.now() - startTime;
                    const response = { data, content };
                    
                    // Cache successful response
                    if (useCache) setCachedResponse(messages, model, response);
                    
                    // Log success with timing
                    logAISuccess('legacy_groq', { model, responseTimeMs: responseTime });
                    
                    if (attempt > 0) {
                        addAIDecision('check-circle', `Successo dopo ${attempt + 1} tentativi`, `${responseTime}ms`);
                    }
                    
                    return response;
                    
                } catch (fetchError) {
                    lastError = fetchError;
                    if (attempt < maxAttempts - 1 && (fetchError.name === 'TypeError' || fetchError.message.includes('fetch'))) {
                        // Network error - retry with backoff
                        aiTelemetry.retryCount++;
                        const backoffMs = 1000 * Math.pow(2, attempt);
                        console.warn(`â³ AI Retry ${attempt + 1}/${maxAttempts} (network error) in ${backoffMs}ms`);
                        await new Promise(r => setTimeout(r, backoffMs));
                        attempt++;
                        continue;
                    }
                    throw fetchError;
                }
            }

            throw lastError || new Error('Errore AI: troppi tentativi');
        }

        function parseAiJsonOrThrow(content, label = 'AI JSON') {
            const c = String(content || '');
            let parsed = null;

            function repairJsonText(jsonText) {
                let t = String(jsonText || '');
                // Common copy/paste typography issues
                t = t.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");
                // Remove trailing commas before } or ] (JSON5-ish output)
                t = t.replace(/,\s*([}\]])/g, '$1');
                return t;
            }

            try {
                const result = window.GR_AI_JSON?.parseFirstJson ? window.GR_AI_JSON.parseFirstJson(c) : null;
                if (result?.ok) {
                    parsed = result.value;
                } else if (result?.jsonText) {
                    // Try a minimal, safe repair if we extracted a balanced JSON chunk.
                    try {
                        parsed = JSON.parse(repairJsonText(result.jsonText));
                    } catch {
                        // keep null
                    }
                }
            } catch {
                // ignore
            }

            if (!parsed) throw new Error(`${label}: JSON non trovato o invalido`);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NORMALIZZA FORMATI ALTERNATIVI
            // Alcuni modelli restituiscono {workout: {...}} invece di {...}
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (parsed.workout && typeof parsed.workout === 'object') {
                parsed = parsed.workout;
            }
            
            // Converti formati alternativi di esercizi
            if (!Array.isArray(parsed.exercises)) {
                const exercises = [];
                
                // Formato: warmup[], technical[], strength[], conditioning[], cooldown[] (ARRAYS)
                const sections = ['warmup', 'warm_up', 'technical', 'strength', 'conditioning', 'cooldown', 'cool_down', 'main', 'accessory'];
                for (const section of sections) {
                    if (Array.isArray(parsed[section])) {
                        for (const ex of parsed[section]) {
                            if (ex && typeof ex === 'object') {
                                exercises.push({
                                    name: ex.name || ex.exercise || ex.movimento || String(ex),
                                    sets: ex.sets || ex.serie || 1,
                                    reps: ex.reps || ex.ripetizioni || ex.duration || ex.durata || 'N/A',
                                    type: section.includes('warm') || section.includes('cool') ? 'conditioning' : 
                                          section === 'strength' ? 'strength' : 
                                          section === 'technical' || section === 'conditioning' ? 'conditioning' : 'hypertrophy'
                                });
                            }
                        }
                    }
                }
                
                // Formato: warmup, technical, strength_main, etc. come STRINGHE
                const stringSections = [
                    { key: 'warmup', type: 'conditioning' },
                    { key: 'warm_up', type: 'conditioning' },
                    { key: 'technical', type: 'conditioning' },
                    { key: 'strength_main', type: 'strength' },
                    { key: 'strength_accessory', type: 'strength' },
                    { key: 'conditioning', type: 'conditioning' },
                    { key: 'cooldown', type: 'conditioning' },
                    { key: 'cool_down', type: 'conditioning' },
                    { key: 'core', type: 'conditioning' }
                ];
                
                for (const { key, type } of stringSections) {
                    const val = parsed[key];
                    if (val && typeof val === 'string' && val.trim().length > 3) {
                        // Prova a splittare se contiene piÃ¹ esercizi separati da ", A1:", ", A2:", etc.
                        const parts = val.split(/,\s*(?=[A-Z]\d:|[A-Z]\d\.)/);
                        
                        if (parts.length > 1) {
                            // PiÃ¹ esercizi nella stessa stringa
                            for (const part of parts) {
                                if (part.trim().length > 3) {
                                    const setsMatch = part.match(/(\d+)x(\d+[-\d]*)/);
                                    const repsMatch = part.match(/(\d+[-\d]*)\s*(reps|ripetizioni|min|sec|s)/i);
                                    exercises.push({
                                        name: part.trim().substring(0, 100),
                                        sets: setsMatch ? parseInt(setsMatch[1]) : 3,
                                        reps: repsMatch ? repsMatch[1] + (repsMatch[2] || '') : setsMatch ? setsMatch[2] : '10',
                                        type: type
                                    });
                                }
                            }
                        } else {
                            // Singolo esercizio
                            const setsMatch = val.match(/(\d+)x(\d+[-\d]*)/);
                            const repsMatch = val.match(/(\d+[-\d]*)\s*(reps|ripetizioni|min|sec|s)/i);
                            exercises.push({
                                name: val.trim().substring(0, 100),
                                sets: setsMatch ? parseInt(setsMatch[1]) : 1,
                                reps: repsMatch ? repsMatch[1] + (repsMatch[2] || '') : setsMatch ? setsMatch[2] : 'N/A',
                                type: type
                            });
                        }
                    }
                }
                
                if (exercises.length > 0) {
                    parsed.exercises = exercises;
                    console.log(`ðŸ”„ Converted alternative format: ${exercises.length} exercises from sections`);
                }
            }
            
            return parsed;
        }

        function addAIMessageSafe(expertKey, text, confidence = 'high') {
            addAIMessage(expertKey, nl2br(escapeHtml(stripMarkdownLite(text))), confidence);
        }

        function formatScheduleAvailability(schedule) {
            try {
                if (!schedule || typeof schedule !== 'object') return '';
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                const dayNames = {
                    monday: 'LunedÃ¬',
                    tuesday: 'MartedÃ¬',
                    wednesday: 'MercoledÃ¬',
                    thursday: 'GiovedÃ¬',
                    friday: 'VenerdÃ¬',
                    saturday: 'Sabato',
                    sunday: 'Domenica'
                };
                const available = [];
                for (const d of days) {
                    const v = String(schedule[d] || '').toLowerCase();
                    if (v === 'gr_available' || v === 'gr_perform' || v === 'both') available.push(dayNames[d]);
                }
                const maxSessions = schedule.max_gr_sessions_per_week != null ? Number(schedule.max_gr_sessions_per_week) : null;
                const duration = schedule.session_duration != null ? Number(schedule.session_duration) : null;
                const parts = [];
                if (available.length) parts.push(`Giorni disponibili GR: ${available.join(', ')}`);
                if (Number.isFinite(maxSessions)) parts.push(`Max sessioni GR/sett: ${maxSessions}`);
                if (Number.isFinite(duration)) parts.push(`Durata target: ${duration} min`);
                return parts.length ? `AGENDA: ${parts.join(' | ')}` : '';
            } catch {
                return '';
            }
        }

        function formatAnamnesisContext(state) {
            try {
                const a = state?.anamnesis && typeof state.anamnesis === 'object' ? state.anamnesis : null;
                if (!a) return '';

                const pillars = a?.pillars && typeof a.pillars === 'object' ? a.pillars : {};
                const focusPct = pillars.focus_percentages && typeof pillars.focus_percentages === 'object'
                    ? pillars.focus_percentages
                    : null;
                const equip = String(pillars.equipment_access || '').trim();
                const likes = String(pillars.training_likes || '').trim();
                const dislikes = String(pillars.training_dislikes || '').trim();
                const constraints = String(pillars.constraints || '').trim();

                const sessionMin = pillars.session_duration_minutes != null ? Number(pillars.session_duration_minutes) : null;
                const programWeeks = pillars.program_duration_weeks != null ? Number(pillars.program_duration_weeks) : null;

                const lines = [];
                lines.push('ANAMNESI (PILASTRI):');
                if (focusPct) {
                    const p = Number(focusPct.performance);
                    const s = Number(focusPct.strength);
                    const c = Number(focusPct.conditioning);
                    const m = Number(focusPct.mobility);
                    const items = [];
                    if (Number.isFinite(p)) items.push(`performance/skill ${p}%`);
                    if (Number.isFinite(s)) items.push(`forza ${s}%`);
                    if (Number.isFinite(c)) items.push(`conditioning ${c}%`);
                    if (Number.isFinite(m)) items.push(`mobilitÃ /prehab ${m}%`);
                    if (items.length) lines.push(`- Focus (percentuali): ${items.join(' | ')}`);
                }
                if (Number.isFinite(sessionMin)) lines.push(`- Durata sessione preferita: ${sessionMin} min`);
                if (Number.isFinite(programWeeks)) lines.push(`- Durata programma: ${programWeeks} settimane`);
                if (equip) lines.push(`- Attrezzatura: ${equip}`);
                if (likes) lines.push(`- Preferenze: ${likes}`);
                if (dislikes) lines.push(`- Evita: ${dislikes}`);
                if (constraints) lines.push(`- Vincoli/limitazioni: ${constraints}`);
                return lines.join('\n');
            } catch {
                return '';
            }
        }

        function getExerciseLibrary(sport, focusPrimary) {
            // Prefer shared curated library module when available
            try {
                if (typeof window.GR_getExerciseLibrary === 'function') {
                    return window.GR_getExerciseLibrary(sport, focusPrimary);
                }
            } catch {
                // fallback to local defaults
            }

            const s = String(sport || '').toLowerCase();
            const f = String(focusPrimary || '').toLowerCase();

            const common = {
                warmup: [
                    'Hip mobility flow',
                    'Ankle mobility + calf activation',
                    'Thoracic rotation + breathing',
                    'Glute med activation (band walks)',
                    'Dynamic hamstring prep'
                ],
                lowerStrength: [
                    'Trap Bar Deadlift',
                    'Front Squat',
                    'Goblet Squat',
                    'Romanian Deadlift',
                    'Bulgarian Split Squat',
                    'Hip Thrust'
                ],
                upperStrength: [
                    'Incline Dumbbell Press',
                    'Bench Press',
                    'Landmine Press',
                    'Pull-ups',
                    'Lat Pulldown',
                    'Chest-Supported Row'
                ],
                accessory: [
                    'Nordic Hamstring (eccentric)',
                    'Copenhagen plank',
                    'Calf Raises',
                    'Cable Row',
                    'DB Rear Delt Raise',
                    'Pallof Press',
                    'Farmer Carry'
                ],
                conditioning: [
                    'Assault Bike Intervals',
                    'Row Erg Intervals',
                    'Sled Pushes',
                    'Tempo Run (easy)',
                    'Shuttle Runs (COD)'
                ]
            };

            if (s === 'boxe') {
                return {
                    ...common,
                    conditioning: ['Jump Rope Intervals', 'Assault Bike Intervals', 'Shuttle Runs (COD)', 'Medicine Ball Slams', 'Shadowboxing conditioning'],
                    accessory: [...common.accessory, 'Rotational med ball throws', 'Scapular control (Y-T-W)']
                };
            }

            if (s === 'calcio' || s === 'basket') {
                return {
                    ...common,
                    conditioning: ['Sled Pushes', 'Shuttle Runs (COD)', 'Tempo Run (easy)', 'Bike Intervals', 'Acceleration mechanics drills'],
                    accessory: [...common.accessory, 'Adductor strength (side plank adduction)', 'Single-leg balance + reach']
                };
            }

            // palestra / default
            if (f === 'hypertrophy') {
                return {
                    ...common,
                    lowerStrength: ['Back Squat', 'Leg Press', 'Romanian Deadlift', 'Hack Squat', 'Walking Lunges'],
                    upperStrength: ['Incline Dumbbell Press', 'Cable Fly', 'Lat Pulldown', 'Seated Row', 'Dumbbell Shoulder Press'],
                    conditioning: ['Incline treadmill walk', 'Bike intervals', 'Row erg easy']
                };
            }
            return common;
        }

        function formatExerciseLibrary(lib) {
            // Use ExerciseLibraryV2 if available for rich structured data
            try {
                if (typeof window.ExerciseLibraryV2 !== 'undefined') {
                    return formatExerciseLibraryV2(selectedAthlete?.sport);
                }
            } catch (e) {
                console.warn('ExerciseLibraryV2 not available, using fallback');
            }
            
            // Fallback to old format
            try {
                if (!lib || typeof lib !== 'object') return '';
                const lines = [];
                lines.push('LIBRERIA ESERCIZI (scegli principalmente da qui):');
                const add = (label, arr) => {
                    const a = Array.isArray(arr) ? arr.filter(Boolean) : [];
                    if (!a.length) return;
                    lines.push(`- ${label}: ${a.join(', ')}`);
                };
                add('Warm-up / prep', lib.warmup);
                add('Lower strength', lib.lowerStrength);
                add('Upper strength', lib.upperStrength);
                add('Accessory / prehab / core', lib.accessory);
                add('Conditioning', lib.conditioning);
                return lines.join('\n');
            } catch {
                return '';
            }
        }
        
        function formatExerciseLibraryV2(sport) {
            const LIB = window.ExerciseLibraryV2;
            if (!LIB) return '';
            
            const sportKey = String(sport || 'palestra').toLowerCase();
            const exercises = LIB.getBySport(sportKey);
            
            if (!exercises.length) {
                // Fallback to all exercises
                return LIB.generatePromptSection(sportKey, { includeDetails: true });
            }
            
            const lines = [];
            lines.push('â•â•â• LIBRERIA ESERCIZI STRUTTURATA â•â•â•');
            lines.push(`Sport: ${sportKey.toUpperCase()} | Totale esercizi disponibili: ${exercises.length}`);
            lines.push('');
            
            // Group by pattern
            const patterns = {};
            exercises.forEach(ex => {
                const p = ex.pattern || 'other';
                if (!patterns[p]) patterns[p] = [];
                patterns[p].push(ex);
            });
            
            const patternLabels = {
                'hinge': 'ðŸ”„ HINGE (anche dominanti)',
                'squat': 'ðŸ¦µ SQUAT (ginocchio dominanti)',
                'push_horizontal': 'ðŸ’ª PUSH ORIZZONTALE',
                'push_vertical': 'ðŸ™Œ PUSH VERTICALE',
                'pull_horizontal': 'ðŸŽ¯ PULL ORIZZONTALE',
                'pull_vertical': 'â¬†ï¸ PULL VERTICALE',
                'rotation': 'ðŸŒ€ ROTAZIONE',
                'anti_rotation': 'ðŸ›¡ï¸ ANTI-ROTAZIONE',
                'plyometric': 'âš¡ PLIOMETRIA/POTENZA',
                'locomotion': 'ðŸƒ LOCOMOZIONE/CONDITIONING',
                'isometric': 'ðŸ§˜ ISOMETRICI/PREHAB'
            };
            
            Object.keys(patterns).forEach(pattern => {
                const label = patternLabels[pattern] || pattern.toUpperCase();
                lines.push(`${label}:`);
                
                patterns[pattern].forEach(ex => {
                    const muscles = ex.muscles.primary.join(', ');
                    const diff = ex.difficulty === 'advanced' ? 'âš ï¸' : ex.difficulty === 'intermediate' ? 'â—' : 'â—‹';
                    lines.push(`  ${diff} ${ex.name} [${muscles}]`);
                    
                    // Add key cue for complex exercises
                    if (ex.cues && ex.cues.length > 0 && ex.difficulty !== 'beginner') {
                        lines.push(`    â†³ Cue: ${ex.cues[0]}`);
                    }
                    
                    // Add contraindications for injury prevention
                    if (ex.contraindications && ex.contraindications.length > 0) {
                        lines.push(`    âš ï¸ Evita se: ${ex.contraindications.join(', ')}`);
                    }
                });
                lines.push('');
            });
            
            // Add methodology hints
            lines.push('â•â•â• METODOLOGIE APPLICABILI â•â•â•');
            lines.push('â€¢ strength: 3-5 reps, 3-5 min rest, RPE 8-9');
            lines.push('â€¢ hypertrophy: 8-12 reps, 60-90s rest, RPE 7-8');
            lines.push('â€¢ power: 3-5 reps explosive, 2-3 min rest');
            lines.push('â€¢ conditioning: intervals, circuits, AMRAP');
            lines.push('â€¢ prehab: 15-20 reps, 30s rest, focus tecnica');
            lines.push('');
            
            // Add variety rules
            lines.push('â•â•â• REGOLE VARIETÃ€ ACCESSORI â•â•â•');
            lines.push('NON ripetere lo stesso accessorio in B2 ogni giorno!');
            lines.push('Alterna tra questi accessori per spalle/postura:');
            lines.push('â€¢ Face Pull (cable/band)');
            lines.push('â€¢ Band Pull-Apart');
            lines.push('â€¢ Prone Y-T-W');
            lines.push('â€¢ Rear Delt Raise');
            lines.push('â€¢ External Rotation');
            lines.push('â€¢ Scapular Push-Up');
            lines.push('â€¢ Cuban Rotation');
            lines.push('Es: LunedÃ¬=Face Pull, MercoledÃ¬=Band Pull-Apart, VenerdÃ¬=Prone Y-T-W');
            
            return lines.join('\n');
        }
        
        /**
         * Genera libreria esercizi filtrata per infortuni/controindicazioni
         * @param {string} sport - Sport dell'atleta
         * @param {Array} injuries - Lista infortuni/condizioni dell'atleta
         * @returns {string} Testo formattato per prompt AI
         */
        function formatExerciseLibraryV2Safe(sport, injuries = []) {
            const LIB = window.ExerciseLibraryV2;
            if (!LIB) return formatExerciseLibraryV2(sport);
            
            const sportKey = String(sport || 'palestra').toLowerCase();
            
            // Map injuries to contraindication keys
            const injuryMap = {
                'low_back': 'low_back_acute',
                'lower_back': 'low_back_acute',
                'schiena': 'low_back_acute',
                'lombare': 'low_back_acute',
                'spalla': 'shoulder_acute',
                'shoulder': 'shoulder_acute',
                'ginocchio': 'knee_acute',
                'knee': 'knee_acute',
                'caviglia': 'ankle_acute',
                'ankle': 'ankle_acute',
                'polso': 'wrist_acute',
                'wrist': 'wrist_acute',
                'hamstring': 'hamstring_acute',
                'femorale': 'hamstring_acute',
                'inguine': 'groin_strain',
                'adduttori': 'groin_strain',
                'achille': 'achilles_tendinopathy',
                'tendine': 'achilles_tendinopathy',
                'collo': 'neck_acute',
                'cervicale': 'neck_acute'
            };
            
            // Extract contraindications from athlete injuries
            const contraindications = [];
            injuries.forEach(injury => {
                const injuryLower = String(injury || '').toLowerCase();
                Object.keys(injuryMap).forEach(key => {
                    if (injuryLower.includes(key)) {
                        contraindications.push(injuryMap[key]);
                    }
                });
            });
            
            // Get safe exercises
            const allExercises = LIB.getBySport(sportKey);
            const safeExercises = contraindications.length > 0 
                ? allExercises.filter(ex => {
                    return !ex.contraindications.some(c => contraindications.includes(c));
                })
                : allExercises;
            
            const excludedCount = allExercises.length - safeExercises.length;
            
            const lines = [];
            lines.push('â•â•â• LIBRERIA ESERCIZI STRUTTURATA â•â•â•');
            lines.push(`Sport: ${sportKey.toUpperCase()} | Esercizi sicuri: ${safeExercises.length}/${allExercises.length}`);
            
            if (excludedCount > 0) {
                lines.push(`âš ï¸ ${excludedCount} esercizi esclusi per controindicazioni: ${contraindications.join(', ')}`);
            }
            lines.push('');
            
            // Group by pattern
            const patterns = {};
            safeExercises.forEach(ex => {
                const p = ex.pattern || 'other';
                if (!patterns[p]) patterns[p] = [];
                patterns[p].push(ex);
            });
            
            const patternLabels = {
                'hinge': 'ðŸ”„ HINGE',
                'squat': 'ðŸ¦µ SQUAT',
                'push_horizontal': 'ðŸ’ª PUSH ORIZZ',
                'push_vertical': 'ðŸ™Œ PUSH VERT',
                'pull_horizontal': 'ðŸŽ¯ PULL ORIZZ',
                'pull_vertical': 'â¬†ï¸ PULL VERT',
                'rotation': 'ðŸŒ€ ROTAZIONE',
                'anti_rotation': 'ðŸ›¡ï¸ ANTI-ROT',
                'plyometric': 'âš¡ PLIOMETRIA',
                'locomotion': 'ðŸƒ LOCOMOTION',
                'isometric': 'ðŸ§˜ ISOMETRICI'
            };
            
            Object.keys(patterns).forEach(pattern => {
                const label = patternLabels[pattern] || pattern.toUpperCase();
                const exList = patterns[pattern].map(ex => {
                    const diff = ex.difficulty === 'advanced' ? 'âš ï¸' : ex.difficulty === 'intermediate' ? 'â—' : 'â—‹';
                    return `${diff}${ex.name}`;
                }).join(', ');
                lines.push(`${label}: ${exList}`);
            });
            
            lines.push('');
            lines.push('Legenda: â—‹=beginner â—=intermediate âš ï¸=advanced');
            
            return lines.join('\n');
        }

        function getAvailableWorkoutDays(schedule) {
            try {
                if (!schedule || typeof schedule !== 'object') return [];
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                const available = [];
                console.log('ðŸ“… Schedule per atleta:', schedule);
                for (const d of days) {
                    const v = String(schedule[d] || '').toLowerCase();
                    console.log(`   ${d}: "${v}" â†’ ${v === 'gr_available' || v === 'gr_perform' || v === 'both' ? 'âœ…' : 'âŒ'}`);
                    if (v === 'gr_available' || v === 'gr_perform' || v === 'both') available.push(d);
                }
                console.log('ðŸ“… Giorni disponibili per GR:', available);
                return available;
            } catch {
                return [];
            }
        }

        function formatCouncilOutputs(expertOutputs) {
            try {
                const eo = expertOutputs && typeof expertOutputs === 'object' ? expertOutputs : {};
                const order = [
                    ['strength', 'Coach Strength'],
                    ['recovery', 'Recovery Pro'],
                    ['technique', 'Tech Master'],
                    ['athletic', 'Coach Athletic'],
                    ['biomech', 'Dr. Biomech']
                ];
                const blocks = [];
                for (const [key, label] of order) {
                    const t = String(eo[key] || '').trim();
                    if (!t) continue;
                    const cleaned = stripMarkdownLite(t).replace(/\n{3,}/g, '\n\n');
                    blocks.push(`${label}: ${cleaned}`);
                }
                return blocks.join('\n\n');
            } catch {
                return '';
            }
        }

        function renderWeekWorkoutPicker() {
            const picker = document.getElementById('week-workout-picker');
            if (!picker) return;

            const workouts = currentWeekPlan?.workouts;
            if (!Array.isArray(workouts) || workouts.length <= 1) {
                picker.style.display = 'none';
                picker.innerHTML = '';
                return;
            }

            const dayLabel = {
                monday: 'LunedÃ¬',
                tuesday: 'MartedÃ¬',
                wednesday: 'MercoledÃ¬',
                thursday: 'GiovedÃ¬',
                friday: 'VenerdÃ¬',
                saturday: 'Sabato',
                sunday: 'Domenica'
            };

            picker.innerHTML = workouts.map((w, idx) => {
                const day = String(w?.day_of_week || '').toLowerCase();
                const title = String(w?.name || w?.title || `Workout ${idx + 1}`);
                const label = `${dayLabel[day] || day || 'Giorno'} â€” ${title}`;
                const selected = idx === selectedWorkoutIndex ? 'selected' : '';
                return `<option value="${idx}" ${selected}>${escapeHtml(label)}</option>`;
            }).join('');

            picker.onchange = () => {
                const idx = Number(picker.value);
                if (!Number.isFinite(idx)) return;
                selectWorkoutFromWeek(idx);
            };

            picker.style.display = 'block';
        }

        function selectWorkoutFromWeek(index) {
            const workouts = currentWeekPlan?.workouts;
            if (!Array.isArray(workouts) || workouts.length === 0) return;
            const idx = Math.max(0, Math.min(workouts.length - 1, Number(index) || 0));
            selectedWorkoutIndex = idx;

            const w = workouts[idx];
            currentWorkout.exercises = Array.isArray(w?.exercises) ? w.exercises : [];
            renderExercises();
            document.getElementById('workout-title').value = String(w?.name || w?.title || `Workout ${idx + 1}`);
            renderWeekWorkoutPicker();
        }

        function wearableSummary(wearableData) {
            if (!wearableData || !wearableData.hasData) return 'Nessun wearable connesso.';
            if (!wearableData.usable) return `Wearable presente ma dati troppo vecchi (${Math.round((wearableData.hoursAgo || 0) / 24)} giorni).`;
            const parts = [];
            if (wearableData.hrv) parts.push(`HRV ${wearableData.hrv}ms`);
            if (wearableData.sleep) parts.push(`Sonno ${wearableData.sleep}h`);
            if (wearableData.readiness) parts.push(`Readiness ${wearableData.readiness}/100`);
            const freshness = wearableData.status === 'stale' ? `dati di ${Math.round(wearableData.hoursAgo)}h fa` : 'dati freschi';
            return `Wearable (${freshness}): ${parts.join(', ') || 'dati parziali'}.`;
        }

        async function fetchExtraAthleteContext(athleteId) {
            const [sportData, schedule, goals] = await Promise.all([
                supabase.fetch('sport_specific_data', `?athlete_id=eq.${athleteId}`).then(r => (r && r[0]) ? r[0] : {}).catch(() => ({})),
                supabase.fetch('weekly_schedule', `?athlete_id=eq.${athleteId}`).then(r => (r && r[0]) ? r[0] : {}).catch(() => ({})),
                supabase.fetch('athlete_goals', `?athlete_id=eq.${athleteId}`).then(r => r || []).catch(() => ([]))
            ]);
            return { sportData, schedule, goals };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ðŸ“ˆ PROGRESS DATA FOR AI PROMPT
        // Raccoglie PR, obiettivi coach e storico peso per personalizzare il workout
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function fetchProgressDataForPrompt(athleteId) {
            const lines = [];
            
            try {
                // ðŸ† Personal Records (top 5 PR piÃ¹ rilevanti)
                let prs = [];
                try {
                    prs = await supabase.fetch('personal_records', 
                        `?athlete_id=eq.${athleteId}&select=exercise_name,weight_kg,reps,estimated_1rm&order=estimated_1rm.desc&limit=5`
                    );
                } catch (e) { /* tabella non esiste ancora */ }
                
                if (prs && prs.length > 0) {
                    const prList = prs.map(pr => 
                        `${pr.exercise_name}: ${pr.weight_kg}kg x ${pr.reps} (1RM: ~${Math.round(pr.estimated_1rm)}kg)`
                    ).join(', ');
                    lines.push(`ðŸ† PR Atleta: ${prList}`);
                }
                
                // ðŸŽ¯ Coach Goals (obiettivi attivi)
                let coachGoals = [];
                try {
                    coachGoals = await supabase.fetch('coach_goals', 
                        `?athlete_id=eq.${athleteId}&status=eq.active&select=goal_title,goal_type,current_value,target_value,unit,end_date&order=end_date.asc&limit=3`
                    );
                } catch (e) { /* tabella non esiste ancora */ }
                
                if (coachGoals && coachGoals.length > 0) {
                    const goalsText = coachGoals.map(g => {
                        const progress = Math.round((g.current_value / g.target_value) * 100);
                        const daysLeft = Math.ceil((new Date(g.end_date) - new Date()) / (1000 * 60 * 60 * 24));
                        return `${g.goal_title} (${progress}% completato, ${daysLeft > 0 ? daysLeft + ' giorni rimasti' : 'scaduto'})`;
                    }).join('; ');
                    lines.push(`ðŸŽ¯ Obiettivi Coach: ${goalsText}`);
                }
                
                // âš–ï¸ Weight trend (ultime 4 settimane)
                let weights = [];
                try {
                    weights = await supabase.fetch('weight_history', 
                        `?athlete_id=eq.${athleteId}&select=weight_kg,recorded_at&order=recorded_at.desc&limit=30`
                    );
                } catch (e) { /* tabella non esiste ancora */ }
                
                if (weights && weights.length > 0) {
                    const currentWeight = weights[0].weight_kg;
                    
                    // Calcola trend (prima settimana vs ultima settimana nei dati)
                    const oneWeekAgo = new Date();
                    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
                    
                    const recentWeights = weights.filter(w => new Date(w.recorded_at) >= oneWeekAgo);
                    const olderWeights = weights.filter(w => new Date(w.recorded_at) < oneWeekAgo).slice(0, 7);
                    
                    let trend = 'stabile';
                    if (recentWeights.length > 0 && olderWeights.length > 0) {
                        const recentAvg = recentWeights.reduce((s, w) => s + w.weight_kg, 0) / recentWeights.length;
                        const olderAvg = olderWeights.reduce((s, w) => s + w.weight_kg, 0) / olderWeights.length;
                        const diff = recentAvg - olderAvg;
                        
                        if (diff > 0.5) trend = `in aumento (+${diff.toFixed(1)}kg)`;
                        else if (diff < -0.5) trend = `in calo (${diff.toFixed(1)}kg)`;
                    }
                    
                    lines.push(`âš–ï¸ Peso: ${currentWeight}kg (${trend})`);
                }
                
            } catch (e) {
                console.warn('ðŸ“ˆ Error fetching progress data:', e);
            }
            
            return lines.length > 0 ? `ðŸ“ˆ PROGRESSI ATLETA:\n${lines.join('\n')}` : '';
        }

        async function generateWorkoutAI(phase, ctxText) {
            try {
                setExpertThinking('strength', true);
                const athleteName = `${selectedAthlete.first_name || ''} ${selectedAthlete.last_name || ''}`.trim();
                const stateHints = aiProgramState?.history?.last_titles?.length
                    ? `Storico titoli recenti (evita ripetizioni): ${aiProgramState.history.last_titles.slice(-6).join(' | ')}`
                    : '';

                const rulesetProfile = getRulesetProfile();
                const rulesetLine = `Ruleset (dipende dal cliente): ${formatRulesetProfile(rulesetProfile)}.`;
                const rulesetRules = rulesetProfile === 'conservative'
                    ? [
                        '- Profilo CONSERVATIVO: prioritÃ  sicurezza, qualitÃ  tecnica, progressioni lente; evita cedimento e movimenti troppo complessi.',
                        '- Mantieni volume moderato e intensitÃ  gestibile; privilegia esercizi stabili e cue chiari.'
                    ]
                    : rulesetProfile === 'aggressive'
                        ? [
                            '- Profilo AGGRESSIVO: spinta alta su intensitÃ /volume, MA senza sacrificare tecnica e senza picchi improvvisi.',
                            '- Evita comunque scelte rischiose se non supportate dal contesto (freschezza, esperienza, infortuni).'
                        ]
                        : [
                            '- Profilo BILANCIATO: progressioni sostenibili, tecnica alta, carico adeguato al contesto.'
                        ];

                // Training Methods Selection for single workout
                let trainingMethodsText = '';
                let advancedMethodsText = '';
                try {
                    if (window.MethodSelector && window.TRAINING_METHODS) {
                        const goalMap = { accumulo: 'massa', intensificazione: 'forza', peaking: 'performance', deload: 'definizione' };
                        const phaseKey = String(phase).toLowerCase();
                        const sportKey = String(selectedAthlete?.sport || '').toLowerCase();
                        const fatigueMatch = ctxText.match(/fatigue[:\s]+(\d+)/i);
                        const fatigueLevel = fatigueMatch ? parseInt(fatigueMatch[1]) : 5;
                        
                        const recommendations = window.MethodSelector.selectMethods({
                            goal: goalMap[phaseKey] || 'massa',
                            phase: phaseKey,
                            experience: String(selectedAthlete?.experience_level || 'intermediate').toLowerCase(),
                            fatigue: fatigueLevel,
                            time_available: 60,
                            equipment: ['barbell', 'dumbbells', 'cables', 'machines', 'bodyweight'],
                            sport: sportKey,
                            pain_areas: [],
                            rpe_tolerance: rulesetProfile === 'conservative' ? 6 : (rulesetProfile === 'aggressive' ? 9 : 7)
                        });
                        trainingMethodsText = window.MethodSelector.generatePromptSection(recommendations);
                        
                        // Advanced rules integration
                        if (window.AdvancedMethodSelector) {
                            const roleKey = String(selectedAthlete?.role || selectedAthlete?.position || '').toLowerCase().replace(/\s+/g, '_');
                            const selectedMethodKeys = recommendations.map(r => r.key);
                            
                            advancedMethodsText = window.AdvancedMethodSelector.generateAdvancedPromptSection({
                                sport: sportKey,
                                role: roleKey,
                                weekNumber: currentWeek,
                                selectedMethods: selectedMethodKeys,
                                planType: sportKey === 'palestra' ? 'standard_4_week' : 'sport_8_week'
                            });
                        }
                    }
                } catch (e) {
                    console.warn('Training methods selection failed:', e);
                }

                const prompt = [
                    'Genera UNA singola sessione (1 workout) per la fase indicata.',
                    'Deve essere compatibile con questa UI: solo una lista di esercizi con sets/reps/type.',
                    'Output: SOLO JSON valido, senza testo extra.',
                    '',
                    ctxText,
                    trainingMethodsText,
                    advancedMethodsText,
                    rulesetLine,
                    stateHints,
                    '',
                    'Schema JSON richiesto:',
                    '{',
                    '  "title": "Titolo workout",',
                    '  "exercises": [',
                    '    {"name":"A1: Goblet Squat (superset)","sets":3,"reps":"10-12","type":"hypertrophy"},',
                    '    {"name":"A2: Romanian Deadlift (superset)","sets":3,"reps":"10-12","type":"hypertrophy"},',
                    '    {"name":"B: Leg Curl (drop set)","sets":3,"reps":"12 + drop 8 + drop 6","type":"hypertrophy"}',
                    '  ],',
                    '  "coach_notes": "2-4 frasi incluse metodologie usate"',
                    '}',
                    '',
                    'Regole:',
                    '- 5-8 esercizi totali',
                    '- type deve essere: strength | hypertrophy | conditioning',
                    '- sets numero intero, reps stringa (es: "8-10" o "30s" o "12 + drop 8")',
                    '- Se usi metodologie speciali (superset, drop set, EMOM, ecc) indicale nel nome esercizio',
                    '- Usa prefissi A1/A2, B1/B2 per superset e gruppi',
                    ...rulesetRules,
                    lastCoachInstructions ? `- Indicazioni coach: ${lastCoachInstructions}` : ''
                ].filter(Boolean).join('\n');

                const { data, content } = await groqChat({
                    model: GROQ_MODELS.main,
                    temperature: 0.5,
                    max_tokens: 900,
                    messages: [
                        { role: 'system', content: `Sei un preparatore atletico d'elite italiano. Rispondi SOLO con JSON valido.` },
                        { role: 'user', content: prompt }
                    ]
                });

                const obj = parseAiJsonOrThrow(content, 'Workout singolo');
                if (!obj.exercises || !Array.isArray(obj.exercises) || obj.exercises.length === 0) {
                    throw new Error('JSON senza exercises');
                }

                const validation = validateWorkoutDraft(obj);
                if (validation.errors.length) {
                    logAIError('validation', new Error(validation.errors.join(' | ')), { phase, week: currentWeek });
                    throw new Error(`Workout non valido: ${validation.errors.join(' | ')}`);
                }
                if (validation.warnings.length) {
                    addAIMessageSafe('biomech', `Nota validazione: ${validation.warnings.join(' â€¢ ')}`, 'medium');
                }

                // Auto-fix esercizi con problemi comuni
                const fixedExercises = autoFixExercises(obj.exercises);
                
                // Calcola confidence score
                const confidence = calculateWorkoutConfidence({ ...obj, exercises: fixedExercises }, { phase });
                addAIDecision('chart-bar', `Confidence: ${confidence.score}%`, confidence.issues.join(', ') || 'Nessun problema');
                
                // Sanity checks
                const sanityChecks = sanityCheckWorkout({ ...obj, exercises: fixedExercises }, phase);
                for (const check of sanityChecks) {
                    if (check.level === 'error') {
                        addAIDecision('times-circle', check.msg, 'Errore sanity check');
                    } else if (check.level === 'warning') {
                        addAIDecision('exclamation-triangle', check.msg, 'Warning');
                    } else {
                        addAIDecision('info-circle', check.msg, 'Info');
                    }
                }

                // Log success
                logAISuccess('workout_generation', { phase, exerciseCount: fixedExercises.length, confidence: confidence.score });

                currentWorkout.exercises = fixedExercises.map(ex => ({
                    name: ex.name,
                    sets: Number(ex.sets || 3),
                    reps: String(ex.reps || '10'),
                    rest: String(ex.rest || '60s'),
                    type: String(ex.type || 'strength')
                }));

                renderExercises();
                
                // Titolo con confidence badge
                const titleBase = obj.title || `${phase} - Sett. ${currentWeek} - ${athleteName}`;
                document.getElementById('workout-title').value = titleBase;
                
                // Mostra confidence nel messaggio
                const confidenceEmoji = confidence.level === 'high' ? 'âœ…' : confidence.level === 'medium' ? 'âš ï¸' : 'âŒ';
                if (obj.coach_notes) {
                    addAIMessageSafe('strength', `${obj.coach_notes} ${confidenceEmoji} <small style="opacity:0.7">(${confidence.score}% confidence)</small>`, 'high');
                } else {
                    addAIMessageSafe('strength', `Workout generato ${confidenceEmoji} <small style="opacity:0.7">(${confidence.score}% confidence)</small>`, 'high');
                }

                // Traceability pack for spacecraft-level debugging
                const workoutHash = hashString(JSON.stringify(currentWorkout.exercises));
                lastAiRun = {
                    id: crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    created_at: nowIso(),
                    model_main: GROQ_MODELS.main,
                    model_fast: GROQ_MODELS.fast,
                    model_review: GROQ_MODELS.review,
                    prompt,
                    ctxText,
                    raw: data,
                    parsed: obj,
                    workout_hash: workoutHash,
                    expert_outputs: lastAiRun?.expert_outputs || {},
                    wearable: latestWearableData || null
                };

                // Lightweight reviewer pass (best-effort). If it fails, we still allow coach to proceed.
                try {
                    const review = await reviewWorkoutAI(ctxText, obj);
                    lastAiRun.review = review;
                    if (review?.risk === 'high') {
                        addAIMessageSafe('recovery', `<i class="fas fa-triangle-exclamation" aria-hidden="true"></i> Review sicurezza: RISCHIO ALTO. ${review.notes || ''}`.trim(), 'medium');
                    } else if (review?.risk === 'medium') {
                        addAIMessageSafe('recovery', `Review: rischio medio. ${review.notes || ''}`.trim(), 'medium');
                    } else if (review?.notes) {
                        addAIMessageSafe('recovery', `Review ok. ${review.notes}`.trim(), 'high');
                    }
                } catch {
                    // ignore
                }

                // Persist memory (best-effort)
                await saveAIProgramState(selectedAthlete.id, {
                    history: {
                        last_phase: phase,
                        last_week: currentWeek,
                        recent_workout_hashes: (aiProgramState?.history?.recent_workout_hashes || []).concat([workoutHash]).slice(-12),
                        last_titles: (aiProgramState?.history?.last_titles || []).concat([String(obj.title || '')]).filter(Boolean).slice(-12)
                    },
                    last_context: {
                        last_coach_instructions: String(lastCoachInstructions || ''),
                        last_wearable_summary: wearableSummary(latestWearableData)
                    }
                });
            } catch (e) {
                console.error('AI workout generation failed:', e);
                addAIMessageSafe('strength', `<i class="fas fa-triangle-exclamation" aria-hidden="true"></i> Generazione AI fallita, uso fallback (${String(e.message || e)}).`, 'medium');
                generateWorkoutFallback(phase);
            } finally {
                setExpertThinking('strength', false);
            }
        }

        function validateWorkoutDraft(obj) {
            const errors = [];
            const warnings = [];
            const exs = Array.isArray(obj?.exercises) ? obj.exercises : [];

            if (!obj || typeof obj !== 'object') errors.push('Oggetto JSON mancante');
            if (!obj?.title || String(obj.title).trim().length < 3) warnings.push('Titolo mancante o troppo corto');
            if (exs.length < 5) errors.push('Meno di 5 esercizi');
            if (exs.length > 10) warnings.push('PiÃ¹ di 10 esercizi (rischio durata eccessiva)');

            const allowedTypes = new Set(['strength', 'hypertrophy', 'conditioning']);
            const seen = new Set();
            for (const ex of exs) {
                const name = String(ex?.name || '').trim();
                if (!name) errors.push('Esercizio senza name');
                const key = name.toLowerCase();
                if (name) {
                    if (seen.has(key)) warnings.push(`Duplicato: ${name}`);
                    seen.add(key);
                }

                const sets = Number(ex?.sets);
                if (!Number.isFinite(sets) || sets < 1 || sets > 10) errors.push(`Sets non valido per ${name || 'esercizio'} (1-10)`);

                const reps = String(ex?.reps || '').trim();
                if (!reps) errors.push(`Reps mancanti per ${name || 'esercizio'}`);
                if (reps.length > 24) warnings.push(`Reps troppo lunga per ${name || 'esercizio'}`);

                const type = String(ex?.type || '').trim();
                if (!allowedTypes.has(type)) errors.push(`Type non valido per ${name || 'esercizio'} (${type})`);
            }

            // Anti-repeat heuristic: if we just generated an identical workout recently, warn.
            try {
                const h = hashString(JSON.stringify(exs));
                const recent = aiProgramState?.history?.recent_workout_hashes || [];
                if (recent.includes(h)) warnings.push('Workout potenzialmente ripetuto (hash giÃ  visto)');
            } catch {
                // ignore
            }

            return { errors, warnings };
        }

        async function reviewWorkoutAI(ctxText, workoutObj) {
            const prompt = [
                'Sei un revisore clinico/preparatore. Valuta rischio infortunio e coerenza con contesto.',
                'Rispondi SOLO JSON valido, senza testo extra.',
                '',
                'Output schema:',
                '{"risk":"low|medium|high","notes":"string","must_fix":["..."],"nice_to_have":["..."]}',
                '',
                'Contesto:',
                ctxText,
                '',
                'Workout JSON:',
                JSON.stringify(workoutObj)
            ].join('\n');

            const { content } = await groqChat({
                model: GROQ_MODELS.review,
                temperature: 0.2,
                max_tokens: 450,
                messages: [
                    { role: 'system', content: 'Sei un reviewer severo. Output SOLO JSON.' },
                    { role: 'user', content: prompt }
                ]
            });

            const obj = parseAiJsonOrThrow(content, 'Review');
            const risk = String(obj?.risk || '').toLowerCase();
            if (!['low', 'medium', 'high'].includes(risk)) {
                obj.risk = 'medium';
            }
            return obj;
        }

        async function fetchTelemetryContext(athleteId) {
            const out = { sessions: [], weekly: null, workoutNameById: {} };
            if (!athleteId) return out;

            const sessions = await supabase.fetch(
                'workout_session_feedback',
                `?athlete_id=eq.${athleteId}&order=completed_at.desc&limit=6&select=workout_id,completed_at,duration_minutes,rpe,feeling,notes,completed_sets,total_sets`
            );
            out.sessions = Array.isArray(sessions) ? sessions : [];

            const weeklyRows = await supabase.fetch(
                'weekly_feedback',
                `?athlete_id=eq.${athleteId}&order=submitted_at.desc&limit=1&select=submitted_at,week_number,fatigue_level,stress_level,sleep_quality,sleep_hours,motivation_level,nutrition_quality,readiness_score,pain_areas,pain_notes,preferences`
            );
            out.weekly = Array.isArray(weeklyRows) && weeklyRows.length > 0 ? weeklyRows[0] : null;

            const workoutIds = Array.from(new Set(out.sessions.map(s => s?.workout_id).filter(Boolean))).slice(0, 6);
            if (workoutIds.length > 0) {
                const inList = workoutIds.join(',');
                const workouts = await supabase.fetch('workouts', `?id=in.(${inList})&select=id,name`);
                (Array.isArray(workouts) ? workouts : []).forEach(w => {
                    if (w?.id) out.workoutNameById[w.id] = w.name;
                });
            }

            return out;
        }

        function formatTelemetryContext(telemetry) {
            try {
                const sessions = Array.isArray(telemetry?.sessions) ? telemetry.sessions : [];
                const weekly = telemetry?.weekly || null;
                const names = telemetry?.workoutNameById || {};

                const lines = [];

                if (sessions.length > 0) {
                    lines.push('TELEMETRIA (ultime sessioni):');
                    for (const s of sessions.slice(0, 6)) {
                        const d = s?.completed_at ? new Date(s.completed_at) : null;
                        const dateStr = d && !Number.isNaN(d.getTime()) ? d.toISOString().slice(0, 10) : 'N/A';
                        const name = (s?.workout_id && names[s.workout_id])
                            ? names[s.workout_id]
                            : (s?.workout_id ? String(s.workout_id).slice(0, 8) : 'N/A');

                        const mins = s?.duration_minutes != null ? Number(s.duration_minutes) : null;
                        const rpe = s?.rpe != null ? Number(s.rpe) : null;
                        const feeling = s?.feeling != null ? Number(s.feeling) : null;
                        const cs = s?.completed_sets != null ? Number(s.completed_sets) : null;
                        const ts = s?.total_sets != null ? Number(s.total_sets) : null;

                        const noteRaw = String(s?.notes || '').trim();
                        const note = noteRaw.length > 0 ? (noteRaw.length > 140 ? `${noteRaw.slice(0, 140)}â€¦` : noteRaw) : '';

                        lines.push(
                            `- ${dateStr} | ${name} | ${Number.isFinite(mins) ? `${mins}m` : 'm?'} | RPE ${Number.isFinite(rpe) ? rpe : '?'} | Feeling ${Number.isFinite(feeling) ? feeling : '?'} | Set ${Number.isFinite(cs) ? cs : '?'}/${Number.isFinite(ts) ? ts : '?'}${note ? ` | Note: ${note}` : ''}`
                        );
                    }
                }

                if (weekly) {
                    const wParts = [];
                    if (weekly.week_number != null && String(weekly.week_number).trim() !== '') wParts.push(`week ${weekly.week_number}`);
                    if (weekly.readiness_score != null) wParts.push(`readiness ${weekly.readiness_score}/10`);
                    if (weekly.fatigue_level != null) wParts.push(`fatigue ${weekly.fatigue_level}/10`);
                    if (weekly.stress_level != null) wParts.push(`stress ${weekly.stress_level}/10`);
                    if (weekly.sleep_quality != null) wParts.push(`sleepQ ${weekly.sleep_quality}/5`);
                    if (weekly.sleep_hours != null) wParts.push(`sleepH ${weekly.sleep_hours}`);
                    if (weekly.motivation_level != null) wParts.push(`motivation ${weekly.motivation_level}/10`);
                    if (weekly.nutrition_quality != null) wParts.push(`nutrition ${weekly.nutrition_quality}/5`);

                    const painAreas = Array.isArray(weekly.pain_areas) ? weekly.pain_areas.filter(Boolean) : [];
                    const painNotesRaw = String(weekly.pain_notes || '').trim();
                    const painNotes = painNotesRaw.length > 0 ? (painNotesRaw.length > 180 ? `${painNotesRaw.slice(0, 180)}â€¦` : painNotesRaw) : '';

                    const prefs = weekly.preferences && typeof weekly.preferences === 'object' ? JSON.stringify(weekly.preferences) : '';
                    const prefsShort = prefs.length > 220 ? `${prefs.slice(0, 220)}â€¦` : prefs;

                    lines.push(
                        [
                            'REPORT SETTIMANALE (ultimo):',
                            wParts.join(' | '),
                            painAreas.length > 0 ? `pain areas: ${painAreas.join(', ')}` : '',
                            painNotes ? `pain notes: ${painNotes}` : '',
                            prefsShort ? `prefs: ${prefsShort}` : ''
                        ].filter(Boolean).join(' ')
                    );
                }

                return lines.join('\n').trim();
            } catch {
                return '';
            }
        }

        // AI CONSULTATION (real)
        async function startConsultation(phase, avgRpe, compliance, wearableData = null) {
            const messages = document.getElementById('messages');
            messages.innerHTML = '';
            setWorkflowStep(2);

            const athleteName = `${selectedAthlete.first_name || ''} ${selectedAthlete.last_name || ''}`.trim();
            let extra = { sportData: {}, schedule: {}, goals: [] };
            try {
                extra = await fetchExtraAthleteContext(selectedAthlete.id);
            } catch {
                // ignore
            }

            let telemetryText = '';
            try {
                const telemetry = await fetchTelemetryContext(selectedAthlete.id);
                telemetryText = formatTelemetryContext(telemetry);
            } catch {
                telemetryText = '';
            }

            const goalsText = (extra.goals || []).map(g => g.goal_name).filter(Boolean).slice(0, 5).join(', ');
            const memoryText = aiProgramState?.history?.last_phase
                ? `Memoria: ultima fase=${aiProgramState.history.last_phase}, ultima sett=${aiProgramState.history.last_week || 'N/A'}.`
                : '';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ðŸ“ˆ PROGRESS DATA - PR, Obiettivi Coach, Peso
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let progressDataText = '';
            try {
                progressDataText = await fetchProgressDataForPrompt(selectedAthlete.id);
            } catch (e) {
                console.warn('ðŸ“ˆ Progress data fetch failed:', e);
            }

            const scheduleText = formatScheduleAvailability(extra.schedule);
            const availableDays = getAvailableWorkoutDays(extra.schedule);
            const maxSessions = extra.schedule?.max_gr_sessions_per_week != null ? Number(extra.schedule.max_gr_sessions_per_week) : null;

            const anamnesisText = formatAnamnesisContext(aiProgramState);

            const rulesetProfile = getRulesetProfile();

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ðŸ“… WEEK CONTEXT ENGINE - Calcolo automatico MD-x
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let weekContextResult = null;
            let weekContextText = '';
            
            try {
                if (window.WeekContextEngine) {
                    console.log('ðŸ“… WeekContextEngine: Analisi contesto settimanale...');
                    
                    // Recupera eventi dal calendario
                    const cal = getCalendarActive(selectedAthlete.id);
                    const events = cal?.events || [];
                    
                    weekContextResult = await window.WeekContextEngine.analyze(selectedAthlete, events);
                    
                    if (weekContextResult) {
                        weekContextText = weekContextResult.forPrompt;
                        
                        // Log nel AI Decision panel
                        addAIDecision('calendar', `Fase: ${weekContextResult.phase?.label || 'Standard'}`, 
                            weekContextResult.md?.mdLabel || 'N/A');
                        
                        if (weekContextResult.nextEvent) {
                            addAIDecision('flag-checkered', 
                                `Prossimo evento: ${weekContextResult.nextEvent.name}`,
                                `${weekContextResult.nextEvent.daysUntil} giorni`);
                        }
                        
                        console.log('ðŸ“… WeekContextEngine result:', weekContextResult);
                    }
                }
            } catch (e) {
                console.warn('ðŸ“… WeekContextEngine failed:', e);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ðŸ“Š EXTERNAL LOAD TRACKER - Carico allenamenti squadra/sport
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let externalLoadResult = null;
            let externalLoadText = '';
            
            try {
                if (window.ExternalLoadTracker) {
                    console.log('ðŸ“Š ExternalLoadTracker: Analisi carico esterno...');
                    
                    // Stima carico dal calendario
                    const cal = getCalendarActive(selectedAthlete.id);
                    const events = cal?.events || [];
                    const estimates = window.ExternalLoadTracker.estimateFromCalendar(events, selectedAthlete.id);
                    
                    // Registra automaticamente le stime dal calendario
                    for (const estimate of estimates) {
                        // Evita duplicati controllando se giÃ  esiste
                        const history = window.ExternalLoadTracker.getAthleteHistory(selectedAthlete.id);
                        const exists = history.some(h => 
                            h.date === estimate.date && 
                            h.type === estimate.type && 
                            h.fromCalendar
                        );
                        if (!exists && estimate.load > 0) {
                            window.ExternalLoadTracker.logSession(selectedAthlete.id, estimate);
                        }
                    }
                    
                    // Analizza ultimi 7 giorni
                    externalLoadResult = window.ExternalLoadTracker.analyze(selectedAthlete.id, 7);
                    
                    if (externalLoadResult && externalLoadResult.forPrompt) {
                        externalLoadText = externalLoadResult.forPrompt;
                        
                        // Log warnings nel AI Decision panel
                        if (externalLoadResult.recommendations?.warnings?.length > 0) {
                            externalLoadResult.recommendations.warnings.forEach(w => {
                                addAIDecision('running', w.replace(/[âš ï¸ðŸ“ŠðŸƒðŸ“ˆðŸ”¥]/g, '').trim(), 'External Load');
                            });
                        }
                        
                        // Log modificatori
                        if (externalLoadResult.recommendations?.volumeModifier < 1) {
                            addAIDecision('chart-line', 
                                `Volume ridotto a ${Math.round(externalLoadResult.recommendations.volumeModifier * 100)}%`,
                                'Per carico esterno');
                        }
                        
                        console.log('ðŸ“Š ExternalLoadTracker result:', externalLoadResult);
                    }
                }
            } catch (e) {
                console.warn('ðŸ“Š ExternalLoadTracker failed:', e);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ðŸ§  DYNAMIC FATIGUE MODEL - Fatica multi-dimensionale
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let fatigueModelResult = null;
            let fatigueModelText = '';
            
            try {
                if (window.DynamicFatigueModel) {
                    console.log('ðŸ§  DynamicFatigueModel: Analyzing multi-dimensional fatigue...');
                    
                    // Inizializza per l'atleta
                    DynamicFatigueModel.initialize(selectedAthlete?.id || 'default', {
                        age: selectedAthlete?.age
                    });
                    
                    // Ottieni workout precedenti dall'history
                    let previousWorkouts = [];
                    if (window.WorkoutHistory && selectedAthlete?.id) {
                        const allHistory = window.WorkoutHistory.getAll();
                        const athleteHistory = allHistory[selectedAthlete.id] || [];
                        previousWorkouts = athleteHistory
                            .sort((a, b) => b.weekNumber - a.weekNumber)
                            .slice(0, 4) // Ultime 4 settimane
                            .map(h => h.workout)
                            .filter(w => w);
                    }
                    
                    // Se abbiamo workout precedenti, stimiamo la fatica
                    if (previousWorkouts && previousWorkouts.length > 0) {
                        console.log(`ðŸ§  Estimating fatigue from ${previousWorkouts.length} previous workouts`);
                        DynamicFatigueModel.estimateFromWorkoutHistory(previousWorkouts);
                    }
                    
                    // Integra dati wearable se disponibili
                    if (wearableData?.data?.hrv || wearableData?.data?.sleepScore) {
                        // Modifica fattori individuali basandosi su wearable
                        const sleepQuality = wearableData.data.sleepScore 
                            ? wearableData.data.sleepScore / 100 
                            : 1.0;
                        DynamicFatigueModel.config.individualFactors.sleepQuality = sleepQuality;
                        
                        // HRV basso = recupero piÃ¹ lento
                        if (wearableData.data.hrv && wearableData.data.hrv < 40) {
                            DynamicFatigueModel.config.individualFactors.recoveryRate *= 0.85;
                        }
                    }
                    
                    // Ottieni stato completo
                    fatigueModelResult = DynamicFatigueModel.getFullStatus();
                    
                    if (fatigueModelResult) {
                        fatigueModelText = DynamicFatigueModel.formatForPrompt();
                        
                        // Add AI decisions
                        addAIDecision('brain', 
                            `Fatica Totale: ${fatigueModelResult.total}% - Status: ${fatigueModelResult.status}`,
                            'Modello multi-dimensionale');
                        
                        // Log alerts
                        if (fatigueModelResult.alerts.length > 0) {
                            fatigueModelResult.alerts.forEach(alert => {
                                addAIDecision(
                                    alert.type === 'danger' ? 'exclamation-triangle' : 'exclamation-circle',
                                    alert.message,
                                    `Fatigue Alert: ${alert.dimension}`
                                );
                            });
                        }
                        
                        // Log readiness
                        addAIDecision('battery-full', 
                            `Readiness Score: ${fatigueModelResult.readinessScore}%`,
                            'Prontezza stimata');
                        
                        // Log recommendations
                        const recs = fatigueModelResult.recommendations;
                        if (recs.volumeModifier < 1) {
                            addAIDecision('volume-down', 
                                `Volume raccomandato: ${Math.round(recs.volumeModifier * 100)}%`,
                                'Basato su fatica accumulata');
                        }
                        if (recs.avoidMuscleGroups.length > 0) {
                            addAIDecision('ban', 
                                `Evitare: ${recs.avoidMuscleGroups.join(', ')}`,
                                'Gruppi muscolari affaticati');
                        }
                        
                        console.log('ðŸ§  DynamicFatigueModel result:', fatigueModelResult);
                    }
                }
            } catch (e) {
                console.warn('ðŸ§  DynamicFatigueModel failed:', e);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ðŸ§  RATIONALE ENGINE - Il cervello che ragiona come un coach
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let rationaleResult = null;
            let rationaleText = '';
            
            try {
                if (window.RationaleEngine) {
                    // Use WeekContextEngine data if available, otherwise calculate manually
                    let weekContext;
                    
                    if (weekContextResult) {
                        // Use pre-calculated data from WeekContextEngine
                        weekContext = {
                            matchDay: weekContextResult.nextEvent?.date || null,
                            daysToMatch: weekContextResult.md?.daysToMatch,
                            daysFromMatch: weekContextResult.md?.daysFromMatch,
                            phase: weekContextResult.phase?.phase || phase,
                            weekNumber: weekContextResult.weekNumber || currentWeek,
                            mesocycle: phase?.toLowerCase() || 'accumulation',
                            // Enhanced data from WeekContextEngine
                            phaseLabel: weekContextResult.phase?.label,
                            volumeModifier: weekContextResult.recommendations?.volumeModifier,
                            intensityModifier: weekContextResult.recommendations?.intensityModifier,
                            sessionType: weekContextResult.recommendations?.sessionType,
                            focusAreas: weekContextResult.recommendations?.focusAreas || [],
                            avoidAreas: weekContextResult.recommendations?.avoidAreas || []
                        };
                    } else {
                        // Fallback: calculate manually
                        const cal = getCalendarActive(selectedAthlete.id);
                        const activeEvent = getActiveEventFromCalendar(cal);
                        let daysToMatch = null;
                        let daysFromMatch = null;
                        
                        if (activeEvent?.date) {
                            const evDate = parseDateOnly(activeEvent.date);
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            if (evDate) {
                                evDate.setHours(0, 0, 0, 0);
                                const diffDays = Math.round((evDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                                if (diffDays >= 0) {
                                    daysToMatch = diffDays;
                                } else {
                                    daysFromMatch = Math.abs(diffDays);
                                }
                            }
                        }
                        
                        weekContext = {
                            matchDay: activeEvent?.date || null,
                            daysToMatch,
                            daysFromMatch,
                            phase,
                            weekNumber: currentWeek,
                            mesocycle: phase?.toLowerCase() || 'accumulation'
                        };
                    }
                    
                    const todayContext = {
                        dayOfWeek: new Date().toLocaleDateString('it-IT', { weekday: 'long' }),
                        sleep: wearableData?.sleep ? { hours: wearableData.sleep, quality: wearableData.sleep >= 7 ? 'good' : 'fair' } : null,
                        stress: aiProgramState?.telemetry?.stress_level || 5,
                        readiness: wearableData?.readiness || 70,
                        compliance: compliance,
                        acwr: aiProgramState?.telemetry?.acwr || 1.0,
                        soreness: aiProgramState?.anamnesis?.injuries?.filter(i => i.status === 'active').map(i => ({
                            location: i.area || i.location,
                            severity: i.severity || 5
                        })) || []
                    };
                    
                    rationaleResult = await window.RationaleEngine.reason(
                        selectedAthlete,
                        extra.sportData,
                        weekContext,
                        todayContext
                    );
                    
                    if (rationaleResult) {
                        rationaleText = rationaleResult.forPrompt;
                        
                        // Log decision to AI Decision panel
                        addAIDecision('brain', `Decisione: ${rationaleResult.forUI?.summary?.decision || 'Standard'}`, 
                            `${rationaleResult.forUI?.summary?.confidence || 80}% confidence`);
                        
                        // Log key factors
                        if (rationaleResult.forUI?.keyFactors?.length > 0) {
                            rationaleResult.forUI.keyFactors.forEach(f => {
                                addAIDecision('info-circle', f.text, f.priority);
                            });
                        }
                        
                        // Log modifications
                        if (rationaleResult.modifications?.length > 0) {
                            rationaleResult.modifications.forEach(m => {
                                addAIDecision('wrench', m, 'Modifica applicata');
                            });
                        }
                        
                        // Show rationale in UI
                        displayRationaleCard(rationaleResult.forUI);
                        
                        console.log('ðŸ§  RationaleEngine result:', rationaleResult);
                    }
                }
            } catch (e) {
                console.warn('ðŸ§  RationaleEngine failed:', e);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 110/100 SUPERHUMAN AI CONTEXT
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let feedbackLearnerText = '';
            let rpePredicorText = '';
            let crossAthleteText = '';
            let adaptiveLoadText = '';
            let recoveryText = '';
            let quickReadinessText = '';

            try {
                if (window.FeedbackLearner) {
                    feedbackLearnerText = window.FeedbackLearner.generatePromptSection(selectedAthlete.id);
                }
            } catch (e) { console.warn('FeedbackLearner failed:', e); }

            try {
                if (window.QuickReadinessCheck) {
                    quickReadinessText = window.QuickReadinessCheck.generatePromptSection(selectedAthlete.id);
                }
            } catch (e) { console.warn('QuickReadinessCheck failed:', e); }

            try {
                if (window.RPEPredictor) {
                    const readinessData = getCurrentReadinessContext();
                    const predictionContext = {
                        athleteId: selectedAthlete.id,
                        phase,
                        weekNumber: currentWeek,
                        avgVolume: 'moderate',
                        sleepQuality: wearableData?.sleep >= 7 ? 'good' : wearableData?.sleep >= 5 ? 'fair' : 'poor',
                        stressLevel: aiProgramState?.telemetry?.stress_level > 6 ? 'high' : aiProgramState?.telemetry?.stress_level > 4 ? 'moderate' : 'low',
                        readiness: readinessData?.scores?.overall || wearableData?.readiness || 70
                    };
                    rpePredicorText = window.RPEPredictor.generatePromptSection(selectedAthlete.id, predictionContext);
                }
            } catch (e) { console.warn('RPEPredictor failed:', e); }

            try {
                if (window.CrossAthleteIntelligence) {
                    crossAthleteText = window.CrossAthleteIntelligence.generatePromptSection(
                        selectedAthlete.sport,
                        selectedAthlete.experience_level,
                        aiProgramState?.anamnesis?.pillars?.primary_goal,
                        phase
                    );
                }
            } catch (e) { console.warn('CrossAthleteIntelligence failed:', e); }

            try {
                if (window.AdaptiveLoadOptimizer) {
                    adaptiveLoadText = window.AdaptiveLoadOptimizer.generatePromptSection(
                        selectedAthlete.id,
                        selectedAthlete.sport,
                        phase
                    );
                }
            } catch (e) { console.warn('AdaptiveLoadOptimizer failed:', e); }

            try {
                if (window.RecoveryPrescriptor) {
                    const recoveryContext = {
                        athleteId: selectedAthlete.id,
                        fatigue: wearableData?.readiness ? (100 - wearableData.readiness) : 50,
                        soreness: aiProgramState?.anamnesis?.injuries?.map(i => i.area) || [],
                        stress: aiProgramState?.telemetry?.stress_level || 5,
                        sleep: wearableData?.sleep || 7,
                        readiness: wearableData?.readiness || 70,
                        phase
                    };
                    recoveryText = window.RecoveryPrescriptor.generatePromptSection(selectedAthlete.id, recoveryContext);
                }
            } catch (e) { console.warn('RecoveryPrescriptor failed:', e); }

            const ctxText = [
                `ATLETA: ${athleteName}`,
                `Sport: ${selectedAthlete.sport || 'N/A'} | Livello: ${selectedAthlete.experience_level || 'N/A'}`,
                `Settimana: ${currentWeek}/8 | Fase: ${phase}`,
                `Ruleset: ${formatRulesetProfile(rulesetProfile)}`,
                `RPE medio: ${avgRpe} | Compliance: ${compliance}%`,
                wearableSummary(wearableData),
                telemetryText,
                scheduleText,
                (() => {
                    try {
                        const ne = getNextEventActive(selectedAthlete.id);
                        return formatNextEventContext(ne, selectedAthlete);
                    } catch {
                        return '';
                    }
                })(),
                anamnesisText,
                // ðŸ“… WEEK CONTEXT ENGINE - MD-x
                weekContextText,
                // ðŸ“Š EXTERNAL LOAD TRACKER - Carico squadra/sport
                externalLoadText,
                // ðŸ§  DYNAMIC FATIGUE MODEL - Fatica multi-dimensionale
                fatigueModelText,
                // ðŸ§  RATIONALE ENGINE CONTEXT
                rationaleText,
                // 110/100 SUPERHUMAN CONTEXT
                feedbackLearnerText,
                quickReadinessText,
                rpePredicorText,
                crossAthleteText,
                adaptiveLoadText,
                recoveryText,
                // ðŸ“ˆ PROGRESS DATA - PR, Obiettivi, Peso
                progressDataText,
                'VINCOLI: non inventare numeri (RPE/minuti/date) non presenti nel contesto. Se mancano dati, scrivi N/A. Non usare date di calendario eccetto quelle esplicitamente fornite nel contesto (es. data partita).',
                memoryText,
                goalsText ? `Obiettivi: ${goalsText}` : '',
                extra.schedule?.max_gr_sessions_per_week ? `Sessioni GR/sett: ${extra.schedule.max_gr_sessions_per_week}` : '',
                lastCoachInstructions ? `Indicazioni coach: ${lastCoachInstructions}` : ''
            ].filter(Boolean).join('\n');

            lastAiRun = {
                id: crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                created_at: nowIso(),
                ctxText,
                expert_outputs: {},
                wearable: wearableData || null
            };

            const expertSpecs = [
                {
                    key: 'strength',
                    system: [
                        'Sei Coach Strength. Dai indicazioni pratiche su carichi, serie/ripetizioni, selezione esercizi e progressioni sicure.',
                        'Vincoli: NON usare markdown, NON inventare numeri/date non presenti nel contesto.',
                        'Non proporre "pugilato"/"tecnica boxe" come esercizi di forza: se citi skill boxing, mettila come nota separata e breve.',
                        'Se mancano dati scrivi N/A. Rispondi in italiano in 5-7 righe.'
                    ].join(' '),
                    confidence: 'high'
                },
                {
                    key: 'recovery',
                    system: [
                        'Sei Recovery Pro. Valuti fatica/recupero e proponi adattamenti di volume/intensitÃ  e prevenzione infortuni.',
                        'Vincoli: NON usare markdown, NON inventare numeri/date. Se citi RPE/minuti, devono essere nel contesto.',
                        'Rispondi in italiano in 5-7 righe.'
                    ].join(' '),
                    confidence: wearableData?.usable ? 'high' : 'medium'
                },
                {
                    key: 'technique',
                    system: [
                        'Sei Tech Master. Dai cue tecnici e scegli esercizi con alta qualitÃ  del movimento e basso rischio.',
                        'Vincoli: NON usare markdown, NON inventare numeri/date. Se mancano dati scrivi N/A.',
                        'Rispondi in italiano in 5-7 righe.'
                    ].join(' '),
                    confidence: 'medium'
                },
                {
                    key: 'athletic',
                    system: [
                        'Sei Coach Athletic. Proponi lavoro di sprint/potenza/condizionamento e prevenzione, coerente con giorni disponibili.',
                        'Vincoli: NON usare markdown, NON inventare date di calendario. Usa solo giorni della settimana se necessario.',
                        'Se mancano dati scrivi N/A. Rispondi in italiano in 5-7 righe.'
                    ].join(' '),
                    confidence: 'medium'
                },
                {
                    key: 'biomech',
                    system: [
                        'Sei Dr. Biomech. Evidenzi rischi biomeccanici e proponi alternative piÃ¹ sicure.',
                        'Vincoli: NON usare markdown, NON inventare numeri/date. Se citi RPE/dolori, devono essere nel contesto.',
                        'Rispondi in italiano in 5-7 righe.'
                    ].join(' '),
                    confidence: 'medium'
                }
            ];

            // Ensure we always capture expert outputs for the final generation step
            if (!lastAiRun || typeof lastAiRun !== 'object') lastAiRun = {};
            if (!lastAiRun.expert_outputs || typeof lastAiRun.expert_outputs !== 'object') lastAiRun.expert_outputs = {};

            // One-call council (prevents 429), still renders as 5 separate expert messages
            const expertKeys = expertSpecs.map(s => s.key);
            for (const k of expertKeys) setExpertThinking(k, true);
            try {
                const councilSystem = [
                    'Sei un CONSIGLIO di 5 esperti: Coach Strength, Recovery Pro, Tech Master, Coach Athletic, Dr. Biomech.',
                    'Devi rispondere SOLO con JSON valido: {"strength":"...","recovery":"...","technique":"...","athletic":"...","biomech":"..."}.',
                    'Ogni valore Ã¨ testo in italiano (5-7 righe), niente markdown.',
                    'VINCOLI: NON inventare numeri/date non presenti nel contesto. Se mancano dati scrivi N/A.'
                ].join(' ');

                const { content } = await groqChat({
                    model: GROQ_MODELS.fast,
                    temperature: 0.25,
                    max_tokens: 900,
                    messages: [
                        { role: 'system', content: councilSystem },
                        { role: 'user', content: ctxText }
                    ]
                });

                const parsed = parseAiJsonOrThrow(content, 'Consiglio esperti');
                for (const spec of expertSpecs) {
                    const msg = parsed && typeof parsed === 'object' ? String(parsed[spec.key] || '').trim() : '';
                    const finalMsg = msg || `N/A (risposta non disponibile).`;
                    if (lastAiRun && lastAiRun.expert_outputs) lastAiRun.expert_outputs[spec.key] = finalMsg;
                    addAIMessageSafe(spec.key, finalMsg, spec.confidence);
                }
            } catch (e) {
                for (const spec of expertSpecs) {
                    addAIMessageSafe(spec.key, `AI non disponibile (${String(e.message || e)}).`, 'medium');
                }
            } finally {
                for (const k of expertKeys) setExpertThinking(k, false);
            }

            setWorkflowStep(3);
            const councilText = formatCouncilOutputs(lastAiRun?.expert_outputs);
            const ctxForGen = [
                ctxText,
                councilText ? `\n\nCONSIGLI ESPERTI (da integrare e rendere coerenti):\n${councilText}` : '',
                availableDays.length ? `\n\nGIORNI DISPONIBILI (usa SOLO questi): ${availableDays.join(', ')}` : ''
            ].filter(Boolean).join('\n');

            await generateWeekAI(phase, ctxForGen, {
                availableDays,
                maxSessions: Number.isFinite(maxSessions) ? maxSessions : null
            });
        }

        async function generateWeekAI(phase, ctxText, { availableDays = [], maxSessions = null } = {}) {
            try {
                setExpertThinking('strength', true);
                const athleteName = `${selectedAthlete.first_name || ''} ${selectedAthlete.last_name || ''}`.trim();

                const focusPct = aiProgramState?.anamnesis?.pillars?.focus_percentages && typeof aiProgramState.anamnesis.pillars.focus_percentages === 'object'
                    ? aiProgramState.anamnesis.pillars.focus_percentages
                    : null;
                const focusStrengthPct = focusPct?.strength != null ? Number(focusPct.strength) : null;
                const focusPrimary = focusPct
                    ? Object.entries(focusPct)
                        .map(([k, v]) => [k, Number(v)])
                        .filter(([, v]) => Number.isFinite(v))
                        .sort((a, b) => b[1] - a[1])
                        .map(([k]) => k)[0]
                    : '';

                const lib = getExerciseLibrary(selectedAthlete?.sport, focusPrimary);
                
                // Use ExerciseLibraryV2 with injury filtering if available
                const athleteInjuries = aiProgramState?.anamnesis?.injuries || [];
                let libText;
                if (typeof window.ExerciseLibraryV2 !== 'undefined' && athleteInjuries.length > 0) {
                    libText = formatExerciseLibraryV2Safe(selectedAthlete?.sport, athleteInjuries);
                    console.log('ðŸ“š Using ExerciseLibraryV2 with injury filtering');
                } else if (typeof window.ExerciseLibraryV2 !== 'undefined') {
                    libText = formatExerciseLibraryV2(selectedAthlete?.sport);
                    console.log('ðŸ“š Using ExerciseLibraryV2');
                } else {
                    libText = formatExerciseLibrary(lib);
                }

                const sportKey = String(selectedAthlete?.sport || '').toLowerCase();
                const conditioningPct = focusPct?.conditioning != null ? Number(focusPct.conditioning) : null;
                const mustIncludeBoxingCircuit = sportKey === 'boxe' && Number.isFinite(conditioningPct) && conditioningPct >= 30;

                const days = Array.isArray(availableDays) ? availableDays : [];
                const n = Math.max(1, Math.min(Number.isFinite(maxSessions) ? maxSessions : days.length || 1, days.length || 1));

                const rulesetProfile = getRulesetProfile();
                const rulesetLine = `Ruleset (dipende dal cliente): ${formatRulesetProfile(rulesetProfile)}.`;
                const rulesetRules = rulesetProfile === 'conservative'
                    ? [
                        '- Profilo CONSERVATIVO: prioritÃ  sicurezza, qualitÃ  tecnica, progressioni lente; evita cedimento e movimenti troppo complessi.',
                        '- Mantieni volume moderato e intensitÃ  gestibile; privilegia esercizi stabili e cue chiari.'
                    ]
                    : rulesetProfile === 'aggressive'
                        ? [
                            '- Profilo AGGRESSIVO: spinta alta su intensitÃ /volume, MA senza sacrificare tecnica e senza picchi improvvisi.',
                            '- Evita comunque scelte rischiose se non supportate dal contesto (freschezza, esperienza, infortuni).'
                        ]
                        : [
                            '- Profilo BILANCIATO: progressioni sostenibili, tecnica alta, carico adeguato al contesto.'
                        ];

                const stateHints = aiProgramState?.history?.last_titles?.length
                    ? `Storico titoli recenti (evita ripetizioni): ${aiProgramState.history.last_titles.slice(-6).join(' | ')}`
                    : '';

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TRAINING METHODS SELECTION - AI Creativity Enhancement
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let trainingMethodsText = '';
                let advancedMethodsText = '';
                try {
                    if (window.MethodSelector && window.TRAINING_METHODS) {
                        // Map goal from phase/focus to method selector format
                        const goalMap = {
                            accumulo: 'massa',
                            intensificazione: 'forza',
                            peaking: 'performance',
                            realizzazione: 'performance',
                            deload: 'definizione'
                        };
                        const phaseKey = String(phase).toLowerCase();
                        const mappedGoal = goalMap[phaseKey] || 'massa';
                        
                        // Get fatigue from context (extract from telemetry if available)
                        const fatigueMatch = ctxText.match(/fatigue[:\s]+(\d+)/i);
                        const fatigueLevel = fatigueMatch ? parseInt(fatigueMatch[1]) : 5;
                        
                        // Get pain areas
                        const painMatch = ctxText.match(/pain areas?[:\s]+([^.\n]+)/i);
                        const painAreas = painMatch ? painMatch[1].split(',').map(s => s.trim().toLowerCase()) : [];
                        
                        // Build context for method selection
                        const methodContext = {
                            goal: mappedGoal,
                            phase: phaseKey,
                            experience: String(selectedAthlete?.experience_level || 'intermediate').toLowerCase(),
                            fatigue: fatigueLevel,
                            time_available: 60, // default
                            equipment: ['barbell', 'dumbbells', 'cables', 'machines', 'bodyweight'],
                            sport: sportKey,
                            pain_areas: painAreas,
                            rpe_tolerance: rulesetProfile === 'conservative' ? 6 : (rulesetProfile === 'aggressive' ? 9 : 7)
                        };
                        
                        const recommendations = window.MethodSelector.selectMethods(methodContext);
                        trainingMethodsText = window.MethodSelector.generatePromptSection(recommendations);
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // ADVANCED RULES: Progressions, Incompatibilities, Role, Sequence
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if (window.AdvancedMethodSelector) {
                            const roleKey = String(selectedAthlete?.role || selectedAthlete?.position || '').toLowerCase().replace(/\s+/g, '_');
                            const selectedMethodKeys = recommendations.map(r => r.key);
                            
                            advancedMethodsText = window.AdvancedMethodSelector.generateAdvancedPromptSection({
                                sport: sportKey,
                                role: roleKey,
                                weekNumber: currentWeek,
                                selectedMethods: selectedMethodKeys,
                                planType: sportKey === 'palestra' ? 'standard_4_week' : 'sport_8_week'
                            });
                            
                            console.log('ðŸ”¥ Advanced Method Rules Applied:', {
                                sport: sportKey,
                                role: roleKey,
                                week: currentWeek,
                                methods: selectedMethodKeys
                            });
                        }
                        
                        // Log for debugging
                        console.log('ðŸŽ¯ Training Methods Selected:', recommendations.map(r => r.key));
                    }
                } catch (e) {
                    console.warn('Training methods selection failed:', e);
                    trainingMethodsText = '';
                    advancedMethodsText = '';
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKOUT TEMPLATES - Struttura rigida per sport/fase
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let templateText = '';
                try {
                    if (window.TemplateSelector) {
                        templateText = window.TemplateSelector.generateTemplatePrompt(sportKey, phase);
                        console.log('ðŸ—ï¸ Template loaded for:', sportKey, phase);
                    }
                } catch (e) {
                    console.warn('Template loading failed:', e);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKOUT HISTORY - Contesto progressione
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let historyText = '';
                try {
                    if (window.WorkoutHistory && selectedAthlete?.id) {
                        historyText = window.WorkoutHistory.generateProgressionContext(selectedAthlete.id, currentWeek);
                        const progression = window.WorkoutHistory.suggestProgression(selectedAthlete.id, currentWeek);
                        if (progression.type !== 'first') {
                            historyText += `\nðŸ”„ SUGGERIMENTO PROGRESSIONE: ${progression.suggestion}\n`;
                        }
                        console.log('ðŸ“š History context loaded, progression type:', progression.type);
                    }
                } catch (e) {
                    console.warn('History loading failed:', e);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FEEDBACK ENGINE - Analisi feedback sessioni precedenti
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let feedbackText = '';
                let feedbackModifiers = null;
                let feedbackAnalysis = null;
                try {
                    if (window.FeedbackEngine && selectedAthlete?.id) {
                        feedbackText = window.FeedbackEngine.generateFeedbackPromptSection(selectedAthlete.id);
                        feedbackModifiers = window.FeedbackEngine.getWorkoutModifiers(selectedAthlete.id);
                        
                        // Log feedback analysis
                        feedbackAnalysis = window.FeedbackEngine.analyzeAll(selectedAthlete.id);
                        if (feedbackAnalysis.recommendations?.length > 0) {
                            console.log('ðŸŽ¯ Feedback Recommendations:', feedbackAnalysis.recommendations);
                        }
                        if (feedbackModifiers.volumeMultiplier !== 1 || feedbackModifiers.intensityMultiplier !== 1) {
                            console.log('ðŸ“‰ Feedback Modifiers:', feedbackModifiers);
                        }
                        
                        console.log('ðŸ’¬ Feedback context loaded for athlete:', selectedAthlete.id);
                    }
                } catch (e) {
                    console.warn('Feedback engine failed:', e);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // INJURY PREVENTION ENGINE - Analisi rischio infortuni
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let injuryPreventionText = '';
                let injuryRiskAnalysis = null;
                let injuryAlerts = null;
                try {
                    if (window.InjuryPrevention && selectedAthlete?.id) {
                        // Costruisci dati atleta
                        const athleteData = {
                            age: selectedAthlete.age || 30,
                            experience_level: selectedAthlete.experience_level || 'intermediate',
                            injuries: aiProgramState?.anamnesis?.injuries || [],
                            sport: sportKey
                        };
                        
                        // Ottieni screening se disponibile
                        const screening = window.InjuryPrevention.getLatestScreening(selectedAthlete.id);
                        
                        // Analisi rischio
                        injuryRiskAnalysis = window.InjuryPrevention.analyzeInjuryRisk(athleteData, feedbackAnalysis || {});
                        
                        // Genera alerts per coach
                        injuryAlerts = window.InjuryPrevention.generateCoachAlerts(selectedAthlete.id, athleteData, feedbackAnalysis || {});
                        
                        // Genera testo prompt
                        injuryPreventionText = window.InjuryPrevention.generateInjuryPreventionPrompt(athleteData, feedbackAnalysis || {}, screening);
                        
                        // Log
                        if (injuryRiskAnalysis.level !== 'low') {
                            console.log('ðŸ›¡ï¸ Injury Risk:', injuryRiskAnalysis.level, injuryRiskAnalysis.score + '/100');
                        }
                        if (injuryAlerts?.criticalCount > 0) {
                            console.warn('âš ï¸ Critical Injury Alerts:', injuryAlerts.alerts.filter(a => a.severity === 'critical'));
                        }
                        
                        console.log('ðŸ›¡ï¸ Injury Prevention context loaded');
                    }
                } catch (e) {
                    console.warn('Injury prevention engine failed:', e);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PERFORMANCE PREDICTION ENGINE - Analisi trend e readiness
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let performancePredictionText = '';
                let readinessData = null;
                try {
                    if (window.PerformancePrediction && selectedAthlete?.id) {
                        // Prepara dati atleta
                        const athleteData = {
                            experience_level: selectedAthlete?.experience_level || 'intermediate',
                            sport: sportKey,
                            age: selectedAthlete?.age || 30
                        };
                        
                        // Ottieni telemetria se disponibile
                        const telemetry = {
                            sleep_hours: aiProgramState?.telemetry?.sleep_avg || 7,
                            stress_level: aiProgramState?.telemetry?.stress_level || 5,
                            hrv: aiProgramState?.telemetry?.hrv_avg || null
                        };
                        
                        // Calcola readiness
                        readinessData = window.PerformancePrediction.calculateReadiness(
                            selectedAthlete.id,
                            feedbackAnalysis || {},
                            telemetry
                        );
                        
                        // Genera prompt
                        performancePredictionText = window.PerformancePrediction.generatePerformancePredictionPrompt(
                            selectedAthlete.id,
                            athleteData,
                            feedbackAnalysis || {},
                            telemetry
                        );
                        
                        // Log
                        console.log('ðŸ“Š Readiness:', readinessData.readiness + '%', readinessData.recommendation);
                        console.log('ðŸ“Š Performance Prediction context loaded');
                    }
                } catch (e) {
                    console.warn('Performance prediction engine failed:', e);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PERIODIZATION ENGINE - Intelligenza periodizzazione
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let periodizationText = '';
                let periodizationParams = null;
                try {
                    if (window.PeriodizationEngine) {
                        // Costruisci contesto atleta
                        const athleteContext = {
                            experience_level: selectedAthlete?.experience_level || 'intermediate',
                            sport: sportKey,
                            goal: aiProgramState?.anamnesis?.pillars?.focus_percentages 
                                ? (focusPct?.strength > 40 ? 'forza' : focusPct?.conditioning > 40 ? 'conditioning' : 'massa')
                                : 'massa',
                            compliance: aiProgramState?.history?.compliance_avg || 100
                        };
                        
                        // Raccogli feedback recente (da telemetria o history salvata)
                        let feedback = {
                            avgRpe: aiProgramState?.telemetry?.rpe_avg || 0,
                            compliance: aiProgramState?.history?.compliance_avg || 100,
                            sleep: aiProgramState?.telemetry?.sleep_avg || 7,
                            hrv: aiProgramState?.telemetry?.hrv_avg || 0,
                            readiness: aiProgramState?.telemetry?.readiness || 0,
                            painAreas: aiProgramState?.anamnesis?.injuries || []
                        };
                        
                        // Integra con dati storici dal WorkoutHistory
                        let weekDataHistory = [];
                        if (window.WorkoutHistory && selectedAthlete?.id) {
                            weekDataHistory = window.WorkoutHistory.getRecentWeekData(selectedAthlete.id, 4);
                            
                            // Usa dati reali dalla history se disponibili
                            if (weekDataHistory.length > 0) {
                                const lastWeekData = weekDataHistory[0];
                                if (lastWeekData.avgRpe > 0) feedback.avgRpe = lastWeekData.avgRpe;
                                if (lastWeekData.compliance > 0) feedback.compliance = lastWeekData.compliance;
                                if (lastWeekData.hrv > 0) feedback.hrv = lastWeekData.hrv;
                            }
                            
                            // Check deload con history reale
                            const deloadCheckFromHistory = window.WorkoutHistory.checkNeedsDeload(selectedAthlete.id);
                            if (deloadCheckFromHistory.needs) {
                                console.log('âš ï¸ DELOAD SUGGERITO DA HISTORY:', deloadCheckFromHistory.reason);
                            }
                        }
                        
                        // Verifica deload forzato
                        const deloadCheck = window.PeriodizationEngine.shouldForceDeload(
                            currentWeek, 
                            feedback, 
                            weekDataHistory
                        );
                        
                        if (deloadCheck.force) {
                            console.log('âš ï¸ DELOAD FORZATO:', deloadCheck.reason);
                            periodizationParams = window.PeriodizationEngine.getWeekParameters(currentWeek, athleteContext);
                            periodizationParams.phase = 'deload';
                            periodizationParams.volume = 60;
                            periodizationParams.intensity = 65;
                            periodizationParams.focus = 'Recovery (deload forzato: ' + deloadCheck.reason + ')';
                            periodizationParams = window.PeriodizationEngine.adaptFromFeedback(periodizationParams, feedback);
                        } else if (deloadCheck.needsGradualReturn) {
                            // Atleta fermo da giorni - serve RIPRESA GRADUALE, non deload!
                            const daysSince = deloadCheck.daysSinceLastWorkout || 5;
                            console.log(`ðŸ“… RIPRESA GRADUALE: Atleta fermo da ${daysSince} giorni`);
                            periodizationParams = window.PeriodizationEngine.getWeekParameters(currentWeek, athleteContext);
                            
                            // Ripresa graduale: intensitÃ  moderata, volume ridotto
                            // Ma NON cosÃ¬ basso come deload (l'atleta Ã¨ riposato, non affaticato)
                            if (daysSince >= 14) {
                                // Fermo da 2+ settimane: ripresa molto graduale
                                periodizationParams.volume = 65;
                                periodizationParams.intensity = 70;
                                periodizationParams.focus = `Ripresa graduale (${daysSince} giorni di pausa) - focus tecnica e movimento`;
                            } else if (daysSince >= 7) {
                                // Fermo da 1-2 settimane: ripresa moderata
                                periodizationParams.volume = 75;
                                periodizationParams.intensity = 75;
                                periodizationParams.focus = `Ripresa moderata (${daysSince} giorni di pausa)`;
                            } else {
                                // Fermo da 5-7 giorni: quasi normale
                                periodizationParams.volume = 85;
                                periodizationParams.intensity = 80;
                                periodizationParams.focus = `Ripresa leggera (${daysSince} giorni di pausa)`;
                            }
                            
                            periodizationParams.phase = 'accumulo'; // Fase di accumulo, non deload!
                            periodizationParams = window.PeriodizationEngine.adaptFromFeedback(periodizationParams, feedback);
                        } else {
                            periodizationParams = window.PeriodizationEngine.getWeekParameters(currentWeek, athleteContext);
                            periodizationParams = window.PeriodizationEngine.adaptFromFeedback(periodizationParams, feedback);
                        }
                        
                        periodizationText = window.PeriodizationEngine.generatePeriodizationPrompt(currentWeek, athleteContext, feedback);
                        
                        console.log('ðŸ“Š Periodization:', {
                            week: currentWeek,
                            model: periodizationParams.modelName,
                            phase: periodizationParams.phase,
                            volume: periodizationParams.volume + '%',
                            intensity: periodizationParams.intensity + '%',
                            adjustments: periodizationParams.adjustments || []
                        });
                    }
                    
                    // Integrate Macrocycle if active
                    if (window.MacrocyclePlanner) {
                        const macroContext = window.MacrocyclePlanner.generatePromptContext(selectedAthlete.id);
                        if (macroContext) {
                            periodizationText += macroContext;
                            
                            // Override periodization params with macrocycle phase
                            const macroParams = window.MacrocyclePlanner.getParametersForPeriodization(selectedAthlete.id);
                            if (macroParams) {
                                periodizationParams = {
                                    ...periodizationParams,
                                    phase: macroParams.phase,
                                    volume: macroParams.volume,
                                    intensity: macroParams.intensity,
                                    focus: macroParams.focus
                                };
                                
                                if (macroParams.isDeload) {
                                    periodizationParams.volume = 60;
                                    periodizationParams.intensity = 65;
                                    periodizationParams.phase = 'deload';
                                    periodizationParams.focus = 'Deload programmato dal macrociclo';
                                }
                                
                                console.log('ðŸ“… Macrocycle override:', macroParams);
                            }
                        }
                    }
                    
                    // Integrate Return-to-Play protocol
                    if (window.ReturnToPlay) {
                        const rtpContext = window.ReturnToPlay.generatePromptContext(selectedAthlete.id);
                        if (rtpContext) {
                            periodizationText += rtpContext;
                            console.log('ðŸ¥ Return-to-Play context added');
                        }
                    }
                    
                    // Integrate Exercise Memory
                    if (window.ExerciseMemory) {
                        const memoryContext = window.ExerciseMemory.generatePromptContext(selectedAthlete.id, currentWeek);
                        if (memoryContext) {
                            periodizationText += memoryContext;
                            console.log('ðŸ“ Exercise Memory context added');
                        }
                    }
                    
                    // Integrate Pre-Workout Check
                    if (window.PreWorkoutCheck) {
                        const checkContext = window.PreWorkoutCheck.generatePromptContext(selectedAthlete.id);
                        if (checkContext) {
                            periodizationText += checkContext;
                            
                            // Apply readiness modifiers
                            const modifiers = window.PreWorkoutCheck.getModifiers(selectedAthlete.id);
                            if (modifiers.hasCheck) {
                                periodizationParams.volume = Math.round(periodizationParams.volume * modifiers.volumeMultiplier);
                                periodizationParams.intensity = Math.round(periodizationParams.intensity * modifiers.intensityMultiplier);
                                console.log('ðŸ“‹ Pre-workout modifiers applied:', modifiers);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Periodization engine failed:', e);
                }

                // Day-by-day builder with quality gate (more human-like programming)
                const dayLabel = {
                    monday: 'LunedÃ¬',
                    tuesday: 'MartedÃ¬',
                    wednesday: 'MercoledÃ¬',
                    thursday: 'GiovedÃ¬',
                    friday: 'VenerdÃ¬',
                    saturday: 'Sabato',
                    sunday: 'Domenica'
                };

                function summarizeWorkoutForContext(w) {
                    try {
                        const day = String(w?.day_of_week || '').toLowerCase();
                        const title = String(w?.name || '').trim();
                        const exs = Array.isArray(w?.exercises) ? w.exercises : [];
                        const first3 = exs.slice(0, 3).map(e => String(e?.name || '').trim()).filter(Boolean);
                        return `- ${dayLabel[day] || day || 'Giorno'}: ${title || 'Workout'} | start: ${first3.join(' / ') || 'N/A'}`;
                    } catch {
                        return '- N/A';
                    }
                }

                function normalizeExerciseType(typeRaw) {
                    const t = String(typeRaw || '').toLowerCase().trim();
                    if (t === 'strength' || t === 'hypertrophy' || t === 'conditioning') return t;
                    if (/^warm\s*-?\s*up$/.test(t) || /warm|prep|prehab|mob|activation|breath|cool\s*-?\s*down|stretch/.test(t)) return 'conditioning';
                    if (/cardio|hiit|zone\s*2|emom|amrap|circuit/.test(t)) return 'conditioning';
                    if (/hypertroph|pump|accessor/.test(t)) return 'hypertrophy';
                    if (/power|max|heavy|strength/.test(t)) return 'strength';
                    return 'conditioning';
                }

                function normalizeWorkout(w) {
                    try {
                        if (!w || typeof w !== 'object') return w;
                        
                        // Supporta sia "exercises" (inglese) che "esercizi" (italiano)
                        if (!w.exercises && w.esercizi) {
                            w.exercises = w.esercizi.map(e => {
                                // Mappa chiavi italiane a inglesi
                                return {
                                    name: e.nome || e.name || '',
                                    sets: e.serie || e.sets || 1,
                                    reps: e.ripetizioni || e.reps || 'N/A',
                                    rest: e.riposo || e.rest || '60s',
                                    type: e.type || e.tipo || 'conditioning',
                                    notes: e.descrizione || e.notes || ''
                                };
                            });
                            delete w.esercizi;
                        }
                        
                        // Mappa anche altre chiavi italiane comuni
                        if (!w.name && w.nome) { w.name = w.nome; delete w.nome; }
                        if (!w.day_of_week && w.giorno) { 
                            const dayMap = { 'lunedi': 'monday', 'lunedÃ¬': 'monday', 'martedi': 'tuesday', 'martedÃ¬': 'tuesday', 
                                           'mercoledi': 'wednesday', 'mercoledÃ¬': 'wednesday', 'giovedi': 'thursday', 'giovedÃ¬': 'thursday',
                                           'venerdi': 'friday', 'venerdÃ¬': 'friday', 'sabato': 'saturday', 'domenica': 'sunday' };
                            w.day_of_week = dayMap[w.giorno.toLowerCase()] || w.giorno;
                            delete w.giorno;
                        }
                        if (!w.estimated_duration_minutes && w.durata_stimata) {
                            w.estimated_duration_minutes = parseInt(w.durata_stimata) || 60;
                            delete w.durata_stimata;
                        }
                        
                        if (!Array.isArray(w.exercises)) return w;
                        w.exercises = w.exercises
                            .map(e => {
                                if (!e || typeof e !== 'object') {
                                    return { name: String(e || ''), sets: 1, reps: 'N/A', type: 'conditioning' };
                                }
                                const ex = { ...e };
                                ex.type = normalizeExerciseType(ex.type);
                                return ex;
                            })
                            .filter(ex => String(ex?.name || '').trim().length > 0);
                        return w;
                    } catch {
                        return w;
                    }
                }

                function validateWorkoutLogic(w) {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // VALIDAZIONE INTELLIGENTE (basata su metriche reali)
                    // Non piÃ¹ regole stupide come "minimo 5 esercizi"
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    const issues = [];
                    const exs = Array.isArray(w?.exercises) ? w.exercises : [];
                    
                    // Usa WorkoutIntelligence se disponibile
                    if (window.WorkoutIntelligence) {
                        // Calcola durata target dall'atleta
                        const targetDuration = (() => {
                            try {
                                const pillars = selectedAthlete?.anamnesis?.pillars;
                                if (pillars?.session_duration_minutes) {
                                    return parseInt(pillars.session_duration_minutes);
                                }
                                const schedule = selectedAthlete?.schedule;
                                if (schedule?.session_duration) {
                                    return parseInt(schedule.session_duration);
                                }
                            } catch {}
                            return 60; // Default
                        })();
                        
                        const validation = window.WorkoutIntelligence.validate(w, {
                            phase: phase,
                            targetDuration: targetDuration,
                            athleteLevel: selectedAthlete?.level || 'intermediate',
                            sport: sportKey
                        });
                        
                        // Log metriche per debug
                        console.log('ðŸ“Š Workout metrics:', validation.metrics);
                        
                        // Solo issues critici (non warning/suggestions)
                        for (const issue of validation.issues) {
                            issues.push(issue);
                        }
                        
                        // Log warning ma non bloccare
                        for (const warn of validation.warnings) {
                            console.log('âš ï¸ Workout warning:', warn);
                        }
                        
                        // Log suggestions
                        for (const sug of validation.suggestions) {
                            console.log('ðŸ’¡ Suggestion:', sug);
                        }
                    }

                    // Coach-like quality gate (sport + phase). Usa criticitÃ  come hard issues.
                    try {
                        if (window.CoachQuality?.scoreWorkout) {
                            const ne = (() => {
                                try { return getNextEventActive(selectedAthlete?.id); } catch { return null; }
                            })();
                            const seasonPhase = (() => {
                                try { return inferSeasonPhaseForAthlete(selectedAthlete, ne); } catch { return null; }
                            })();
                            const matchDayType = ne?.date ? computeMatchDayTypeForWorkoutDay(w?.day_of_week, ne.date) : null;
                            const qc = window.CoachQuality.scoreWorkout(w, {
                                phase: phase,
                                sportKey: sportKey,
                                sport: sportKey,
                                athleteSport: selectedAthlete?.sport,
                                seasonPhase: seasonPhase,
                                matchDayType: matchDayType
                            });
                            console.log(`ðŸ§ª CoachQuality: ${qc.score}/100 (${qc.rating})`);
                            for (const ci of qc.criticalIssues || []) {
                                issues.push(ci);
                            }
                            for (const warn of qc.warnings || []) {
                                console.log('âš ï¸ CoachQuality warning:', warn);
                            }
                        }
                    } catch (e) {
                        console.warn('CoachQuality failed:', e);
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // BOXING RULES - Vincoli hard non negoziabili per boxe
                    // BLOCKED = REJECT IMMEDIATO, nessun override possibile
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    try {
                        const sportForValidation = sportKey || selectedAthlete?.sport || '';
                        const isBoxing = /box|pugilato|pugile/i.test(sportForValidation);
                        
                        if (isBoxing && window.BoxingRules?.validateWorkout) {
                            console.log('ðŸ¥Š BoxingRules: validating workout...');
                            const boxValidation = window.BoxingRules.validateWorkout(w, {
                                sport: sportForValidation,
                                sessionType: phase || 'mixed',
                                weeklyBoxingRounds: aiProgramState?.weeklyStats?.totalBoxingRounds || 0,
                                athleteLevel: selectedAthlete?.level || 'intermediate'
                            });
                            
                            console.log(`ðŸ¥Š BoxingRules: ${boxValidation.status || (boxValidation.isValid ? 'VALID' : 'BLOCKED')}`);
                            
                            // âš ï¸ BLOCKING ERRORS = HARD REJECT
                            // NON si fa auto-fix, si RIGENERA
                            if (boxValidation.status === 'BLOCKED' || (boxValidation.blockingErrors?.length > 0)) {
                                for (const err of boxValidation.blockingErrors) {
                                    issues.push(`ðŸ¥Š BLOCCO: ${err.message} â†’ ${err.fix}`);
                                    console.error('ðŸ¥Š BLOCKING ERROR:', err);
                                }
                                // Log esplicito che questo workout sarÃ  rigettato
                                console.error('ðŸ¥Š WORKOUT REJECTED - BLOCKED errors cannot be overridden');
                                // Stop immediato: non tentare fix, non accettare
                                throw new Error('BLOCKED: Workout non valido, va rigenerato');
                            }
                            
                            // Warnings vengono loggati ma non bloccano
                            for (const warn of boxValidation.warnings || []) {
                                console.log('ðŸ¥Š BoxingRules warning:', warn);
                            }
                            
                            // âš ï¸ RIMOSSO: Niente auto-fix per BLOCKED
                            // Un workout BLOCKED deve essere RIGENERATO, non patchato
                        }
                    } catch (e) {
                        console.warn('BoxingRules validation failed:', e);
                    }
                    
                    // Fallback: validazione base se WorkoutIntelligence non caricato
                    if (exs.length === 0) {
                        issues.push('Nessun esercizio nel workout');
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // HARD STOPS - Non warning, ma REJECT immediato
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Escludi warm-up e cool-down dal conteggio esercizi principali
                    const mainExercises = exs.filter(e => {
                        const name = String(e?.name || '').toLowerCase();
                        return !/warm|cool|stretch|mobility|activation/i.test(name);
                    });
                    
                    // HARD STOP: Max 10 esercizi principali
                    if (mainExercises.length > 10) {
                        issues.push(`ðŸ›‘ HARD STOP: ${mainExercises.length} esercizi (max 10 esclusi warm-up/cool-down)`);
                    }
                    
                    // HARD STOP: Durata stimata > 90 min
                    const estimatedDuration = w?.estimated_duration_minutes || w?.estimatedDuration || 0;
                    if (estimatedDuration > 90) {
                        issues.push(`ðŸ›‘ HARD STOP: Durata ${estimatedDuration}min (max 90min)`);
                    }
                    
                    // HARD STOP: Pattern overload (usa PostProcessor se disponibile)
                    if (window.WorkoutPostProcessor?.validatePatternLimits) {
                        const patternIssues = window.WorkoutPostProcessor.validatePatternLimits(exs);
                        for (const pi of patternIssues) {
                            issues.push(`ðŸ›‘ HARD STOP: ${pi}`);
                        }
                    }
                    
                    // Tipo esercizio valido
                    const types = exs.map(e => String(e?.type || '').toLowerCase());
                    const badType = types.find(t => t !== 'strength' && t !== 'hypertrophy' && t !== 'conditioning');
                    if (badType) issues.push(`type non valido: ${badType}`);

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // METODOLOGIE CHECK - Verifica uso di almeno 1 metodologia
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const methodologyPatterns = [
                        /superset|super\s*set/i,
                        /drop\s*set/i,
                        /tri[\-\s]?set/i,
                        /giant\s*set/i,
                        /rest[\-\s]?pause/i,
                        /cluster/i,
                        /myo[\-\s]?rep/i,
                        /emom/i,
                        /amrap/i,
                        /tabata/i,
                        /circuit|circuito/i,
                        /tempo\s*\d/i,           // es: "tempo 3010"
                        /\d[\-]\d[\-]\d[\-]\d/,  // es: "3-0-1-0"
                        /pyramid|piramide/i,
                        /^[A-C][1-9]:/i,         // es: "A1:", "B2:"
                        /contrast/i,
                        /eccentric|negativ/i,
                        /isometric|hold/i
                    ];
                    
                    const exerciseNames = exs.map(e => String(e?.name || ''));
                    const exerciseReps = exs.map(e => String(e?.reps || ''));
                    const allText = [...exerciseNames, ...exerciseReps].join(' ');
                    
                    const hasMethodology = methodologyPatterns.some(p => p.test(allText));
                    
                    if (!hasMethodology && mainExercises.length >= 4) {
                        // Solo warning se non Ã¨ un workout minimalista
                        console.log('âš ï¸ METODOLOGIE: Nessuna metodologia rilevata nel workout');
                        issues.push('Aggiungi almeno 1 metodologia (superset, drop set, EMOM, tempo, ecc)');
                    } else if (hasMethodology) {
                        // Log quali metodologie sono state usate
                        const usedMethods = methodologyPatterns
                            .filter(p => p.test(allText))
                            .map(p => p.source.replace(/\\/g, '').replace(/\[.*?\]/g, '').slice(0, 15));
                        console.log('âœ… METODOLOGIE applicate:', usedMethods);
                    }

                    // Check nomi troppo generici (questo Ã¨ utile)
                    const vaguePatternsBoxing = [
                        /^boxing\s*circuit$/i,
                        /^shadow\s*boxing\s*drills?$/i,
                        /^footwork\s*drills?$/i,
                        /^heavy\s*bag\s*intervals?$/i,
                        /^emom\s*\d+\s*(min|')?$/i,
                        /^circuit\s*training$/i,
                        /^conditioning\s*circuit$/i,
                        /^cardio\s*finisher$/i
                    ];
                    
                    for (const ex of exs) {
                        const name = String(ex?.name || '').trim();
                        const isVague = vaguePatternsBoxing.some(p => p.test(name));
                        const isCircuitWithoutDetails = /circuit|emom|drill|interval/i.test(name) && 
                                                        !/\d+\s*(x|Ã—)|\+|,|:.*\d/.test(name);
                        
                        if (isVague || isCircuitWithoutDetails) {
                            issues.push(`nome troppo generico: "${name}" - specifica gli esercizi esatti`);
                            break;
                        }
                    }

                    return Array.from(new Set(issues));
                }

                async function fixWorkoutIfNeeded(dayCtx, workoutObj, issues, coachPlaybookText = '') {
                    if (!issues || issues.length === 0) return workoutObj;
                    
                    // Include regole metodologie nel fix
                    let methodRules = '';
                    if (trainingMethodsText) methodRules += trainingMethodsText;
                    if (advancedMethodsText) methodRules += advancedMethodsText;
                    
                    const promptFix = [
                        'CORREGGI OBBLIGATORIAMENTE questo workout seguendo TUTTE le regole.',
                        'Output: SOLO JSON valido (workout object).',
                        'âš ï¸ CHIAVI JSON OBBLIGATORIE IN INGLESE: day_of_week, name, exercises, sets, reps, rest, type',
                        '',
                        dayCtx,
                        coachPlaybookText ? `\n${coachPlaybookText.substring(0, 700)}` : '',
                        libText,
                        methodRules,
                        rulesetLine,
                        '',
                        `â›” PROBLEMI DA CORREGGERE OBBLIGATORIAMENTE: ${issues.join(' | ')}`,
                        '',
                        'REGOLE VINCOLANTI:',
                        '- JSON keys in ENGLISH: day_of_week, name, exercises, sets, reps, rest, type',
                        '- 5-8 esercizi (max 10 se necessario)',
                        '- warm-up/prep come 1Â° (o 1Â°-2Â°) elemento',
                        '- main chiaro dopo warm-up',
                        '- rispettare focus % e vincoli anamnesi',
                        '- type solo: strength | hypertrophy | conditioning',
                        '- DEVI usare almeno 1 metodologia (superset, drop set, ecc)',
                        '- DEVI indicare metodologia nel nome esercizio (es: "(superset)", "(drop set)")',
                        '- Se c\'Ã¨ incompatibilitÃ  tra metodi, RIMUOVI quello meno prioritario',
                        '',
                        'WORKOUT JSON DA CORREGGERE:',
                        JSON.stringify(workoutObj)
                    ].join('\n');

                    const { content } = await groqChat({
                        model: GROQ_MODELS.fast,
                        temperature: 0.2,
                        max_tokens: 2500,
                        messages: [
                            { role: 'system', content: "Sei un preparatore atletico d'elite. Correggi il workout rispettando TUTTE le regole. Rispondi SOLO con JSON valido COMPLETO." },
                            { role: 'user', content: promptFix }
                        ]
                    });

                    console.log('ðŸ”§ FIX RESPONSE:', content?.substring(0, 500));

                    try {
                        const fixed = parseAiJsonOrThrow(content, 'Fix workout');
                        console.log('ðŸ”§ FIXED WORKOUT exercises:', fixed?.exercises?.length);
                        return normalizeWorkout(fixed);
                    } catch (e) {
                        console.error('ðŸ”§ FIX PARSE ERROR:', e);
                        return workoutObj;
                    }
                }

                async function reviseWorkoutWithCouncil(dayCtx, workoutObj, councilNotes) {
                    try {
                        const notes = Array.isArray(councilNotes) ? councilNotes.map(s => String(s || '').trim()).filter(Boolean) : [];
                        if (!notes.length) return workoutObj;

                        const promptRevise = [
                            'Rivedi e MIGLIORA questo workout usando i commenti degli esperti.',
                            'Output: SOLO JSON valido (workout object). Niente testo extra.',
                            'âš ï¸ JSON KEYS IN ENGLISH: day_of_week, name, exercises, sets, reps, rest, type',
                            '',
                            dayCtx,
                            libText,
                            rulesetLine,
                            '',
                            'COMMENTI ESPERTI (da integrare):',
                            notes.map(n => `- ${n}`).join('\n'),
                            '',
                            'Regole:',
                            '- JSON keys MUST be in English: day_of_week, name, exercises, sets, reps, rest, type',
                            '- Mantieni day_of_week invariato',
                            '- 5-8 esercizi (max 10 se serve)',
                            '- warm-up/prep all\'inizio',
                            '- ordine logico, niente esercizi casuali',
                            '- type solo: strength | hypertrophy | conditioning',
                            '- inserisci tempo/TUT in reps per hypertrophy/accessori tecnici (es: "8-10 @ tempo 3-1-1")',
                            '',
                            'WORKOUT JSON DA RIVEDERE:',
                            JSON.stringify(workoutObj)
                        ].join('\n');

                        const { content } = await groqChat({
                            model: GROQ_MODELS.fast,
                            temperature: 0.25,
                            max_tokens: 2500,
                            messages: [
                                { role: 'system', content: "Sei un preparatore atletico d'elite. Rispondi SOLO con JSON valido COMPLETO (oggetto workout)." },
                                { role: 'user', content: promptRevise }
                            ]
                        });

                        try {
                            const revised = parseAiJsonOrThrow(content, 'Revisione workout');
                            return normalizeWorkout(revised);
                        } catch {
                            return workoutObj;
                        }
                    } catch {
                        return workoutObj;
                    }
                }

                async function dayCouncilReviewAndRevise(dayCtx, workoutObj, expertKeys) {
                    const keys = Array.isArray(expertKeys) ? expertKeys.map(k => String(k || '').trim()).filter(Boolean) : [];
                    if (!keys.length) return { critiques: {}, revised_workout: workoutObj };

                    const prompt = [
                        'Sei un consiglio di esperti. Devi fare 2 cose: (1) critica breve per ogni esperto richiesto, (2) revisione del workout.',
                        'Output: SOLO JSON valido nel formato:',
                        '{"critiques":{"recovery":"...","athletic":"...","technique":"..."},"revised_workout":{...}}',
                        'Regole critiche: 2-4 righe, 1 modifica concreta; niente markdown.',
                        'Regole workout: mantieni day_of_week invariato; 5-8 esercizi (max 10); ordine warm-up -> main -> accessori -> conditioning; type solo strength|hypertrophy|conditioning; usa tempo/TUT in reps quando utile.',
                        '',
                        dayCtx,
                        libText,
                        rulesetLine,
                        '',
                        `ESPERTI RICHIESTI: ${keys.join(', ')}`,
                        'WORKOUT JSON:',
                        JSON.stringify(workoutObj)
                    ].join('\n');

                    const { content } = await groqChat({
                        model: GROQ_MODELS.fast,
                        temperature: 0.25,
                        max_tokens: 1600,
                        messages: [
                            { role: 'system', content: "Sei un consiglio di preparatori d'elite. Rispondi SOLO con JSON valido." },
                            { role: 'user', content: prompt }
                        ]
                    });

                    let parsed;
                    try {
                        parsed = parseAiJsonOrThrow(content, 'Consiglio + revisione');
                    } catch {
                        return { critiques: {}, revised_workout: workoutObj };
                    }
                    const revised = normalizeWorkout(parsed?.revised_workout && typeof parsed.revised_workout === 'object' ? parsed.revised_workout : workoutObj);
                    const critiques = parsed?.critiques && typeof parsed.critiques === 'object' ? parsed.critiques : {};
                    return { critiques, revised_workout: revised };
                }

                const selectedDays = days.slice(0, n).map(d => String(d).toLowerCase());
                const allowedDays = new Set(selectedDays);
                const workouts = [];
                const promptsByDay = [];
                let circuitIncluded = false;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PROMPT COMPATTO - Riduce da ~3500 a ~1800 token
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                function buildCompactPrompt(dayCtx, options = {}) {
                    const { libText, templateText, periodizationText, feedbackText, trainingMethodsText, coachPlaybookText, focusPct, focusStrengthPct, sportIntelligenceText } = options;
                    
                    // Sezioni essenziali (compattate)
                    const essentialRules = `
REGOLE OUTPUT:
- JSON valido: {day_of_week, name, estimated_duration_minutes, exercises:[{name,sets,reps,rest,type}]}
- type: strength|hypertrophy|conditioning
- Nomi SPECIFICI (NO "Boxing Circuit", SÃŒ "Circuit 3x: Burpees+JumpRope+MountainClimbers")
- Round-based: "6x3min" â†’ sets=6, reps="3min"
- Superset: A1/A2 con rest=0s tra, 90s dopo coppia
- 8-10 esercizi, 25-35 sets totali, ~60min

STRUTTURA:
warmup(10-12min) â†’ FORZA(compound first) â†’ accessori â†’ conditioning â†’ cooldown(5min)

REST VARIETÃ€: strength=120-180s (compound) | hypertrophy=60-90s | conditioning=30-60s
SETS/REPS VARIETÃ€: strength=4x5-6 | accessori=3x8-12 | circuits=3-4rounds`;

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // REGOLE SPORT-SPECIFICHE - BOXE (da BoxingRules module)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let boxeRules = '';
                    if (sportKey === 'boxe') {
                        if (window.BoxingRules?.generatePromptRules) {
                            // Usa il modulo centralizzato
                            boxeRules = '\nðŸ¥Š REGOLE BOXE (OBBLIGATORIE - VINCOLI NON NEGOZIABILI):\n' + 
                                        window.BoxingRules.generatePromptRules();
                        } else {
                            // Fallback se modulo non caricato
                            boxeRules = `

ðŸ¥Š REGOLE BOXE (OBBLIGATORIE):
1. WARM-UP COMPLETO (10-12 min): mobilitÃ  dinamica completa (anche, colonna, spalle), attivazione (glute bridge, dead bug), shadow leggero 2x2min. NON 2x10 hip circles.

2. ORDINE SESSIONE: Warm-up â†’ FORZA (compound pesanti) â†’ Conditioning boxing â†’ Cool-down
   âŒ ERRORE: Shadow boxing PRIMA della forza
   âœ… CORRETTO: Squat/Deadlift PRIMA di bag work/shadow

3. FORZA: recuperi 120-180s tra compound. I 45s dopo squat sono INSUFFICIENTI.
   - Lower day: Back Squat 4x5 (180s) â†’ Romanian Deadlift 3x8 (120s)
   - Upper day: Bench 4x6 (150s) â†’ Pull-ups 4xAMRAP (120s) â†’ Row 3x8

4. CONDITIONING BOXE: MAX 4-6 round per sessione, non 9+
   - Shadow boxing: 4x3min (focus tecnico diverso ogni round)
   - Heavy bag: 2-3x3min (non 3 intervals + 3 circuit = 6 round)

5. NECK: 3x15 rep per direzione (flessione, estensione, laterale). 
   âŒ ERRORE: 4x3min (troppo, rischioso)
   âœ… CORRETTO: 3x15 per direzione

6. VARIETÃ€ TRA GIORNI:
   - MartedÃ¬: Focus POTENZA (lower body emphasis + heavy bag power)
   - GiovedÃ¬: Focus VELOCITÃ€ (upper body emphasis + speed/technique)
   NON stessa struttura identica.

7. COOL-DOWN: 5min walk + stretching statico (quads, hamstrings, hip flexors, spalle 30s each)`;
                        }
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // REGOLE SPORT-SPECIFICHE - CALCIO
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let calcioRules = '';
                    if (sportKey === 'calcio') {
                        calcioRules = `

âš½ REGOLE CALCIO (OBBLIGATORIE - VINCOLI NON NEGOZIABILI):

1. WARM-UP SPECIFICO (12-15 min):
   - MobilitÃ  dinamica: anche, caviglie, colonna (leg swings, hip circles, ankle circles)
   - Attivazione: glute bridges, clamshells, monster walks
   - Ramp-up locomotion: skipping, carioca, backward run progressivo
   - NON iniziare mai con sprint/plyo senza ramp-up

2. ORDINE SESSIONE:
   Warm-up â†’ FORZA (compound) â†’ Pliometria â†’ Conditioning â†’ Tecnica/AgilitÃ  â†’ Cool-down
   âŒ ERRORE: Plyo PRIMA della forza (CNS non attivato)
   âœ… CORRETTO: Squat/Deadlift â†’ Box Jumps â†’ Sprint work

3. PREVENZIONE INFORTUNI (OBBLIGATORIO):
   - Nordic Hamstring: 3x5-8 (controllo eccentrico, NON 3x15)
   - Copenhagen: 2x8 per lato (adduttori)
   - Single Leg RDL: 3x8 per lato (stabilitÃ  monopodalica)
   - Ankle strengthening: banded dorsiflexion, calf raises eccentrici

4. FORZA LOWER BODY (PRIORITÃ€):
   - Squat variations: 4x5-6 @ RPE 8 (recuperi 150-180s)
   - Hip Hinge: RDL/Trap Bar Deadlift 3x6-8 (120s)
   - Single-leg: Bulgarian Split Squat, Step-ups 3x8/lato
   - Posterior chain > anterior chain (rapporto 2:1)

5. PLIOMETRIA (MAX 40-60 contatti/sessione):
   - Box Jumps, Broad Jumps: 4x5 (non 4x12!)
   - Depth Jumps: SOLO atleti avanzati, max 3x3
   - Recuperi completi: 60-90s tra set
   âŒ ERRORE: 100+ salti per sessione
   âœ… CORRETTO: 40-60 contatti qualitÃ 

6. SPRINT & AGILITY:
   - Linear sprints: 6-8 x 20-40m con recupero 1:6-8
   - COD (change of direction): 5x5 con recupero completo
   - NON fare sprint sub-massimale per "cardio" (Ã¨ inutile)

7. CONDITIONING CALCIO:
   - HIT (High Intensity): 4-6 x 4min @ 85-90% HRmax (2-3min rec)
   - SSG (Small Sided Games) simulation: HIIT 15:15, 30:30
   - Evitare long slow distance > 30min (sport intermittente!)

8. MATCH DAY LOGIC:
   - MD-3: Alta intensitÃ , volume forza
   - MD-2: Media intensitÃ , tecnica + mobilitÃ 
   - MD-1: Priming leggero (attivazione, NO DOMS)
   - MD+1: Recovery attivo (zone 2, mobility, pool)
   - MD+2: Ripresa graduale

9. COOL-DOWN COMPLETO (8-10 min):
   - Walk 3min + stretching statico (quads, hamstrings, hip flexors, calves, IT band)
   - Foam rolling: quads, IT band, calves (30s per area)`;
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // REGOLE SPORT-SPECIFICHE - BASKET
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let basketRules = '';
                    if (sportKey === 'basket') {
                        basketRules = `

ðŸ€ REGOLE BASKET (OBBLIGATORIE - VINCOLI NON NEGOZIABILI):

1. WARM-UP SPECIFICO (12-15 min):
   - MobilitÃ  dinamica: anche, spalle, caviglie, thoracic spine
   - Attivazione: glute bridges, band walks, scapular push-ups
   - Locomotion progressiva: jog, lateral shuffle, backpedal, carioca
   - Jump prep: submaximal hops, line jumps

2. ORDINE SESSIONE:
   Warm-up â†’ FORZA â†’ Potenza/Plyo â†’ AgilitÃ  â†’ Conditioning â†’ Cool-down
   âŒ ERRORE: Cardio intenso PRIMA della forza/plyo
   âœ… CORRETTO: Squat â†’ Jumps â†’ Conditioning finale

3. FORZA VERTICALE (PRIORITÃ€ SALTO):
   - Squat: 4x5-6 (prioritÃ  profonditÃ )
   - Trap Bar Deadlift: 4x5 (hip hinge power)
   - Split Squat/Lunges: 3x8/lato (stabilitÃ )
   - Calf Raises: 3x12-15 (esplosivitÃ  plantare)

4. FORZA UPPER (TIRO + CONTATTO):
   - Push: Bench/Overhead Press 3x6-8
   - Pull: Rows, Pull-ups 4x8-10 (spalla sana)
   - Core anti-rotation: Pallof Press 3x12/lato
   - Shoulder prehab: facepulls, YTWLs

5. POTENZA & PLIOMETRIA (FOCUS VERTICALE):
   - Box Jumps: 4x5 (enfasi altezza)
   - Depth Jumps: 3x4 (solo avanzati)
   - Lateral bounds: 3x6/lato
   - Medicine Ball throws: 3x6 (rotazionali + overhead)
   - MAX 50-60 contatti/sessione

6. AGILITÃ€ & FOOTWORK:
   - Defensive slides: 4x10s
   - Closeout drills: 3x5
   - Lane agility (T-test, Pro Agility): 4-6 reps
   - Reaction drills: 3-4 sets
   - Recuperi completi tra set

7. CONDITIONING BASKET:
   - HIIT specifico: 30:30, 15:15 (simula gioco)
   - Repeat Sprint Ability: 8-10 x 20m (rec 20s)
   - Court sprints: suicides, 17s
   - NON jogging lento prolungato (sport esplosivo)

8. PREVENZIONE INFORTUNI:
   - Ankle stability: BOSU, single-leg balance 2x30s/lato
   - Knee control: mini-band squats, VMO work
   - ACL prevention: Nordic, single-leg landings
   - Shoulder mobility: sleeper stretch, pec stretch

9. MATCH/GAME DAY LOGIC:
   - G-3: Volume forza + conditioning
   - G-2: Potenza/velocitÃ  (basso volume)
   - G-1: Attivazione leggera, shooting practice
   - G+1: Recovery pool/bike + mobility
   - G+2: Ripresa graduale forza

10. COOL-DOWN (8-10 min):
    - Walk + stretching statico (quads, hips, shoulders, ankles)
    - Foam rolling: IT band, quads, lats`;
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // REGOLE SPORT-SPECIFICHE - PALESTRA/FITNESS
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let palestraRules = '';
                    if (sportKey === 'palestra') {
                        palestraRules = `

ðŸ‹ï¸ REGOLE PALESTRA/FITNESS (OBBLIGATORIE):

1. WARM-UP GENERALE (8-10 min):
   - 5min cardio leggero (bike, row, walk incline)
   - MobilitÃ  dinamica: hips, thoracic, shoulders
   - Attivazione specifica per split del giorno

2. SPLIT TRAINING LOGIC:
   - PPL (Push/Pull/Legs): 3-6x settimana
   - Upper/Lower: 4x settimana ideale
   - Full Body: 2-3x settimana per principianti
   - Bro Split: solo atleti avanzati 5-6x

3. ORDINE ESERCIZI:
   Compound â†’ Accessori â†’ Isolamento â†’ Core
   âŒ ERRORE: Curl bicipiti PRIMA di Rows
   âœ… CORRETTO: Deadlift â†’ Row â†’ Curl â†’ Core

4. SETS & REPS VARIETÃ€:
   - Forza: 4-6x 3-5 @ RPE 8-9 (rest 180-300s)
   - Ipertrofia: 3-4x 8-12 @ RPE 7-8 (rest 60-90s)
   - Endurance/Pump: 2-3x 15-20 (rest 30-45s)
   - Mescolare tutti e 3 nella settimana

5. VOLUME SETTIMANALE (per gruppo muscolare):
   - Principiante: 10-12 sets/settimana
   - Intermedio: 12-16 sets/settimana
   - Avanzato: 16-20+ sets/settimana
   - MAI piÃ¹ di 10-12 sets per muscolo/sessione

6. PROGRESSIVE OVERLOAD:
   - Aumenta peso quando RPE < 7 per tutte le rep
   - Aggiungi 1-2 rep prima di aumentare peso
   - Deload ogni 4-6 settimane (volume -40%)

7. COMPOUND ESSENZIALI:
   - Squat variation (back, front, goblet)
   - Hip Hinge (deadlift, RDL, good morning)
   - Horizontal Push (bench, dumbbell press)
   - Horizontal Pull (row variations)
   - Vertical Push (OHP, landmine press)
   - Vertical Pull (pull-ups, lat pulldown)

8. ACCESSORI INTELLIGENTI:
   - Scegliere 2-3 accessori per gruppo
   - Variare angoli e grip ogni 4-6 settimane
   - Includere unilateral work

9. CORE TRAINING:
   - Anti-extension: plank, dead bug
   - Anti-rotation: Pallof press
   - Anti-lateral flexion: suitcase carry
   - Hip flexion: hanging leg raise
   - 2-3 esercizi fine sessione

10. COOL-DOWN (5 min):
    - Stretching statico gruppi allenati
    - Foam rolling opzionale`;
                    }

                    // Combina tutte le regole sport-specifiche
                    const sportSpecificRules = boxeRules || calcioRules || basketRules || palestraRules;

                    // Prompt compatto
                    return [
                        dayCtx,
                        sportIntelligenceText ? `\nðŸ§  EXPERT COACH INTELLIGENCE:\n${sportIntelligenceText.substring(0, 2000)}` : '',
                        coachPlaybookText ? `\n${coachPlaybookText.substring(0, 650)}` : '',
                        libText ? `\nESERCIZI:\n${libText.substring(0, 1500)}` : '',
                        periodizationText ? `\n${periodizationText.substring(0, 400)}` : '',
                        feedbackText ? `\n${feedbackText.substring(0, 300)}` : '',
                        trainingMethodsText ? `\n${trainingMethodsText.substring(0, 400)}` : '',
                        essentialRules,
                        sportSpecificRules, // â† Regole sport-specifiche (boxe/calcio/basket/palestra)
                        focusStrengthPct ? `\nFocus: forza ${focusStrengthPct}% | cond ${focusPct?.conditioning || 'N/A'}%` : ''
                    ].filter(Boolean).join('\n');
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // MICRO-PERIODIZZAZIONE SETTIMANALE
                // Varia intensitÃ  tra i giorni (come un coach umano)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const microPeriodization = {
                    // 2 giorni: Heavy / Light
                    2: [
                        { intensity: 'ALTA', rpeRange: '8-9', volumeMod: 1.0, description: 'Sessione PESANTE - carichi alti, focus forza' },
                        { intensity: 'BASSA', rpeRange: '5-6', volumeMod: 0.7, description: 'Sessione LEGGERA - tecnica e recupero attivo' }
                    ],
                    // 3 giorni: Heavy / Light / Medium
                    3: [
                        { intensity: 'ALTA', rpeRange: '8-9', volumeMod: 1.0, description: 'Sessione PESANTE - carichi alti, RPE 8-9' },
                        { intensity: 'BASSA', rpeRange: '5-6', volumeMod: 0.6, description: 'Sessione LEGGERA - tecnica, mobilitÃ , RPE 5-6' },
                        { intensity: 'MEDIA', rpeRange: '7-7.5', volumeMod: 0.85, description: 'Sessione MEDIA - volume moderato, RPE 7' }
                    ],
                    // 4 giorni: Heavy / Light / Medium / Medium-Heavy
                    4: [
                        { intensity: 'ALTA', rpeRange: '8-9', volumeMod: 1.0, description: 'Sessione PESANTE - massimali, compound' },
                        { intensity: 'BASSA', rpeRange: '5-6', volumeMod: 0.6, description: 'Sessione LEGGERA - recupero attivo' },
                        { intensity: 'MEDIA', rpeRange: '7', volumeMod: 0.8, description: 'Sessione MEDIA - ipertrofia' },
                        { intensity: 'MEDIO-ALTA', rpeRange: '7.5-8', volumeMod: 0.9, description: 'Sessione MEDIO-ALTA - accessori intensi' }
                    ],
                    // 5+ giorni
                    5: [
                        { intensity: 'ALTA', rpeRange: '8-9', volumeMod: 1.0, description: 'HEAVY - Lower Body' },
                        { intensity: 'MEDIA', rpeRange: '7', volumeMod: 0.8, description: 'MEDIUM - Upper Push' },
                        { intensity: 'BASSA', rpeRange: '5-6', volumeMod: 0.6, description: 'LIGHT - Active Recovery' },
                        { intensity: 'ALTA', rpeRange: '8-9', volumeMod: 1.0, description: 'HEAVY - Upper Pull' },
                        { intensity: 'MEDIA', rpeRange: '7', volumeMod: 0.8, description: 'MEDIUM - Full Body' }
                    ]
                };
                
                // Funzione per ottenere micro-periodizzazione del giorno
                function getDayMicroPeriod(dayIndex, totalDays) {
                    const pattern = microPeriodization[Math.min(totalDays, 5)] || microPeriodization[3];
                    return pattern[dayIndex % pattern.length];
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // VARIAZIONE TRA GIORNI - Focus diversi per ogni sessione
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const dayVariations = {
                    boxe: [
                        { focus: 'Power & Heavy Bag', mainExercise: 'Heavy Bag power work', conditioning: 'Power combos + explosive movements', strength: 'Lower body emphasis (Squat variations)' },
                        { focus: 'Speed & Technique', mainExercise: 'Speed Bag + Pad Work simulation', conditioning: 'Fast combos + footwork drills', strength: 'Upper body emphasis (Push/Pull)' },
                        { focus: 'Endurance & Combinations', mainExercise: 'Long rounds + combo chains', conditioning: 'Extended rounds + circuit', strength: 'Full body conditioning' }
                    ],
                    calcio: [
                        { focus: 'Speed & Acceleration', mainExercise: 'Sprint work', conditioning: 'Short sprints + agility', strength: 'Power (jumps, Olympic lifts)' },
                        { focus: 'Endurance & Repeated Sprints', mainExercise: 'RSA training', conditioning: 'Tempo runs + intervals', strength: 'Strength endurance' },
                        { focus: 'Agility & Change of Direction', mainExercise: 'COD drills', conditioning: 'Reactive agility', strength: 'Single-leg focus' }
                    ],
                    basket: [
                        { focus: 'Vertical Power', mainExercise: 'Jump training', conditioning: 'Court sprints', strength: 'Lower body power' },
                        { focus: 'Lateral Movement', mainExercise: 'Defensive slides', conditioning: 'Lane agility', strength: 'Core + hip stability' },
                        { focus: 'Game Conditioning', mainExercise: 'Full court work', conditioning: 'Game simulation', strength: 'Upper body + shooting endurance' }
                    ],
                    palestra: [
                        { focus: 'Push Day', mainExercise: 'Bench Press / OHP', conditioning: 'Upper body circuit', strength: 'Chest + Shoulders + Triceps' },
                        { focus: 'Pull Day', mainExercise: 'Rows / Pull-ups', conditioning: 'Back circuit', strength: 'Back + Biceps + Rear delts' },
                        { focus: 'Legs Day', mainExercise: 'Squat / Deadlift', conditioning: 'Lower body finisher', strength: 'Quads + Hamstrings + Glutes' }
                    ]
                };
                
                const sportVariations = dayVariations[sportKey] || dayVariations.palestra;

                // Next event context (match/fight) for prompt + rules
                const nextEvent = (() => {
                    try { return getNextEventActive(selectedAthlete?.id); } catch { return null; }
                })();
                const seasonPhase = (() => {
                    try { return inferSeasonPhaseForAthlete(selectedAthlete, nextEvent); } catch { return null; }
                })();
                const nextEventDate = String(nextEvent?.date || '').trim();
                const nextEventName = String(nextEvent?.name || '').trim();

                for (let i = 0; i < selectedDays.length; i++) {
                    const day = selectedDays[i];
                    const dayNumber = i + 1;
                    const dayVariation = sportVariations[i % sportVariations.length];

                    const matchDayType = nextEventDate ? computeMatchDayTypeForWorkoutDay(day, nextEventDate) : null;

                    const md0Mode = String(nextEvent?.md0_mode || 'off');

                    const matchWeekDirective = (() => {
                        if (!matchDayType) return '';
                        if (matchDayType === 'md0') {
                            if (md0Mode === 'primer') {
                                return [
                                    'MATCH-DAY (MD0): oggi Ã¨ gara/match. ModalitÃ : MICRO-PRIMER.',
                                    'Crea SOLO un primer 10â€“15 min: mobilitÃ  + attivazione + 2-4 accelerazioni/low jumps easy + respirazione.',
                                    'Vietati: lower heavy, volume alto, plyo high-impact, HIIT, lavoro a cedimento, DOMS.'
                                ].join('\n');
                            }
                            return [
                                'MATCH-DAY (MD0): oggi Ã¨ gara/match. ModalitÃ : OFF totale da training extra.',
                                'Non creare un workout per oggi.',
                                'Vietati: lower heavy, volume alto, plyo high-impact, HIIT, lavoro a cedimento, DOMS.'
                            ].join('\n');
                        }
                        if (matchDayType === 'md-1') {
                            return [
                                'MD-1: priming (basso volume, alta qualitÃ ).',
                                'Vietati: eccentrici massacranti (Nordic/Copenhagen), lower heavy + volume, plyo high-impact, HIIT.'
                            ].join('\n');
                        }
                        if (matchDayType === 'md+1') {
                            return [
                                'MD+1: recovery (zone2 easy/mobility/reset).',
                                'Vietati: lower heavy, plyo high-impact, HIIT, volume alto.'
                            ].join('\n');
                        }
                        return `Match-day context: ${matchDayType} (riduci volume/DOMS)`;
                    })();

                    // MD0 behavior is configurable per atleta
                    if (matchDayType === 'md0' && md0Mode !== 'primer') {
                        try {
                            addAIMessageSafe('recovery', `MD0 (${dayLabel[day] || day}): gara/match â†’ OFF (nessun workout generato).`, 'high');
                        } catch {
                            // ignore
                        }
                        continue;
                    }
                    
                    // Usa WeeklyLogic per contesto "umano"
                    let weeklyLogicContext = '';
                    let dayFocusName = dayVariation.focus;
                    if (window.WeeklyLogic) {
                        try {
                            weeklyLogicContext = window.WeeklyLogic.getDayContext(sportKey, dayNumber, currentWeek, workouts);
                            const weekPlan = window.WeeklyLogic.getWeekPlan(sportKey, currentWeek);
                            dayFocusName = weekPlan.days[dayNumber - 1]?.name || dayVariation.focus;
                        } catch (e) {
                            console.warn('WeeklyLogic error:', e);
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // MICRO-PERIODIZZAZIONE - IntensitÃ  del giorno
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const dayMicroPeriod = getDayMicroPeriod(i, selectedDays.length);
                    const microPeriodText = `
ðŸŽ¯ INTENSITÃ€ GIORNO: ${dayMicroPeriod.intensity}
- RPE Target: ${dayMicroPeriod.rpeRange}
- ${dayMicroPeriod.description}
- Volume: ${Math.round(dayMicroPeriod.volumeMod * 100)}% del normale`;

                    const coachPlaybookText = window.CoachPlaybook?.buildPromptSnippet
                        ? window.CoachPlaybook.buildPromptSnippet({
                            sport: sportKey,
                            phase: phase,
                            seasonPhase: seasonPhase,
                            matchDayType: matchDayType,
                            matchDay0Mode: md0Mode,
                            dayNumber,
                            microPeriod: dayMicroPeriod
                        })
                        : '';
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ðŸ§  SPORT INTELLIGENCE HUB - Expert Multi-Sport AI System
                    // Genera contesto esperto per il prompt AI
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let sportIntelligenceText = '';
                    let sportAlerts = [];
                    if (window.SportIntelligenceHub) {
                        try {
                            const intelligenceContext = {
                                sport: sportKey,
                                phase: phase,
                                seasonPhase: seasonPhase,
                                matchDayType: matchDayType,
                                dayNumber: dayNumber,
                                totalDays: selectedDays.length,
                                currentWeek: currentWeek,
                                microPeriod: dayMicroPeriod,
                                previousWorkouts: workouts.map(summarizeWorkoutForContext)
                            };
                            
                            const workoutHistory = workouts.map(w => ({
                                day: w.day_of_week,
                                exercises: (w.exercises || []).map(e => ({ name: e.name, type: e.type, sets: e.sets }))
                            }));
                            
                            const intelligence = window.SportIntelligenceHub.generateIntelligence(
                                selectedAthlete,
                                intelligenceContext,
                                workoutHistory
                            );
                            
                            if (intelligence?.promptInjection) {
                                sportIntelligenceText = intelligence.promptInjection;
                                console.log(`ðŸ§  Sport Intelligence Hub: ${sportKey.toUpperCase()} - ${intelligence.expertise?.methodology || 'standard'}`);
                            }
                            
                            if (intelligence?.adaptation?.alerts?.length > 0) {
                                sportAlerts = intelligence.adaptation.alerts;
                                console.log(`âš ï¸ Sport Intelligence Alerts:`, sportAlerts.map(a => a.message));
                            }
                        } catch (e) {
                            console.warn('Sport Intelligence Hub error:', e);
                        }
                    }
                    
                    console.log(`ðŸ“Š Micro-period ${day}: ${dayMicroPeriod.intensity} (RPE ${dayMicroPeriod.rpeRange})`);
                    
                    addAIMessageSafe('strength', `Costruisco ${dayLabel[day] || day} (giorno ${dayNumber}/${selectedDays.length}) - ${dayFocusName} [${dayMicroPeriod.intensity}]...`, 'medium');

                    const weekSoFar = workouts.length ? `WEEK SO FAR:\n${workouts.map(summarizeWorkoutForContext).join('\n')}` : 'WEEK SO FAR: N/A';
                    
                    // Contesto coach umano + variazione
                    const variationInstructions = [
                        weeklyLogicContext,
                        workouts.length > 0 ? `\nâ›” NON RIPETERE questi esercizi giÃ  usati questa settimana:` : '',
                        workouts.length > 0 ? workouts.flatMap(w => (w.exercises || []).slice(0, 4).map(e => `  - ${e.name?.substring(0, 50)}`)).join('\n') : ''
                    ].filter(Boolean).join('\n');
                    
                    const dayCtx = [
                        ctxText,
                        weekSoFar,
                        variationInstructions,
                        microPeriodText, // â† AGGIUNTO: micro-periodizzazione
                        matchWeekDirective,
                        `\nOBIETTIVO: costruisci SOLO il workout di ${dayLabel[day] || day} (day_of_week=\"${day}\").`,
                        (nextEventDate || nextEventName) ? `CONTESTO EVENTO: ${nextEventName || 'N/A'} | data=${nextEventDate || 'N/A'} | questo workout=${matchDayType || 'N/A'}` : '',
                        // Durata target dall'atleta
                        (() => {
                            try {
                                const pillars = selectedAthlete?.anamnesis?.pillars;
                                if (pillars?.session_duration_minutes) {
                                    return `â±ï¸ DURATA TARGET: ${pillars.session_duration_minutes} minuti (preferenza atleta)`;
                                }
                                const schedule = selectedAthlete?.schedule;
                                if (schedule?.session_duration) {
                                    return `â±ï¸ DURATA TARGET: ${schedule.session_duration} minuti`;
                                }
                            } catch {}
                            return 'â±ï¸ DURATA TARGET: ~60 minuti (default)';
                        })(),
                        Number.isFinite(focusStrengthPct) ? `Focus forza: ${focusStrengthPct}% (adatta contenuto/volume).` : '',
                        mustIncludeBoxingCircuit ? 'BOXE: questa settimana deve contenere almeno 1 "Circuit:" dalla libreria.' : ''
                    ].filter(Boolean).join('\n');

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // USA PROMPT COMPATTO (ridotto da ~3500 a ~1800 token)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const promptDay = buildCompactPrompt(dayCtx, {
                        libText,
                        templateText,
                        periodizationText,
                        feedbackText,
                        trainingMethodsText,
                        coachPlaybookText,
                        sportIntelligenceText,
                        sportIntelligenceText,
                        focusPct,
                        focusStrengthPct
                    });

                    promptsByDay.push(promptDay);
                    
                    // Log dimensione prompt per debug
                    console.log(`ðŸ“ Prompt ${day}: ${promptDay.length} chars (~${Math.round(promptDay.length/4)} tokens)`);

                    // Retry wrapper per errori di rete/timeout
                    let content;
                    let apiRetries = 0;
                    const maxApiRetries = 2;
                    
                    while (apiRetries <= maxApiRetries) {
                        try {
                            const response = await groqChat({
                                model: GROQ_MODELS.main,
                                temperature: 0.4,
                                max_tokens: 2500,
                                messages: [
                                    { role: 'system', content: "Preparatore atletico d'elite. Output: SOLO JSON workout valido. Schema: {day_of_week,name,estimated_duration_minutes,exercises:[{name,sets,reps,rest,type}]}" },
                                    { role: 'user', content: promptDay }
                                ]
                            });
                            content = response.content;
                            break; // Success
                        } catch (apiErr) {
                            apiRetries++;
                            const errMsg = String(apiErr.message || apiErr);
                            
                            // Rate limit - aspetta e riprova
                            if (errMsg.includes('429') || errMsg.includes('rate_limit') || errMsg.includes('Rate limit')) {
                                const waitMatch = errMsg.match(/(\d+\.?\d*)\s*s/);
                                const waitTime = waitMatch ? Math.ceil(parseFloat(waitMatch[1]) * 1000) + 1000 : 20000;
                                console.warn(`âš ï¸ Rate limit hit, waiting ${waitTime}ms...`);
                                addAIMessageSafe('recovery', `â³ Rate limit, attendo ${Math.ceil(waitTime/1000)}s...`, 'low');
                                await new Promise(r => setTimeout(r, waitTime));
                                // Don't count this as a retry
                                apiRetries--;
                                continue;
                            }
                            
                            if (apiRetries <= maxApiRetries && (errMsg.includes('timeout') || errMsg.includes('timed out') || errMsg.includes('network') || errMsg.includes('503') || errMsg.includes('502'))) {
                                console.warn(`âš ï¸ API retry ${apiRetries}/${maxApiRetries} for ${day}: ${errMsg}`);
                                addAIMessageSafe('recovery', `âš ï¸ Timeout ${day}, riprovo (${apiRetries}/${maxApiRetries})...`, 'low');
                                await new Promise(r => setTimeout(r, 2000 * apiRetries)); // Backoff
                            } else {
                                // Non-retryable error or max retries reached - use fallback for this day
                                console.error(`âŒ API failed for ${day} after ${apiRetries} retries:`, errMsg);
                                const fallbackWorkout = getFallbackForDay(sportKey, day, dayNumber);
                                workouts.push(fallbackWorkout);
                                addAIMessageSafe('recovery', `âš ï¸ ${dayLabel[day] || day}: usato fallback (${errMsg.substring(0, 50)}...)`, 'medium');
                                content = null;
                                break;
                            }
                        }
                    }
                    
                    // Skip to next day if we used fallback
                    if (!content) continue;

                    console.log('ðŸ¤– MAIN AI RESPONSE for', day, ':', content?.substring(0, 600));

                    let w;
                    try {
                        w = parseAiJsonOrThrow(content, `Workout (${day})`);
                        console.log('ðŸ¤– PARSED WORKOUT exercises:', w?.exercises?.length);
                    } catch {
                        throw new Error(`JSON workout non trovato (${day})`);
                    }
                    w.day_of_week = day;
                    if (allowedDays.size && !allowedDays.has(String(w?.day_of_week || '').toLowerCase())) w.day_of_week = day;
                    w = normalizeWorkout(w);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // POST-PROCESS: Correggi errori comuni AI (v2.1)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    console.log('ðŸ”§ POST-PROCESSOR v2.1 running on', w?.exercises?.length, 'exercises');
                    if (Array.isArray(w?.exercises)) {
                        w.exercises = w.exercises.map(ex => {
                            let name = String(ex.name || '');
                            let modified = false;
                            
                            // 1. Fix coerenza rounds/sets (pattern piÃ¹ robusto)
                            // Cerca "X rounds" nel nome dell'esercizio
                            const roundsMatch = name.match(/(\d+)\s*rounds?/i);
                            if (roundsMatch) {
                                const expectedSets = parseInt(roundsMatch[1], 10);
                                const currentSets = parseInt(ex.sets, 10) || 0;
                                if (expectedSets !== currentSets && expectedSets >= 2 && expectedSets <= 20) {
                                    console.log(`ðŸ”§ FIX ROUNDS: "${name.substring(0, 40)}..." â†’ sets ${currentSets} â†’ ${expectedSets}`);
                                    ex.sets = expectedSets;
                                    modified = true;
                                }
                            }
                            
                            // 2. Cerca anche pattern "Xx" tipo "8x3min"
                            if (!modified) {
                                const xMatch = name.match(/(\d+)\s*x\s*\d+\s*min/i);
                                if (xMatch) {
                                    const expectedSets = parseInt(xMatch[1], 10);
                                    const currentSets = parseInt(ex.sets, 10) || 0;
                                    if (expectedSets !== currentSets && expectedSets >= 2 && expectedSets <= 20) {
                                        console.log(`ðŸ”§ FIX XxMIN: "${name.substring(0, 40)}..." â†’ sets ${currentSets} â†’ ${expectedSets}`);
                                        ex.sets = expectedSets;
                                        modified = true;
                                    }
                                }
                            }
                            
                            // 3. Sanitize rest invalido (N/A, null, undefined)
                            const restStr = String(ex.rest || '').toLowerCase().trim();
                            const restSeconds = parseInt(restStr) || 0;
                            const nameLower = name.toLowerCase();
                            const isInterval = nameLower.includes('interval') || nameLower.includes('round') || nameLower.includes('circuit');
                            const isSuperset1 = nameLower.includes('a1:') || nameLower.includes('b1:') || nameLower.includes('c1:');
                            const sets = parseInt(ex.sets, 10) || 0;
                            
                            // 3a. Se Ã¨ interval/rounds con rest 0 E ha piÃ¹ di 1 set â†’ ERRORE
                            if (isInterval && restSeconds === 0 && sets > 1 && !isSuperset1) {
                                ex.rest = '60s'; // Rest tra i round
                                console.log(`ðŸ”§ FIX REST INTERVAL: "${name.substring(0, 30)}..." â†’ rest "60s" (era 0s con ${sets} sets)`);
                            }
                            // 3b. Sanitize rest completamente invalido
                            else if (!restStr || restStr === 'n/a' || restStr === 'null' || restStr === 'undefined') {
                                const type = String(ex.type || '').toLowerCase();
                                if (isSuperset1) {
                                    ex.rest = '0s'; // Superset first exercise
                                } else if (type === 'strength') {
                                    ex.rest = '120s';
                                } else if (type === 'hypertrophy') {
                                    ex.rest = '60s';
                                } else if (isInterval) {
                                    ex.rest = '60s'; // Intervals sempre con rest
                                } else {
                                    ex.rest = '60s';
                                }
                                console.log(`ðŸ”§ FIX REST: "${name.substring(0, 30)}..." â†’ rest "${ex.rest}"`);
                            }
                            
                            // 4. Sanitize reps invalido
                            const repsStr = String(ex.reps || '').trim();
                            if ((repsStr === '1' || repsStr === '') && (nameLower.includes('interval') || nameLower.includes('rounds'))) {
                                ex.reps = '3 min';
                                console.log(`ðŸ”§ FIX REPS: "${name.substring(0, 30)}..." â†’ reps "3 min"`);
                            }
                            
                            // 5. Espandi nomi generici
                            if (nameLower === 'footwork ladder drills' || nameLower === 'footwork ladder') {
                                ex.name = 'Footwork Ladder: Ali Shuffle + In-Out + Carioca';
                                console.log(`ðŸ”§ FIX NAME: generico â†’ specifico`);
                            }
                            
                            return ex;
                        });
                        console.log('ðŸ”§ POST-PROCESSOR completed');
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ðŸ”¬ CONSTRAINT ENGINE - Validazione e correzione DETERMINISTICA
                    // L'AI genera, il ConstraintEngine FORZA conformitÃ  scientifica
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (window.ConstraintEngine) {
                        try {
                            console.log('ðŸ”¬ ConstraintEngine: Validating and enforcing scientific constraints...');
                            console.log('ðŸ”¬ BEFORE ConstraintEngine - exercises:', w.exercises?.map(e => `${e.name?.substring(0,30)} [${e.type}]`));
                            
                            const constraintResult = window.ConstraintEngine.enforceAll(w, sportKey);
                            
                            console.log('ðŸ”¬ AFTER ConstraintEngine - exercises:', constraintResult.workout?.exercises?.map(e => `${e.name?.substring(0,30)} [${e.type}]`));
                            
                            if (constraintResult.report.constraintsApplied > 0) {
                                console.log(`ðŸ”¬ ConstraintEngine: ${constraintResult.report.constraintsApplied} correzioni applicate`);
                                constraintResult.report.fixes.forEach(fix => {
                                    console.log(`  âš™ï¸ ${fix.type}: ${fix.message}`);
                                });
                                
                                // Mostra messaggio all'utente
                                addAIMessageSafe('biomech', 
                                    `ðŸ”¬ Quality Engine: ${constraintResult.report.constraintsApplied} ottimizzazioni scientifiche applicate a ${dayLabel[day] || day}`, 
                                    'high');
                            }
                            
                            // Warnings (non bloccanti)
                            if (constraintResult.report.warnings.length > 0) {
                                constraintResult.report.warnings.forEach(warn => {
                                    console.log(`  âš ï¸ Warning: ${warn.message}`);
                                });
                            }
                            
                            // Applica workout corretto
                            w = constraintResult.workout;
                            
                            console.log(`ðŸ”¬ ConstraintEngine: ${constraintResult.report.summary}`);
                        } catch (e) {
                            console.warn('ConstraintEngine error (non-blocking):', e);
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // FALLBACK: Se il parsing non ha prodotto esercizi, usa fallback
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const exCount = Array.isArray(w?.exercises) ? w.exercises.length : 0;
                    if (exCount < 3) {
                        console.warn(`âš ï¸ Workout ${day} ha solo ${exCount} esercizi, uso fallback sport-specific`);
                        const fallbackW = getFallbackForDay(sportKey, day, dayNumber);
                        w.exercises = fallbackW.exercises;
                        w.name = w.name || fallbackW.name;
                        addAIMessageSafe('recovery', `ðŸ”„ ${dayLabel[day] || day}: integrato con esercizi fallback (${w.exercises.length} totali)`, 'medium');
                    }

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // VALIDATION + RETRY LOOP (max 3 tentativi per 99% affidabilitÃ )
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // VALIDAZIONE INTELLIGENTE (solo issue critici richiedono fix)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let retryCount = 0;
                    const maxRetries = 2; // Ridotto: con validazione intelligente servono meno retry
                    let lastIssues = [];
                    
                    while (retryCount < maxRetries) {
                        const issues = validateWorkoutLogic(w);
                        lastIssues = issues;
                        
                        if (issues.length === 0) {
                            console.log(`âœ… Workout ${day} validato al tentativo ${retryCount + 1}`);
                            break;
                        }
                        
                        retryCount++;
                        const issueText = issues.join(', ');
                        
                        if (retryCount < maxRetries) {
                            addAIMessageSafe('recovery', `Quality gate: correggo ${dayLabel[day] || day} (${issueText})`, 'medium');
                            try {
                                let fixedW = await fixWorkoutIfNeeded(dayCtx, w, issues, coachPlaybookText);
                                fixedW.day_of_week = day;
                                w = normalizeWorkout(fixedW);
                                console.log(`ðŸ”§ Fix applicato per ${day}`);
                            } catch (e) {
                                console.warn(`Fix tentativo ${retryCount} fallito:`, e);
                            }
                        } else {
                            // Accetta con warning (issues non critici)
                            console.log(`â„¹ï¸ Workout ${day} ha warning ma Ã¨ accettabile:`, issues);
                        }
                    }

                    // Expert micro-discussion: can be expensive on local models, so run only when it adds value.
                    const shouldRunExpertCouncil = (i === 0) || (i === selectedDays.length - 1) || (lastIssues.length > 0);
                    if (shouldRunExpertCouncil) {
                    try {
                        const critiqueExperts = (() => {
                            const sport = String(selectedAthlete?.sport || '').toLowerCase();
                            if (sport === 'boxe') return ['athletic', 'recovery', 'technique'];
                            if (sport === 'calcio' || sport === 'basket') return ['athletic', 'recovery'];
                            return ['technique', 'recovery'];
                        })();

                        for (const ek of critiqueExperts) setExpertThinking(ek, true);
                        const before = JSON.stringify(w);
                        const review = await dayCouncilReviewAndRevise(dayCtx, w, critiqueExperts);

                        const critiques = review?.critiques && typeof review.critiques === 'object' ? review.critiques : {};
                        for (const ek of critiqueExperts) {
                            const msg = String(critiques?.[ek] || '').trim();
                            if (msg) addAIMessageSafe(ek, msg, 'medium');
                        }

                        if (review?.revised_workout && typeof review.revised_workout === 'object') {
                            const candidateW = normalizeWorkout(review.revised_workout);
                            candidateW.day_of_week = day;
                            
                            // âš ï¸ ACCETTA IL REVISED SOLO SE HA ALMENO 4 ESERCIZI
                            // Altrimenti il council ha fallito e manteniamo l'originale
                            const candidateExCount = Array.isArray(candidateW?.exercises) ? candidateW.exercises.length : 0;
                            const originalExCount = Array.isArray(w?.exercises) ? w.exercises.length : 0;
                            
                            if (candidateExCount >= 4 && candidateExCount >= originalExCount - 2) {
                                w = candidateW;
                                console.log(`âœ… Council accepted for ${day}: ${candidateExCount} exercises`);
                            } else {
                                console.warn(`âš ï¸ Council rejected for ${day}: revised has ${candidateExCount} vs original ${originalExCount} exercises`);
                            }
                        }

                        const issues2 = validateWorkoutLogic(w);
                        if (issues2.length) {
                            try {
                                const beforeFix = w;
                                const beforeCount = Array.isArray(beforeFix?.exercises) ? beforeFix.exercises.length : 0;
                                
                                let fixedW = await fixWorkoutIfNeeded(dayCtx, w, issues2, coachPlaybookText);
                                fixedW.day_of_week = day;
                                fixedW = normalizeWorkout(fixedW);
                                
                                const afterCount = Array.isArray(fixedW?.exercises) ? fixedW.exercises.length : 0;
                                
                                // âš ï¸ ACCETTA IL FIX SOLO SE HA ALMENO 4 ESERCIZI E NON PEGGIORA
                                if (afterCount >= 4 && (afterCount >= beforeCount || afterCount >= 5)) {
                                    w = fixedW;
                                    console.log(`âœ… Fix accepted for ${day}: ${afterCount} exercises`);
                                } else {
                                    console.warn(`âš ï¸ Fix rejected for ${day}: would reduce from ${beforeCount} to ${afterCount} exercises`);
                                }
                            } catch {
                                // keep
                            }
                        }

                        const after = JSON.stringify(w);
                        if (before !== after) addAIMessageSafe('strength', `<i class="fas fa-circle-check" aria-hidden="true"></i> ${dayLabel[day] || day}: integrati i feedback degli esperti.`, 'high');
                    } catch {
                        // ignore expert loop errors
                    } finally {
                        try {
                            const sport = String(selectedAthlete?.sport || '').toLowerCase();
                            const critiqueExperts = sport === 'boxe'
                                ? ['athletic', 'recovery', 'technique']
                                : (sport === 'calcio' || sport === 'basket')
                                    ? ['athletic', 'recovery']
                                    : ['technique', 'recovery'];
                            for (const ek of critiqueExperts) setExpertThinking(ek, false);
                        } catch {
                            // ignore
                        }
                    }
                    }

                    if (!Array.isArray(w?.exercises)) w.exercises = [];

                    if (w.exercises.some(e => /circuit:/.test(String(e?.name || '').toLowerCase()))) circuitIncluded = true;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // LOG METRICHE PRE POST-PROCESSING (per debug)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (window.WorkoutIntelligence) {
                        const preMetrics = window.WorkoutIntelligence.calculateMetrics(w);
                        console.log(`ðŸ“Š ${day} PRE: ${preMetrics.exerciseCount} ex, ${preMetrics.totalSets} sets, ~${preMetrics.estimatedDurationMinutes}min`);
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // POST-PROCESSING: Correzioni soft (non distruttive)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (window.WorkoutPostProcessor) {
                        try {
                            const beforePP = JSON.stringify(w);
                            
                            // Passa contesto atleta + periodizzazione + feedback modifiers
                            const athleteContext = {
                                experience_level: selectedAthlete?.experience_level || 'intermediate',
                                compliance: parseInt((document.getElementById('ctx-compliance')?.textContent || '100').replace('%','')) || 100,
                                periodization: periodizationParams, // overridden below with per-day copy if needed
                                feedbackModifiers: feedbackModifiers // Aggiunto per adattamenti da feedback
                            };
                            
                            // Applica feedback modifiers se presenti
                            if (feedbackModifiers && periodizationParams) {
                                const baseVol = periodizationParams.volume;
                                const baseInt = periodizationParams.intensity;
                                const adjustedVol = Math.round(baseVol * feedbackModifiers.volumeMultiplier);
                                const adjustedInt = Math.round(baseInt * feedbackModifiers.intensityMultiplier);

                                // IMPORTANT: do not mutate shared periodizationParams across days.
                                athleteContext.periodization = {
                                    ...periodizationParams,
                                    volume: adjustedVol,
                                    intensity: adjustedInt
                                };
                                
                                if (feedbackModifiers.volumeMultiplier !== 1 || feedbackModifiers.intensityMultiplier !== 1) {
                                    console.log(`ðŸ“‰ Feedback modifiers applied: vol ${baseVol}â†’${adjustedVol}%, int ${baseInt}â†’${adjustedInt}%`);
                                }
                                
                                // Log exercises to avoid
                                if (feedbackModifiers.avoidExercises?.length > 0) {
                                    console.log('âš ï¸ Exercises to avoid (from feedback):', feedbackModifiers.avoidExercises);
                                }
                            }
                            
                            w = window.WorkoutPostProcessor.process(w, sportKey, phase, athleteContext);
                            const afterPP = JSON.stringify(w);
                            
                            if (beforePP !== afterPP) {
                                const corrections = w._corrections || [];
                                if (corrections.length > 0) {
                                    console.log(`ðŸ”§ Post-processing applied to ${day}:`, corrections);
                                    addAIMessageSafe('recovery', `ðŸ”§ ${dayLabel[day] || day}: ${corrections.length} correzioni automatiche applicate`, 'medium');
                                }
                            }
                            
                            // Final strict validation
                            const strictIssues = window.WorkoutPostProcessor.strictValidate(w, sportKey, phase);
                            if (strictIssues.length > 0) {
                                console.warn(`âš ï¸ Strict validation issues for ${day}:`, strictIssues);
                            }
                        } catch (ppErr) {
                            console.warn('Post-processing error:', ppErr);
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // LOG METRICHE FINALI (dopo post-processing)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (window.WorkoutIntelligence) {
                        const finalMetrics = window.WorkoutIntelligence.calculateMetrics(w);
                        console.log(`ðŸ“Š ${day} FINAL: ${finalMetrics.exerciseCount} ex, ${finalMetrics.totalSets} sets, ~${finalMetrics.estimatedDurationMinutes}min, methods: ${finalMetrics.methodsUsed.join(', ') || 'nessuna'}`);
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ðŸ”¬ CONSTRAINT ENGINE FINALE - Dopo tutti i fix/council
                    // Questo Ã¨ il passo DEFINITIVO che forza la conformitÃ 
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (window.ConstraintEngine) {
                        try {
                            console.log('ðŸ”¬ FINAL ConstraintEngine: Enforcing order AFTER all fixes...');
                            const finalConstraintResult = window.ConstraintEngine.enforceAll(w, sportKey);
                            
                            if (finalConstraintResult.report.constraintsApplied > 0) {
                                console.log(`ðŸ”¬ FINAL ConstraintEngine: ${finalConstraintResult.report.constraintsApplied} correzioni finali`);
                                finalConstraintResult.report.fixes.forEach(fix => {
                                    console.log(`  âš™ï¸ FINAL ${fix.type}: ${fix.message}`);
                                });
                            }
                            
                            w = finalConstraintResult.workout;
                            console.log('ðŸ”¬ FINAL order:', w.exercises?.map(e => `${e.name?.substring(0,25)}[${e.type}]`).join(' â†’ '));
                        } catch (e) {
                            console.warn('FINAL ConstraintEngine error:', e);
                        }
                    }
                    
                    workouts.push(w);
                    
                    // â³ Delay tra i giorni per evitare rate limiting
                    if (i < selectedDays.length - 1) {
                        await new Promise(r => setTimeout(r, 1500));
                    }
                }

                if (mustIncludeBoxingCircuit && !circuitIncluded) {
                    addAIMessageSafe('recovery', 'BOXE: aggiungo un circuito (obbligatorio) al primo giorno.', 'medium');
                    const circuit = (Array.isArray(lib?.conditioning) ? lib.conditioning : []).find(x => /^circuit:/i.test(String(x || '').trim()));
                    if (circuit && workouts[0]) {
                        workouts[0].exercises = Array.isArray(workouts[0].exercises) ? workouts[0].exercises : [];
                        workouts[0].exercises.push({ name: String(circuit), sets: 1, reps: 'come da template', type: 'conditioning' });
                        if (workouts[0].exercises.length > 10) workouts[0].exercises = workouts[0].exercises.slice(0, 10);
                    }
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SAVE TO HISTORY (for progression context)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (window.WorkoutHistory && selectedAthlete?.id) {
                    try {
                        for (const workout of workouts) {
                            window.WorkoutHistory.save(selectedAthlete.id, currentWeek, workout);
                        }
                        console.log(`ðŸ“š Saved ${workouts.length} workouts to history for week ${currentWeek}`);
                        
                        // Salva anche dati settimanali per periodizzazione
                        if (periodizationParams) {
                            const avgRpe = parseFloat((document.getElementById('ctx-rpe')?.textContent || '').replace(/[^0-9.]/g, '')) || 0;
                            const compliance = parseInt((document.getElementById('ctx-compliance')?.textContent || '100').replace('%','')) || 100;
                            const hrv = parseFloat((document.getElementById('ctx-hrv')?.textContent || '').replace(/[^0-9.]/g, '')) || 0;
                            
                            window.WorkoutHistory.saveWeekData(selectedAthlete.id, currentWeek, {
                                avgRpe,
                                compliance,
                                hrv,
                                phase: periodizationParams.phase,
                                volumePct: periodizationParams.volume,
                                intensityPct: periodizationParams.intensity,
                                notes: periodizationParams.focus
                            });
                        }
                    } catch (histErr) {
                        console.warn('History save error:', histErr);
                    }
                }

                currentWeekPlan = { week_number: currentWeek, phase, workouts };
                selectedWorkoutIndex = 0;
                selectWorkoutFromWeek(0);

                // Calculate overall week confidence
                let weekConfidenceSum = 0;
                for (const w of workouts) {
                    const conf = calculateWorkoutConfidence(w, { phase });
                    weekConfidenceSum += conf.score;
                }
                const avgConfidence = Math.round(weekConfidenceSum / Math.max(1, workouts.length));
                const weekConfidenceLevel = avgConfidence >= 80 ? 'high' : avgConfidence >= 60 ? 'medium' : 'low';
                
                // Log decisions for week generation
                addAIDecision('calendar-week', `Settimana ${currentWeek} generata`, `${workouts.length} workout, confidence media ${avgConfidence}%`);
                logAISuccess('week_generation', { phase, workoutCount: workouts.length, avgConfidence });

                // Traceability
                const hashes = workouts.map(w => {
                    try { return hashString(JSON.stringify(w.exercises || [])); } catch { return null; }
                }).filter(Boolean);

                lastAiRun = {
                    id: crypto?.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`,
                    created_at: nowIso(),
                    model_main: GROQ_MODELS.main,
                    model_fast: GROQ_MODELS.fast,
                    model_review: GROQ_MODELS.review,
                    prompt: 'DAY_BY_DAY_V1',
                    prompts_by_day: promptsByDay,
                    ctxText,
                    raw: null,
                    parsed: { week_number: currentWeek, phase, workouts },
                    week_workout_hashes: hashes,
                    expert_outputs: lastAiRun?.expert_outputs || {},
                    wearable: latestWearableData || null,
                    week_confidence: avgConfidence
                };

                // Optional reviewer: best-effort on first workout only
                try {
                    const first = workouts[0];
                    const review = await reviewWorkoutAI(ctxText, { title: first?.name || 'Workout', exercises: first?.exercises || [] });
                    lastAiRun.review = review;
                    if (review?.risk === 'high') {
                        addAIMessageSafe('recovery', `<i class="fas fa-triangle-exclamation" aria-hidden="true"></i> Review sicurezza (primo workout): RISCHIO ALTO. ${review.notes || ''}`.trim(), 'medium');
                        addAIDecision('shield-exclamation', 'Review: RISCHIO ALTO', review.notes || '');
                    } else if (review?.risk === 'medium') {
                        addAIMessageSafe('recovery', `Review (primo workout): rischio medio. ${review.notes || ''}`.trim(), 'medium');
                        addAIDecision('shield-alt', 'Review: rischio medio', review.notes || '');
                    } else if (review?.notes) {
                        addAIMessageSafe('recovery', `Review (primo workout) ok. ${review.notes}`.trim(), 'high');
                        addAIDecision('shield-check', 'Review: OK', review.notes || '');
                    }
                } catch (reviewErr) {
                    logAIError('review', reviewErr, { phase });
                }

                // Show overall confidence in chat
                const confEmoji = weekConfidenceLevel === 'high' ? 'âœ…' : weekConfidenceLevel === 'medium' ? 'âš ï¸' : 'âŒ';
                addAIMessageSafe('strength', `${confEmoji} Settimana completata con confidence <strong>${avgConfidence}%</strong>`, 'high');
                
                // 110/100: Show recovery prescription after generation
                setTimeout(() => {
                    showRecoveryPrescription();
                }, 500);

                // Persist memory (best-effort)
                if (hashes.length) {
                    await saveAIProgramState(selectedAthlete.id, {
                        history: {
                            last_phase: phase,
                            last_week: currentWeek,
                            recent_workout_hashes: (aiProgramState?.history?.recent_workout_hashes || []).concat(hashes).slice(-12),
                            last_titles: (aiProgramState?.history?.last_titles || []).concat(workouts.map(w => String(w?.name || '')).filter(Boolean)).slice(-12)
                        }
                    });
                }
            } catch (e) {
                console.error('AI week generation failed:', e);
                logAIError('week_generation', e, { phase, week: currentWeek });
                addAIDecision('times-circle', 'Generazione fallita', String(e.message || e).substring(0, 100));
                addAIMessageSafe('strength', `<i class="fas fa-triangle-exclamation" aria-hidden="true"></i> Generazione AI fallita, uso fallback (${String(e.message || e)}).`, 'medium');
                generateWorkoutFallback(phase);
            } finally {
                setExpertThinking('strength', false);
                
                // Show reliability stats in console
                const reliabilityScore = getAIReliabilityScore();
                console.log(`ðŸ“Š AI Reliability: ${reliabilityScore}% (${aiTelemetry.successes} successi, ${aiTelemetry.failures} fallimenti)`);
            }
        }

        function setExpertThinking(expertKey, isThinking) {
            const card = document.querySelector(`.expert-card[data-expert="${expertKey}"]`);
            const indicator = card.querySelector('.status-indicator');
            
            if (isThinking) {
                card.classList.add('thinking');
                indicator.classList.remove('ready');
                indicator.classList.add('thinking');
                showTypingIndicator(expertKey);
            } else {
                card.classList.remove('thinking');
                indicator.classList.remove('thinking');
                indicator.classList.add('ready');
                hideTypingIndicator();
            }
        }

        function showTypingIndicator(expertKey) {
            const expert = experts[expertKey];
            const indicator = document.getElementById('typing-indicator');
            const avatar = document.getElementById('typing-avatar');
            
            avatar.innerHTML = expert.avatarHtml;
            avatar.className = `expert-avatar ${expert.class}`;
            indicator.classList.add('show');
        }

        function hideTypingIndicator() {
            document.getElementById('typing-indicator').classList.remove('show');
        }

        function getPhaseDescription(phase) {
            const desc = {
                'Adattamento': 'Focus su <strong>tecnica</strong> e costruzione della base. Carichi 60-70%.',
                'Accumulo': 'Volume elevato per <strong>ipertrofia</strong>. Carichi 70-80%.',
                'Intensificazione': 'Carichi <strong>pesanti</strong>, volume ridotto. Focus forza 80-90%.',
                'Peaking': 'Preparazione test/gara. Volume minimo, <strong>intensitÃ  massima</strong>.',
                'Deload': 'Settimana di <strong>scarico</strong>. Recupero attivo 50-60%.'
            };
            return desc[phase] || '';
        }

        // MESSAGES
        function addAIMessage(expertKey, text, confidence = 'high') {
            const expert = experts[expertKey];
            const messages = document.getElementById('messages');
            
            const confidenceLabel = confidence === 'high' ? 'Alta confidenza' : 'Media confidenza';
            const confidenceClass = confidence === 'high' ? 'confidence-high' : 'confidence-medium';
            
            messages.insertAdjacentHTML('beforeend', `
                <div class="ai-message">
                    <div class="expert-avatar ${expert.class}">${expert.avatarHtml}</div>
                    <div class="message-bubble">
                        <div class="message-header">
                            <span class="message-author">
                                ${expert.name}
                                <span class="confidence-badge ${confidenceClass}">${confidenceLabel}</span>
                            </span>
                            <span class="message-time">${new Date().toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                        <div class="message-text">${text}</div>
                    </div>
                </div>
            `);
            
            messages.scrollTop = messages.scrollHeight;
        }

        function addCoachMessage(text) {
            const messages = document.getElementById('messages');
            messages.insertAdjacentHTML('beforeend', `
                <div class="coach-message">
                    <div class="coach-bubble">
                        <div class="message-text">${text}</div>
                    </div>
                </div>
            `);
            messages.scrollTop = messages.scrollHeight;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MESOCYCLE AUTO-PHASE DETECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getMesocyclePhase(weekNum, sport) {
            // Standard 4-week mesocycle for gym
            const standard4Week = {
                1: { phase: 'Accumulo', name: 'Adattamento', intensity: 'medium', description: 'Volume moderato, tecnica' },
                2: { phase: 'Accumulo', name: 'Accumulo', intensity: 'medium-high', description: 'Aumenta volume' },
                3: { phase: 'Intensificazione', name: 'Intensificazione', intensity: 'high', description: 'Picco intensitÃ ' },
                4: { phase: 'Deload', name: 'Deload', intensity: 'low', description: 'Recupero attivo' }
            };

            // Sport 8-week mesocycle
            const sport8Week = {
                1: { phase: 'Accumulo', name: 'GPP Base', intensity: 'low-medium', description: 'Base aerobica e forza' },
                2: { phase: 'Accumulo', name: 'GPP Volume', intensity: 'medium', description: 'Aumenta volume' },
                3: { phase: 'Accumulo', name: 'Forza Base', intensity: 'medium', description: 'Introduci lavoro forza' },
                4: { phase: 'Intensificazione', name: 'Forza Sviluppo', intensity: 'medium-high', description: 'Aumenta carichi' },
                5: { phase: 'Intensificazione', name: 'Potenza', intensity: 'high', description: 'Converti forza in potenza' },
                6: { phase: 'Peaking', name: 'Potenza Picco', intensity: 'high', description: 'Picco potenza' },
                7: { phase: 'Peaking', name: 'Specifico', intensity: 'medium-high', description: 'Sport-specifico' },
                8: { phase: 'Deload', name: 'Taper', intensity: 'low', description: 'Volume -50%, mantieni intensitÃ ' }
            };

            const sportKey = String(sport || '').toLowerCase();
            const isSport = ['calcio', 'basket', 'boxe'].includes(sportKey);
            
            if (isSport) {
                const weekMod = ((weekNum - 1) % 8) + 1;
                return sport8Week[weekMod] || sport8Week[1];
            } else {
                const weekMod = ((weekNum - 1) % 4) + 1;
                return standard4Week[weekMod] || standard4Week[1];
            }
        }

        function updatePhaseIndicator() {
            const sport = selectedAthlete?.sport || 'palestra';
            const mesocycleInfo = getMesocyclePhase(currentWeek, sport);
            
            const badge = document.getElementById('auto-phase-badge');
            const indicator = document.getElementById('phase-indicator');
            
            if (badge) {
                badge.textContent = `Week ${currentWeek}`;
            }
            if (indicator) {
                const phaseEmoji = {
                    'Accumulo': 'ðŸ“ˆ',
                    'Intensificazione': 'ðŸ”¥',
                    'Peaking': 'ðŸŽ¯',
                    'Deload': 'ðŸ›ï¸'
                };
                indicator.innerHTML = `${phaseEmoji[mesocycleInfo.phase] || 'ðŸ“…'} <strong>${mesocycleInfo.name}</strong> - ${mesocycleInfo.description}`;
            }
            
            currentPhase = mesocycleInfo.name;
            return mesocycleInfo;
        }

        function generateFromMesocycle() {
            if (!selectedAthlete) {
                addAIMessage('strength', 'âš ï¸ Seleziona prima un atleta dalla barra in alto.', 'high');
                return;
            }

            // Pre-generation validation
            const validation = validatePreGeneration(selectedAthlete.id);
            if (!validation.valid) {
                addAIMessage('strength', `âŒ ${validation.blocks.join(' | ')}`, 'high');
                return;
            }

            // Clear previous decision log
            clearAIDecisions();

            // Log: Starting generation
            addAIDecision('rocket', 'Avvio generazione workout', `Settimana ${currentWeek}`);

            const mesocycleInfo = getMesocyclePhase(currentWeek, selectedAthlete.sport);
            const extraInstructions = document.getElementById('coach-input').value.trim();

            // Log phase decision
            addAIDecision('layer-group', `Fase: ${mesocycleInfo.name}`, mesocycleInfo.description);

            // Check for match-day adjustments
            const cal = getCalendarActive(selectedAthlete.id);
            const activeEvent = getActiveEventFromCalendar(cal);
            let phaseOverride = null;

            if (activeEvent?.date) {
                const evDate = parseDateOnly(activeEvent.date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                if (evDate) {
                    evDate.setHours(0, 0, 0, 0);
                    const diffDays = Math.round((evDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) {
                        phaseOverride = 'Deload';
                        addAIDecision('fire', 'Override fase â†’ Deload', 'Oggi Ã¨ giorno di gara (MD0)');
                    } else if (diffDays === 1) {
                        phaseOverride = 'Deload';
                        addAIDecision('bolt', 'Override fase â†’ Deload', 'Domani gara (MD-1) - solo priming');
                    } else if (diffDays === 2 && mesocycleInfo.phase !== 'Deload') {
                        addAIDecision('clock', 'Riduzione volume consigliata', `MD-2 per ${activeEvent.name || 'evento'}`);
                    } else if (diffDays === -1) {
                        phaseOverride = 'Deload';
                        addAIDecision('bed', 'Override fase â†’ Recovery', 'Post-gara (MD+1)');
                    }
                }
            }

            // Check wearable adjustments
            if (latestWearableData) {
                if (latestWearableData.readiness && latestWearableData.readiness < 50) {
                    addAIDecision('battery-half', `Adattamento per readiness bassa`, `Readiness ${latestWearableData.readiness}/100`);
                }
                if (latestWearableData.sleep && latestWearableData.sleep < 6) {
                    addAIDecision('moon', `Considerato sonno ridotto`, `${latestWearableData.sleep}h`);
                }
                if (latestWearableData.hrv) {
                    addAIDecision('heartbeat', `HRV integrato nel contesto`, `${latestWearableData.hrv}ms`);
                }
            }

            // Log ruleset
            const ruleset = getRulesetProfile();
            addAIDecision('shield-alt', `Ruleset: ${ruleset}`, 'Profilo rischio/progressione');

            // Store extra instructions if any
            if (extraInstructions) {
                lastCoachInstructions = extraInstructions;
                addCoachMessage(extraInstructions);
                document.getElementById('coach-input').value = '';
                addAIDecision('comment', 'Istruzioni coach integrate', extraInstructions.substring(0, 50) + (extraInstructions.length > 50 ? '...' : ''));
            }

            const finalPhase = phaseOverride || mesocycleInfo.phase;
            const finalPhaseName = phaseOverride || mesocycleInfo.name;

            if (phaseOverride) {
                addAIMessage('recovery', `âš¡ <strong>Match-aware override</strong>: fase cambiata a <strong>${phaseOverride}</strong> per rispettare il calendario gare.`, 'high');
            }

            addAIMessage('strength', `ðŸš€ Genero <strong>Settimana ${currentWeek}</strong> - Fase: <strong>${finalPhaseName}</strong><br><small>${mesocycleInfo.description}</small>`, 'high');

            // Start consultation with the correct phase
            setTimeout(() => {
                startConsultation(
                    finalPhase, 
                    document.getElementById('ctx-rpe')?.textContent || '7.0', 
                    parseInt((document.getElementById('ctx-compliance')?.textContent || '100').replace('%','')) || 100, 
                    latestWearableData
                );
            }, 500);
        }

        // COACH INTERACTION
        function sendCoachMessage() {
            const input = document.getElementById('coach-input');
            const text = input.value.trim();
            if (!text) return;

            addCoachMessage(text);
            input.value = '';

            // AI Response
            setTimeout(() => processCoachInput(text.toLowerCase()), 600);
        }

        function quickPrompt(text) {
            document.getElementById('coach-input').value = text;
            sendCoachMessage();
        }

        function processCoachInput(text) {
            lastCoachInstructions = text;
            setExpertThinking('strength', true);

            setTimeout(() => {
                setExpertThinking('strength', false);

                if (text.includes('deload') || text.includes('scarico') || text.includes('recupero')) {
                    addAIMessage('recovery', 'Capito! Adatto il piano per una settimana di <strong>scarico</strong>. Volume -40%, intensitÃ  60-70%.', 'high');
                    startConsultation('Deload', document.getElementById('ctx-rpe').textContent || '7.0', parseInt((document.getElementById('ctx-compliance').textContent || '100').replace('%','')) || 100, latestWearableData);
                } else if (text.includes('pesante') || text.includes('intenso') || text.includes('intensitÃ ') || text.includes('forza')) {
                    addAIMessage('strength', 'Perfetto! Aumento l\'intensitÃ  a <strong>85-90%</strong>. Meno volume, piÃ¹ carico.', 'high');
                    startConsultation('Intensificazione', document.getElementById('ctx-rpe').textContent || '7.0', parseInt((document.getElementById('ctx-compliance').textContent || '100').replace('%','')) || 100, latestWearableData);
                } else if (text.includes('volume') || text.includes('ipertrofia')) {
                    addAIMessage('strength', 'Ok! Struttura orientata al <strong>volume</strong>: 4 serie, 8-12 reps, carichi moderati.', 'high');
                    startConsultation('Accumulo', document.getElementById('ctx-rpe').textContent || '7.0', parseInt((document.getElementById('ctx-compliance').textContent || '100').replace('%','')) || 100, latestWearableData);
                } else if (text.includes('tecnica') || text.includes('base')) {
                    addAIMessage('technique', 'Inserisco esercizi propedeutici con focus sulla <strong>qualitÃ  del movimento</strong>.', 'high');
                    startConsultation('Adattamento', document.getElementById('ctx-rpe').textContent || '7.0', parseInt((document.getElementById('ctx-compliance').textContent || '100').replace('%','')) || 100, latestWearableData);
                } else {
                    addAIMessage('strength', 'Ricevuto! Ho aggiornato la scheda in base alle tue indicazioni.', 'medium');
                }
            }, 800);
        }

        // Get fallback workout for a specific day (used when API fails)
        function getFallbackForDay(sport, dayOfWeek, dayNumber) {
            const sportLower = String(sport || '').toLowerCase();
            let exercises;
            
            // Sport-specific fallbacks
            if (exerciseDB[sportLower]) {
                exercises = [...exerciseDB[sportLower]];
            } else {
                exercises = [...exerciseDB.accumulo];
            }
            
            // Vary slightly by day number
            const dayVariations = {
                1: { prefix: 'Power', focus: 'strength' },
                2: { prefix: 'Speed', focus: 'conditioning' },
                3: { prefix: 'Endurance', focus: 'conditioning' }
            };
            
            const variation = dayVariations[dayNumber] || dayVariations[1];
            
            return {
                day_of_week: dayOfWeek,
                name: `${variation.prefix} Day (Fallback)`,
                estimated_duration_minutes: 50,
                exercises: exercises,
                _fallback: true
            };
        }

        // WORKOUT GENERATION (fallback)
        function generateWorkoutFallback(phase) {
            const phaseKey = phase.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            const sportKey = String(selectedAthlete?.sport || '').toLowerCase();
            
            // Prova prima fallback sport-specific, poi fase, poi default
            let exercises;
            if (exerciseDB[sportKey]) {
                exercises = exerciseDB[sportKey];
                console.log('ðŸ“‹ Using sport-specific fallback for:', sportKey);
            } else if (exerciseDB[phaseKey]) {
                exercises = exerciseDB[phaseKey];
                console.log('ðŸ“‹ Using phase fallback for:', phaseKey);
            } else {
                exercises = exerciseDB.accumulo;
                console.log('ðŸ“‹ Using default accumulo fallback');
            }
            
            currentWorkout.exercises = [...exercises];
            renderExercises();
            document.getElementById('workout-title').value = `${phase} - Sett. ${currentWeek} (Fallback)`;
            
            addAIMessageSafe('recovery', `âš ï¸ Workout di fallback generato per ${sportKey || 'generale'}. Puoi rigenerare quando la connessione Ã¨ stabile.`, 'medium');
        }

        function renderExercises() {
            const container = document.getElementById('workout-body');
            
            if (currentWorkout.exercises.length === 0) {
                container.innerHTML = `
                    <div class="exercises-empty">
                        <i class="fas fa-layer-group"></i>
                        <p>Gli esercizi appariranno qui</p>
                    </div>
                `;
                updateMeta();
                return;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX DISPLAY-TIME: Correggi errori comuni prima di renderizzare
            // NOTA: NON sovrascrivere le correzioni del ConstraintEngine!
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            currentWorkout.exercises = currentWorkout.exercises.map(ex => {
                const name = String(ex.name || '');
                const nameLower = name.toLowerCase();
                const currentSets = parseInt(ex.sets, 10) || 0;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RIMOSSO: Il fix rounds/sets dal nome sovrascriveva le correzioni
                // del ConstraintEngine. Ora il ConstraintEngine aggiorna ANCHE il nome.
                // Quindi non serve piÃ¹ questa logica qui.
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // FIX REST 0s per intervals/rounds (solo se NON Ã¨ superset A1)
                const isInterval = nameLower.includes('interval') || nameLower.includes('round') || nameLower.includes('circuit');
                const sets = parseInt(ex.sets, 10) || 0;
                const restStr = String(ex.rest || '').toLowerCase().trim();
                const isSuperset1 = nameLower.includes('a1:') || nameLower.includes('b1:') || nameLower.includes('c1:') ||
                                   nameLower.includes('(superset a1)') || nameLower.includes('superset a1');
                
                if (isInterval && (restStr === '0s' || restStr === '0') && sets > 1 && !isSuperset1) {
                    console.log(`ðŸ”§ RENDER FIX REST: "${name.substring(0, 30)}..." rest 0â†’60s`);
                    ex.rest = '60s';
                }
                
                // Espandi nomi generici
                if (nameLower === 'footwork ladder drills' || nameLower === 'footwork ladder') {
                    ex.name = 'Footwork Ladder: Ali Shuffle + In-Out + Carioca';
                }
                
                return ex;
            });

            container.innerHTML = currentWorkout.exercises.map((ex, i) => `
                <div class="exercise-card">
                    <div class="exercise-top">
                        <span class="exercise-drag"><i class="fas fa-grip-vertical"></i></span>
                        <span class="exercise-name">${ex.name}</span>
                        <span class="exercise-type type-${ex.type}">${ex.type}</span>
                    </div>
                    <div class="exercise-params">
                        <div class="param-group">
                            <div class="param-label">Serie</div>
                            <div class="param-value">${ex.sets}</div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Reps</div>
                            <div class="param-value">${ex.reps}</div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Rest</div>
                            <div class="param-value">${ex.rest || '60s'}</div>
                        </div>
                    </div>
                    <div class="exercise-actions">
                        <button class="ex-btn" onclick="editExercise(${i})"><i class="fas fa-edit"></i> Modifica</button>
                        <button class="ex-btn delete" onclick="removeExercise(${i})"><i class="fas fa-trash"></i></button>
                    </div>
                </div>
            `).join('');

            updateMeta();
            renderWeekWorkoutPicker();
        }

        function updateMeta() {
            const count = currentWorkout.exercises.length;
            const duration = count * 8;
            document.getElementById('workout-meta').innerHTML = `
                <span><i class="fas fa-dumbbell"></i> ${count} esercizi</span>
                <span><i class="fas fa-clock"></i> ~${duration} min</span>
            `;
        }

        function addExercise() {
            const allExercises = ['Squat', 'Deadlift', 'Bench Press', 'Pull-ups', 'Rows', 'Lunges', 'Shoulder Press', 'Dips'];
            const random = allExercises[Math.floor(Math.random() * allExercises.length)];
            
            currentWorkout.exercises.push({ name: random, sets: 3, reps: '10', type: 'strength' });
            renderExercises();
            
            addAIMessage('strength', `Aggiunto <strong>${random}</strong>. Vuoi regolare serie e ripetizioni?`, 'medium');
        }

        function removeExercise(index) {
            currentWorkout.exercises.splice(index, 1);
            renderExercises();
        }

        function editExercise(index) {
            // TODO: Modal per editing
            alert('Editing in arrivo!');
        }

        function regenerate() {
            if (!selectedAthlete) return;
            startConsultation(currentPhase, document.getElementById('ctx-rpe').textContent || '7.0', parseInt((document.getElementById('ctx-compliance').textContent || '100').replace('%','')) || 100, latestWearableData);
            addAIMessage('strength', 'Ho rigenerato la scheda con <strong>nuove varianti</strong>. Che ne pensi?', 'high');
        }

        // SAVE WORKOUT
        async function saveWorkout() {
            const workoutsToSave = Array.isArray(currentWeekPlan?.workouts) && currentWeekPlan.workouts.length
                ? currentWeekPlan.workouts
                : null;

            if (!selectedAthlete || (!workoutsToSave && !currentWorkout.exercises.length)) {
                alert('Seleziona atleta e aggiungi esercizi');
                return;
            }

            // If reviewer flagged high risk, require explicit confirmation.
            if (lastAiRun?.review?.risk === 'high') {
                const msg = `Review AI: RISCHIO ALTO.\n${lastAiRun.review.notes || ''}\n\nVuoi salvare comunque?`;
                if (!confirm(msg)) return;
            }

            const baseMeta = {
                ai_generated: Boolean(lastAiRun),
                ai_model_used: lastAiRun?.model_main || GROQ_MODELS.main,
                reviewed_by_coach: true
            };

            const btn = document.querySelector('.btn-assign');
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Assegno...';
            }

            try {
                const savedTitles = [];
                const savedHashes = [];

                if (workoutsToSave) {
                    for (let i = 0; i < workoutsToSave.length; i++) {
                        const w = workoutsToSave[i];
                        const name = String(w?.name || w?.title || `Workout ${i + 1}`);
                        const exs = Array.isArray(w?.exercises) ? w.exercises : [];
                        const day = String(w?.day_of_week || '').toLowerCase() || null;
                        const est = w?.estimated_duration_minutes != null ? Number(w.estimated_duration_minutes) : null;

                        const workoutRow = {
                            athlete_id: selectedAthlete.id,
                            name,
                            exercises: exs,
                            week_number: currentWeek,
                            day_of_week: day,
                            estimated_duration_minutes: Number.isFinite(est) ? est : null,
                            ...baseMeta,
                            ai_generation_prompt: lastAiRun ? JSON.stringify({
                                version: 2,
                                created_at: lastAiRun.created_at,
                                ctxText: lastAiRun.ctxText,
                                expert_outputs: lastAiRun.expert_outputs,
                                prompt: lastAiRun.prompt,
                                week_index: i,
                                review: i === 0 ? lastAiRun.review : null,
                                wearable: lastAiRun.wearable
                            }) : null
                        };

                        console.log('Saving workout:', workoutRow);
                        const result = await supabase.insert('workouts', workoutRow);
                        if (result && (result.error || result.message)) {
                            throw new Error(result.message || result.error || 'Errore sconosciuto');
                        }

                        savedTitles.push(name);
                        try { savedHashes.push(hashString(JSON.stringify(exs))); } catch {}
                    }
                } else {
                    const name = document.getElementById('workout-title').value || 'Workout AI';
                    const exs = currentWorkout.exercises;
                    const workoutRow = {
                        athlete_id: selectedAthlete.id,
                        name,
                        exercises: exs,
                        week_number: currentWeek,
                        ...baseMeta,
                        ai_generation_prompt: lastAiRun ? JSON.stringify({
                            version: 1,
                            created_at: lastAiRun.created_at,
                            ctxText: lastAiRun.ctxText,
                            expert_outputs: lastAiRun.expert_outputs,
                            prompt: lastAiRun.prompt,
                            workout_hash: lastAiRun.workout_hash,
                            review: lastAiRun.review,
                            wearable: lastAiRun.wearable
                        }) : null
                    };

                    console.log('Saving workout:', workoutRow);
                    const result = await supabase.insert('workouts', workoutRow);
                    if (result && (result.error || result.message)) {
                        throw new Error(result.message || result.error || 'Errore sconosciuto');
                    }
                    savedTitles.push(name);
                    try { savedHashes.push(hashString(JSON.stringify(exs))); } catch {}
                }

                addAIMessage('strength', `<i class="fas fa-circle-check" aria-hidden="true"></i> Workout assegnato con successo a <strong>${selectedAthlete.first_name}</strong>!`, 'high');

                // Persist memory: record that we shipped this workout
                if (savedHashes.length) {
                    await saveAIProgramState(selectedAthlete.id, {
                        history: {
                            last_phase: currentPhase,
                            last_week: currentWeek,
                            recent_workout_hashes: (aiProgramState?.history?.recent_workout_hashes || []).concat(savedHashes).slice(-12),
                            last_titles: (aiProgramState?.history?.last_titles || []).concat(savedTitles).filter(Boolean).slice(-12)
                        }
                    });
                }
                
                // Record exercises in Exercise Memory
                if (window.ExerciseMemory && workoutsToSave) {
                    workoutsToSave.forEach(w => {
                        const exNames = (w.exercises || []).map(ex => ex.name || ex.exercise_name || '').filter(Boolean);
                        if (exNames.length > 0) {
                            window.ExerciseMemory.record(selectedAthlete.id, {
                                weekNumber: currentWeek,
                                dayOfWeek: w.day_of_week,
                                exercises: exNames,
                                date: new Date().toISOString().split('T')[0]
                            });
                        }
                    });
                    console.log('ðŸ“ Esercizi registrati in Exercise Memory');
                }
                
                // 110/100: Record for Cross-Athlete Intelligence
                if (window.CrossAthleteIntelligence && workoutsToSave) {
                    try {
                        workoutsToSave.forEach(w => {
                            window.CrossAthleteIntelligence.recordSuccessfulSession({
                                athleteId: selectedAthlete.id,
                                sport: selectedAthlete.sport,
                                level: selectedAthlete.experience_level,
                                goal: aiProgramState?.anamnesis?.pillars?.primary_goal,
                                phase: currentPhase,
                                exercises: (w.exercises || []).map(ex => ({
                                    name: ex.name || ex.exercise_name,
                                    sets: ex.sets,
                                    reps: ex.reps,
                                    intensity: ex.intensity || ex.percentage
                                })),
                                weekNumber: currentWeek,
                                dayOfWeek: w.day_of_week
                            });
                        });
                        console.log('ðŸ§  Sessione registrata in Cross-Athlete Intelligence');
                    } catch (e) {
                        console.warn('CrossAthleteIntelligence record failed:', e);
                    }
                }
                
                // 110/100: Record load for Adaptive Load Optimizer
                if (window.AdaptiveLoadOptimizer && workoutsToSave) {
                    try {
                        let weekTotalLoad = 0;
                        workoutsToSave.forEach(w => {
                            const load = window.AdaptiveLoadOptimizer.calculateWorkoutLoad(w);
                            weekTotalLoad += load;
                        });
                        window.AdaptiveLoadOptimizer.recordWeeklyLoad(
                            selectedAthlete.id,
                            currentWeek,
                            weekTotalLoad,
                            {
                                avgRPE: parseFloat(document.getElementById('ctx-rpe')?.textContent) || 7,
                                compliance: parseInt((document.getElementById('ctx-compliance')?.textContent || '100').replace('%', '')) || 100,
                                sessions: workoutsToSave.length
                            }
                        );
                        console.log('ðŸ“Š Carico registrato in Adaptive Load Optimizer:', weekTotalLoad);
                    } catch (e) {
                        console.warn('AdaptiveLoadOptimizer record failed:', e);
                    }
                }
                
                // Success animation
                if (btn) {
                    btn.innerHTML = '<i class="fas fa-check"></i> Assegnato!';
                    btn.style.background = '#00D26A';
                }
                
                setTimeout(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-paper-plane"></i> Assegna Workout';
                        btn.style.background = '';
                    }
                }, 2000);
            } catch (e) {
                console.error('Error saving workout:', e);
                alert('Errore nel salvataggio: ' + String(e?.message || e || 'Errore sconosciuto'));
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-paper-plane"></i> Assegna Workout';
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ðŸ§ª AI STRESS TEST RUNNER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function runAIStressTest(options = {}) {
            if (!window.AIStressTest) {
                console.error('âŒ AIStressTest not loaded');
                return;
            }
            
            console.log('ðŸ§ª Starting AI Stress Test...');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Funzione che simula la generazione AI per un profilo test
            async function generateForProfile(profile) {
                // Costruisci il contesto come farebbe il sistema reale
                const sportKey = profile.sport;
                const phaseMap = { principiante: 'accumulo', intermedio: 'intensificazione', avanzato: 'peaking', elite: 'peaking' };
                const phase = phaseMap[profile.level] || 'accumulo';
                
                // Simula il contesto atleta
                const ctxLines = [
                    `ATLETA: ${profile.name}`,
                    `Sport: ${profile.sport.toUpperCase()}`,
                    `Ruolo: ${profile.role || profile.goal || 'N/A'}`,
                    `Livello: ${profile.level}`,
                    `EtÃ : ${profile.age} anni`,
                    `Peso: ${profile.weight}kg | Altezza: ${profile.height}cm`,
                    `Esperienza: ${profile.experience_years} anni`,
                    `Fase: ${phase}`,
                    profile.injuries?.length ? `âš ï¸ INFORTUNI: ${profile.injuries.join(', ')}` : '',
                    profile.goals?.length ? `ðŸŽ¯ OBIETTIVI: ${profile.goals.join(', ')}` : '',
                    profile.stress_level ? `Stress: ${profile.stress_level}` : '',
                    profile.sleep_hours ? `Sonno: ${profile.sleep_hours}h` : '',
                    profile.upcoming_fight ? `ðŸ¥Š MATCH: ${profile.upcoming_fight}` : '',
                    profile.fight_week ? 'âš¡ FIGHT WEEK - Scarico massimo!' : '',
                    profile.equipment ? `Attrezzatura: ${profile.equipment}` : '',
                    profile.gender === 'female' ? 'ðŸ‘© Atleta donna - considerare prevenzione ACL' : ''
                ].filter(Boolean).join('\n');
                
                // Costruisci prompt specifico per sport
                let sportRules = '';
                if (sportKey === 'boxe' && window.BoxingRules?.generatePromptRules) {
                    sportRules = window.BoxingRules.generatePromptRules();
                }
                
                const prompt = [
                    'Genera UNA singola sessione workout per questo atleta.',
                    'Output: SOLO JSON valido.',
                    '',
                    ctxLines,
                    '',
                    sportRules,
                    '',
                    'Schema JSON:',
                    '{',
                    '  "title": "Titolo workout",',
                    '  "exercises": [',
                    '    {"name":"Esercizio","sets":3,"reps":"10-12","type":"strength"}',
                    '  ]',
                    '}',
                    '',
                    'REGOLE CRITICHE:',
                    '- 5-8 esercizi totali',
                    '- Includi warm-up e cool-down',
                    '- type: strength | hypertrophy | conditioning | warmup | cooldown',
                    profile.injuries?.length ? `- âš ï¸ EVITA esercizi che stressano: ${profile.injuries.join(', ')}` : '',
                    profile.fight_week ? '- âš¡ FIGHT WEEK: Solo attivazione leggera, NO volume!' : ''
                ].filter(Boolean).join('\n');
                
                // Chiama Groq
                const response = await groqChat({
                    model: GROQ_MODELS.main,
                    temperature: 0.5,
                    max_tokens: 1200,
                    messages: [
                        { role: 'system', content: 'Sei un preparatore atletico d\'elite. Rispondi SOLO con JSON valido.' },
                        { role: 'user', content: prompt }
                    ]
                });
                
                const workout = parseAiJsonOrThrow(response.content, 'Stress Test');
                return workout;
            }
            
            // Esegui i test
            const results = await window.AIStressTest.runFullTest(generateForProfile, {
                sports: options.sports || ['calcio', 'basket', 'boxe', 'palestra'],
                maxPerSport: options.maxPerSport || 3
            });
            
            // Mostra risultati
            console.log(window.AIStressTest.formatResults(results));
            
            // Salva risultati per analisi
            window.lastStressTestResults = results;
            console.log('ðŸ’¾ Risultati salvati in window.lastStressTestResults');
            
            return results;
        }
        
        // Quick test singolo profilo
        async function testProfile(profileId) {
            if (!window.AIStressTest) {
                console.error('âŒ AIStressTest not loaded');
                return;
            }
            
            return await window.AIStressTest.testSingleProfile(profileId, async (profile) => {
                // Usa la stessa logica di runAIStressTest
                const sportKey = profile.sport;
                const phase = 'accumulo';
                
                const ctxLines = [
                    `ATLETA: ${profile.name}`,
                    `Sport: ${profile.sport.toUpperCase()}`,
                    `Ruolo: ${profile.role || profile.goal || 'N/A'}`,
                    `Livello: ${profile.level}`,
                    `EtÃ : ${profile.age} anni | Peso: ${profile.weight}kg`,
                    profile.injuries?.length ? `âš ï¸ INFORTUNI: ${profile.injuries.join(', ')}` : '',
                    profile.goals?.length ? `ðŸŽ¯ OBIETTIVI: ${profile.goals.join(', ')}` : '',
                    profile.fight_week ? 'âš¡ FIGHT WEEK!' : ''
                ].filter(Boolean).join('\n');
                
                const prompt = [
                    'Genera UNA sessione workout. Output: SOLO JSON.',
                    '',
                    ctxLines,
                    '',
                    '{"title":"...","exercises":[{"name":"...","sets":3,"reps":"10","type":"strength"}]}',
                    '',
                    '- 5-8 esercizi con warm-up e cool-down',
                    profile.injuries?.length ? `- EVITA: ${profile.injuries.join(', ')}` : ''
                ].filter(Boolean).join('\n');
                
                const response = await groqChat({
                    model: GROQ_MODELS.main,
                    temperature: 0.5,
                    max_tokens: 1200,
                    messages: [
                        { role: 'system', content: 'Preparatore atletico. Solo JSON valido.' },
                        { role: 'user', content: prompt }
                    ]
                });
                
                return parseAiJsonOrThrow(response.content, 'Test Profile');
            });
        }
        
        // Esponi funzioni globalmente
        window.runAIStressTest = runAIStressTest;
        window.testProfile = testProfile;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ðŸ”¬ SCIENTIFIC VALIDATION TEST
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function runScientificTest(options = {}) {
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ”¬ GR PERFORM - NASA-LEVEL SCIENTIFIC WORKOUT VALIDATION                    â•‘
â•‘  Testing AI-generated workouts against scientific criteria                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            `);
            
            if (!window.ScientificWorkoutValidator) {
                console.error('âŒ ScientificWorkoutValidator not loaded!');
                return;
            }
            
            const sports = options.sports || ['calcio', 'basket', 'boxe', 'palestra'];
            const maxPerSport = options.maxPerSport || 2;
            
            const allResults = [];
            const sportScores = {};
            
            for (const sport of sports) {
                const profiles = window.AIStressTest.testProfiles[sport] || [];
                const toTest = profiles.slice(0, maxPerSport);
                sportScores[sport] = { scores: [], passed: 0, failed: 0 };
                
                console.log(`\nðŸ… Testing ${sport.toUpperCase()} (${toTest.length} profili)...`);
                console.log('â”€'.repeat(60));
                
                for (const profile of toTest) {
                    try {
                        // Genera workout con AI + REGOLE SCIENTIFICHE
                        const ctxLines = [
                            `ATLETA: ${profile.name}`,
                            `Sport: ${profile.sport.toUpperCase()}`,
                            `Ruolo: ${profile.role || profile.goal || 'N/A'}`,
                            `Livello: ${profile.level}`,
                            `EtÃ : ${profile.age} anni | Peso: ${profile.weight}kg`,
                            profile.injuries?.length ? `âš ï¸ INFORTUNI: ${profile.injuries.join(', ')}` : '',
                            profile.goals?.length ? `ðŸŽ¯ OBIETTIVI: ${profile.goals.join(', ')}` : '',
                            profile.fight_week ? 'âš¡ FIGHT WEEK!' : ''
                        ].filter(Boolean).join('\n');
                        
                        // ðŸ“‹ INIETTA REGOLE SCIENTIFICHE
                        const scientificRules = window.ScientificPromptRules 
                            ? window.ScientificPromptRules.generatePrompt(profile.sport, profile)
                            : '';
                        
                        const prompt = `Genera workout scientificamente ottimale per:
${ctxLines}

${scientificRules}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ðŸ“¤ OUTPUT RICHIESTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Output SOLO JSON valido:
{"title":"Titolo descrittivo","exercises":[{"name":"Esercizio","sets":3,"reps":"10-12","type":"strength"}]}

TYPES: warmup | strength | hypertrophy | power | conditioning | cooldown
ESERCIZI: 6-10 totali (inclusi warm-up e cool-down)

${profile.injuries?.length ? `âš ï¸ EVITA ASSOLUTAMENTE esercizi che stressano: ${profile.injuries.join(', ')}` : ''}
${profile.fight_week ? 'âš¡ FIGHT WEEK: Solo attivazione leggera!' : ''}`;
                        
                        const response = await groqChat({
                            model: GROQ_MODELS.main,
                            temperature: 0.4,
                            max_tokens: 1500,
                            messages: [
                                { role: 'system', content: `Sei un preparatore atletico d'elite con conoscenze di biomeccanica, fisiologia e prevenzione infortuni.
Segui RIGOROSAMENTE le regole scientifiche fornite.
Rispondi SOLO con JSON valido, nessun altro testo.` },
                                { role: 'user', content: prompt }
                            ]
                        });
                        
                        const workout = parseAiJsonOrThrow(response.content, 'Scientific Test');
                        
                        // ðŸ”¬ VALIDAZIONE SCIENTIFICA
                        const validation = window.ScientificWorkoutValidator.validate(workout, profile);
                        
                        // Risultato
                        const passed = validation.score >= 70;
                        const icon = passed ? 'âœ…' : 'âŒ';
                        
                        console.log(`${icon} ${profile.name}: ${validation.score}% (${validation.grade.letter})`);
                        
                        if (validation.summary.errors > 0) {
                            validation.summary.criticalIssues.slice(0, 2).forEach(issue => {
                                console.log(`   â””â”€ ${issue}`);
                            });
                        }
                        
                        sportScores[sport].scores.push(validation.score);
                        if (passed) sportScores[sport].passed++;
                        else sportScores[sport].failed++;
                        
                        allResults.push({
                            profile: profile.id,
                            sport,
                            workout,
                            validation
                        });
                        
                        // Rate limiting
                        await new Promise(r => setTimeout(r, 800));
                        
                    } catch (err) {
                        console.error(`ðŸ’¥ ${profile.name}: ${err.message}`);
                        sportScores[sport].failed++;
                    }
                }
            }
            
            // Riepilogo finale
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ“Š RISULTATI VALIDAZIONE SCIENTIFICA                                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
            
            let grandTotal = 0;
            let grandCount = 0;
            
            for (const [sport, data] of Object.entries(sportScores)) {
                const avg = data.scores.length > 0 
                    ? Math.round(data.scores.reduce((a, b) => a + b, 0) / data.scores.length)
                    : 0;
                const grade = avg >= 90 ? 'A+' : avg >= 80 ? 'A' : avg >= 70 ? 'B' : avg >= 60 ? 'C' : 'D';
                const bar = 'â–ˆ'.repeat(Math.round(avg / 10)) + 'â–‘'.repeat(10 - Math.round(avg / 10));
                
                console.log(`â•‘  ${sport.toUpperCase().padEnd(12)} ${bar} ${String(avg).padStart(3)}% (${grade}) | âœ…${data.passed} âŒ${data.failed}`);
                
                grandTotal += avg * data.scores.length;
                grandCount += data.scores.length;
            }
            
            const overallScore = grandCount > 0 ? Math.round(grandTotal / grandCount) : 0;
            const overallGrade = overallScore >= 90 ? 'A+' : overallScore >= 80 ? 'A' : overallScore >= 70 ? 'B' : overallScore >= 60 ? 'C' : 'D';
            
            console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ðŸŽ¯ OVERALL SCIENTIFIC SCORE: ${overallScore}% (${overallGrade})                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
            
            window.lastScientificTest = allResults;
            console.log('ðŸ’¾ Risultati dettagliati in window.lastScientificTest');
            
            return allResults;
        }
        
        // Validazione singolo workout
        function validateWorkout(workout, profile = {}) {
            if (!window.ScientificWorkoutValidator) {
                console.error('âŒ ScientificWorkoutValidator not loaded!');
                return;
            }
            
            const validation = window.ScientificWorkoutValidator.validate(workout, profile);
            console.log(window.ScientificWorkoutValidator.formatReport(validation));
            return validation;
        }
        
        window.runScientificTest = runScientificTest;
        window.validateWorkout = validateWorkout;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ðŸ§¬ ATLAS COMPARATIVE TEST - Con vs Senza ATLAS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function runATLASComparison(options = {}) {
            const allSports = options.sports || ['calcio', 'basket', 'boxe', 'palestra'];
            const maxPerSport = options.maxPerSport || 2;
            
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ§¬ ATLAS COMPARATIVE TEST                                                   â•‘
â•‘  Testing: Standard Prompts vs ATLAS First-Principles Prompts                 â•‘
â•‘  Sports: ${allSports.join(', ').padEnd(55)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            `);
            
            const sports = options.sports || ['calcio', 'basket'];
            const results = { standard: [], atlas: [] };
            
            for (const sport of allSports) {
                const profiles = window.AIStressTest.testProfiles[sport]?.slice(0, maxPerSport) || [];
                
                for (const profile of profiles) {
                    console.log(`\nðŸ”„ Testing ${profile.name}...`);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TEST 1: Standard Prompt (senza ATLAS)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    const standardPrompt = `Genera workout per ${profile.name}, ${profile.sport}, livello ${profile.level}.
Output JSON: {"title":"...","exercises":[{"name":"...","sets":3,"reps":"10","type":"strength"}]}`;
                    
                    try {
                        const stdResponse = await groqChat({
                            model: GROQ_MODELS.main,
                            temperature: 0.5,
                            max_tokens: 1200,
                            messages: [
                                { role: 'system', content: 'Preparatore atletico. Solo JSON.' },
                                { role: 'user', content: standardPrompt }
                            ]
                        });
                        
                        const stdWorkout = parseAiJsonOrThrow(stdResponse.content, 'Standard');
                        const stdValidation = window.ScientificWorkoutValidator.validate(stdWorkout, profile);
                        
                        results.standard.push({
                            profile: profile.name,
                            sport,
                            score: stdValidation.score,
                            grade: stdValidation.grade.letter
                        });
                        
                        console.log(`   ðŸ“‹ Standard: ${stdValidation.score}% (${stdValidation.grade.letter})`);
                        
                    } catch (e) {
                        console.error(`   âŒ Standard failed: ${e.message}`);
                        results.standard.push({ profile: profile.name, sport, score: 0, grade: 'F' });
                    }
                    
                    await new Promise(r => setTimeout(r, 500));
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TEST 2: ATLAS Prompt (con First Principles)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    const atlasPrompt = window.ATLAS.generatePrompt(profile) + `

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
OUTPUT RICHIESTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Genera JSON: {"title":"...","exercises":[{"name":"...","sets":3,"reps":"10","type":"strength|power|hypertrophy|warmup|cooldown"}]}

- 6-10 esercizi totali
- Rispetta TUTTI i principi sopra
${profile.injuries?.length ? `- âš ï¸ EVITA esercizi per: ${profile.injuries.join(', ')}` : ''}`;
                    
                    try {
                        const atlasResponse = await groqChat({
                            model: GROQ_MODELS.main,
                            temperature: 0.4,
                            max_tokens: 1500,
                            messages: [
                                { role: 'system', content: `Sei un sistema di intelligenza artificiale che RAGIONA con principi primi della fisiologia.
Non sei un database di esercizi. Sei un PENSATORE.
Prima di generare, applica internamente ogni principio.
Rispondi SOLO con JSON valido.` },
                                { role: 'user', content: atlasPrompt }
                            ]
                        });
                        
                        const atlasWorkout = parseAiJsonOrThrow(atlasResponse.content, 'ATLAS');
                        const atlasValidation = window.ScientificWorkoutValidator.validate(atlasWorkout, profile);
                        
                        results.atlas.push({
                            profile: profile.name,
                            sport,
                            score: atlasValidation.score,
                            grade: atlasValidation.grade.letter
                        });
                        
                        console.log(`   ðŸ§¬ ATLAS:    ${atlasValidation.score}% (${atlasValidation.grade.letter})`);
                        
                        // Calcola improvement
                        const stdScore = results.standard[results.standard.length - 1]?.score || 0;
                        const improvement = atlasValidation.score - stdScore;
                        const emoji = improvement > 0 ? 'ðŸ“ˆ' : improvement < 0 ? 'ðŸ“‰' : 'âž¡ï¸';
                        console.log(`   ${emoji} Î” = ${improvement > 0 ? '+' : ''}${improvement}%`);
                        
                    } catch (e) {
                        console.error(`   âŒ ATLAS failed: ${e.message}`);
                        results.atlas.push({ profile: profile.name, sport, score: 0, grade: 'F' });
                    }
                    
                    await new Promise(r => setTimeout(r, 800));
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RISULTATI FINALI
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const avgStandard = results.standard.reduce((s, r) => s + r.score, 0) / results.standard.length;
            const avgAtlas = results.atlas.reduce((s, r) => s + r.score, 0) / results.atlas.length;
            const improvement = avgAtlas - avgStandard;
            
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ“Š RISULTATI COMPARATIVI                                                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                              â•‘
â•‘    ðŸ“‹ STANDARD PROMPTS:  ${String(Math.round(avgStandard)).padStart(3)}%                                          â•‘
â•‘    ðŸ§¬ ATLAS PROMPTS:     ${String(Math.round(avgAtlas)).padStart(3)}%                                          â•‘
â•‘                                                                              â•‘
â•‘    ${improvement >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰'} IMPROVEMENT:       ${improvement >= 0 ? '+' : ''}${improvement.toFixed(1)}%                                          â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
            
            if (improvement > 5) {
                console.log('âœ… ATLAS significantly improves workout quality!');
            } else if (improvement > 0) {
                console.log('âœ… ATLAS shows marginal improvement.');
            } else {
                console.log('âš ï¸ No improvement detected - may need prompt tuning.');
            }
            
            window.lastATLASComparison = results;
            return results;
        }
        
        window.runATLASComparison = runATLASComparison;
        
        console.log('ðŸ§ª AI Stress Test ready!');
        console.log('   â†’ runAIStressTest() - Test completo tutti gli sport');
        console.log('   â†’ runAIStressTest({sports: ["calcio"], maxPerSport: 2}) - Test specifico');
        console.log('   â†’ testProfile("calcio_ala_velocista") - Test singolo profilo');
        console.log('');
        console.log('ðŸ”¬ Scientific Validation ready!');
        console.log('   â†’ runScientificTest() - NASA-level validation all sports');
        console.log('   â†’ runScientificTest({sports: ["boxe"], maxPerSport: 3}) - Specific sport');
        console.log('   â†’ validateWorkout(workout, profile) - Validate single workout');
        console.log('');
        console.log('ðŸ§¬ ATLAS Comparison ready!');
        console.log('   â†’ runATLASComparison() - Compare Standard vs ATLAS prompts');
        console.log('   â†’ runATLASComparison({sports: ["calcio"]}) - Specific sport comparison');
        console.log('   â†’ debugBasketWorkout() - Debug basket validation');
        
        // Debug function per basket
        window.debugBasketWorkout = async function() {
            const basketProfile = {
                sport: 'basket',
                level: 'intermedio',
                goal: 'potenza',
                duration: 60,
                gender: 'M',
                age: 22,
                position: 'playmaker',
                name: 'Test Basket'
            };
            
            const atlasPrompt = window.ATLAS.metaPromptGenerator.generate(basketProfile);
            console.log('ðŸ“‹ ATLAS PROMPT per Basket (ultimi 1500 char):');
            console.log(atlasPrompt.slice(-1500));
            
            console.log('\\nðŸ”„ Generating workout...');
            
            // Chiamata corretta a groqChat con oggetto
            const response = await groqChat({
                model: 'llama-3.3-70b-versatile',
                messages: [{ role: 'user', content: atlasPrompt }],
                temperature: 0.3,
                max_tokens: 1500
            });
            
            // Parse JSON dalla risposta
            let workout;
            try {
                let content = response.content || response.data?.choices?.[0]?.message?.content || '';
                // Rimuovi markdown code blocks se presenti
                content = content.replace(/```json\n?/gi, '').replace(/```\n?/g, '').trim();
                workout = typeof content === 'string' ? JSON.parse(content) : content;
            } catch (e) {
                console.error('âŒ Failed to parse workout:', e);
                console.log('Raw response:', response);
                return null;
            }
            
            console.log('\\nðŸ“Š WORKOUT GENERATO:');
            console.log('Esercizi:', workout.exercises?.map(e => e.name));
            
            console.log('\\nðŸ”¬ VALIDAZIONE:');
            const validation = window.ScientificWorkoutValidator.validate(workout, basketProfile);
            console.log('Score:', validation.score);
            console.log('Grade:', validation.grade);
            console.log('Categories:');
            if (validation.results && Array.isArray(validation.results)) {
                validation.results.forEach(r => {
                    console.log(`  ${r.category}: ${r.score}/${r.maxScore}`);
                    if (r.findings && Array.isArray(r.findings)) {
                        r.findings.forEach(f => console.log(`    ${f.msg}`));
                    }
                });
            } else {
                console.log('Results structure:', validation);
            }
            
            // Debug specifica basket
            const names = workout.exercises?.map(e => (e.name || '').toLowerCase()).join(' ') || '';
            console.log('\\nðŸ€ DEBUG BASKET KEYWORDS:');
            console.log('Names string:', names);
            console.log('Has jump:', names.includes('jump'));
            console.log('Has box:', names.includes('box'));
            console.log('Has squat:', names.includes('squat'));
            console.log('Has lunge:', names.includes('lunge'));
            console.log('Has lateral:', names.includes('lateral'));
            console.log('Has calf:', names.includes('calf'));
            console.log('Has single:', names.includes('single'));
            
            return { workout, validation, names };
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ðŸŽ¯ TEST SINGOLO SPORT CON SCHEDA VISIBILE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        window.testSport = async function(sport = 'calcio', showDetails = true) {
            const profiles = {
                calcio: { sport: 'calcio', level: 'intermedio', goal: 'potenza', duration: 60, gender: 'M', age: 24, position: 'centrocampista', name: 'Test Calcio' },
                basket: { sport: 'basket', level: 'intermedio', goal: 'potenza', duration: 60, gender: 'M', age: 22, position: 'playmaker', name: 'Test Basket' },
                boxe: { sport: 'boxe', level: 'intermedio', goal: 'potenza', duration: 60, gender: 'M', age: 26, name: 'Test Boxe' },
                palestra: { sport: 'palestra', level: 'intermedio', goal: 'ipertrofia', duration: 75, gender: 'M', age: 28, name: 'Test Palestra' }
            };
            
            const profile = profiles[sport] || profiles.calcio;
            
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸŽ¯ TEST SINGOLO: ${sport.toUpperCase().padEnd(58)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            `);
            
            // Genera prompt ATLAS
            const atlasPrompt = window.ATLAS.metaPromptGenerator.generate(profile);
            
            if (showDetails) {
                console.log('ðŸ“‹ PROMPT INVIATO (ultimi 2000 caratteri):');
                console.log(atlasPrompt.slice(-2000));
            }
            
            console.log('\\nâ³ Generazione in corso...');
            
            // Chiama AI
            const response = await groqChat({
                model: 'llama-3.3-70b-versatile',
                messages: [{ role: 'user', content: atlasPrompt }],
                temperature: 0.3,
                max_tokens: 1500
            });
            
            // Parse risposta
            let workout;
            try {
                let content = response.content || '';
                content = content.replace(/\`\`\`json\\n?/gi, '').replace(/\`\`\`\\n?/g, '').trim();
                workout = JSON.parse(content);
            } catch (e) {
                console.error('âŒ Errore parsing JSON:', e);
                console.log('Raw:', response.content?.slice(0, 500));
                return null;
            }
            
            // Mostra scheda
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ“‹ SCHEDA GENERATA: ${(workout.title || 'Workout').slice(0, 52).padEnd(52)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
            
            workout.exercises?.forEach((ex, i) => {
                const name = (ex.name || '').slice(0, 40).padEnd(40);
                const sets = String(ex.sets || '').padStart(2);
                const reps = String(ex.reps || '').padEnd(8);
                const type = (ex.type || '').slice(0, 10).padEnd(10);
                console.log(`â•‘  ${String(i+1).padStart(2)}. ${name} ${sets} x ${reps} [${type}]  â•‘`);
            });
            
            console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
            
            // Validazione
            const validation = window.ScientificWorkoutValidator.validate(workout, profile);
            
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ”¬ VALIDAZIONE SCIENTIFICA                                                   â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SCORE: ${String(validation.score).padStart(3)}% | GRADE: ${validation.grade?.letter || 'N/A'} (${(validation.grade?.label || '').padEnd(20)})          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
            
            // Mostra punteggi per categoria
            if (validation.analyses) {
                for (const [key, data] of Object.entries(validation.analyses)) {
                    const bar = 'â–ˆ'.repeat(Math.round(data.score / 10)) + 'â–‘'.repeat(10 - Math.round(data.score / 10));
                    console.log(`â•‘  ${key.padEnd(20)} ${bar} ${String(data.score).padStart(3)}%                 â•‘`);
                }
            }
            
            console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
            
            // Mostra findings importanti
            if (showDetails && validation.allFindings) {
                console.log('\\nðŸ“Š DETTAGLI VALIDAZIONE:');
                validation.allFindings.slice(0, 15).forEach(f => {
                    console.log(`   ${f.msg}`);
                });
            }
            
            // Validazione principi
            if (window.ATLASPrinciples) {
                const principleFindings = window.ATLASPrinciples.validateAgainstPrinciples(workout, profile);
                if (principleFindings.length > 0) {
                    console.log('\\nðŸ§¬ PRINCIPI NON RISPETTATI:');
                    principleFindings.forEach(f => console.log(`   ${f.msg}`));
                } else {
                    console.log('\\nâœ… Tutti i principi fondamentali rispettati!');
                }
            }
            
            return { workout, validation, profile };
        };
        
        console.log('\\nðŸŽ¯ Test singolo sport:');
        console.log('   â†’ testSport("calcio") - Testa calcio con scheda visibile');
        console.log('   â†’ testSport("basket") - Testa basket');
        console.log('   â†’ testSport("boxe") - Testa boxe');
        console.log('   â†’ testSport("palestra") - Testa palestra');
    </script>
</body>
</html>